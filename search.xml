<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VsCode使用jupyter时附加交互窗口</title>
      <link href="/2024/04/30/vscodeNotebook/"/>
      <url>/2024/04/30/vscodeNotebook/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-2">前言</h2><p>Vscode里使用jupyter notebook是很方便的事情，但我习惯使用F9逐行运行。这样方便调试和查看变量。但是在notebook中使用F9跳出的交互窗口与notebook本身并不共享内存，也就是在交互窗口与notebook之间数据不互通。Github上也有不少帖子在呼吁这一功能的增加，例如<a href="https://github.com/microsoft/vscode-jupyter/issues/4573">Support a notebook “scratch pad” and/or integrate interactive window experience for notebooks · Issue #4573 · microsoft/vscode-jupyter (github.com)</a> 和 <a href="https://github.com/microsoft/vscode-jupyter/issues/6484">Support a scratchpad for a jupyter notebook · Issue #6484 · microsoft/vscode-jupyter (github.com)</a>。 目前有一个可行的解决方案来自第二个链接。</p><h2 id="jupyter-添加conda环境">jupyter 添加conda环境</h2><p>jupyter使用的比较少，我才发现在使用之前需要先做一些操作才能找到conda环境</p><p>如果jupyter显示内核不可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --user</span><br></pre></td></tr></table></figure><p>如果找不到自己的conda环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --user --name 环境名</span><br></pre></td></tr></table></figure><h2 id="从终端启动notebook">从终端启动notebook</h2><p>这个可行方案需要将notebook和交互窗口链接到同一个内核上。在终端命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>会输出一个URL链接，形如 <code>http://localhost:8889/?token=a8dfgfdgfd757fdfsggsgb3687e8967fbdfhfdhgdgdfgcff</code> 。</p><p>点击Vscode notebook的选择内核—&gt;选择其他内核—&gt;现有jupyter服务器。 输入以上URL，取一个名字例如test1。选择自己的conda环境。</p><p>这样notebook就配置好了。在使用F9后会出现交互窗口，交互窗口需要选择内核—&gt;选择其他内核—&gt;现有jupyter服务器。 选择test1，选择和notebook同样的环境(会出现<code>1连接</code> 的字样，就选择这一个，因为这正是notebook所正在连接的)。 然后就配置完成啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode连接到集群的计算节点</title>
      <link href="/2024/04/24/computeNode/"/>
      <url>/2024/04/24/computeNode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-8">前言</h2><p>最近拿到了大装置的账号，在大装置中用户在登陆节点登陆，在网络节点下载，在计算节点计算。VsCode可以正常连接到登陆节点，但在登陆节点运行程序、处理数据会引起节点拥堵。应当进一步连到计算节点上进行处理数据。</p><h2 id="申请计算节点">申请计算节点</h2><p>大装置上的调度系统是slurm，可使用 <code>salloc</code> 申请计算节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salloc -n 1 -c 1 -p cpu_single --mem=50G</span><br></pre></td></tr></table></figure><p>在debug分区，申请ntask=1, cpu=1的节点资源, 申请50G内存，内存太小读取数据会导致崩溃</p><p>使用 <code>squeue</code> 查询申请到的节点名，假如是 <code>a3105n01</code></p><h2 id="跳板机">跳板机</h2><p>查询网络教程，我发现大神们是通过本地计算机作为”跳板“连接到计算节点的。首先应当在本地cmd中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>一路回车，将在<code>C:/User/用户名/.ssh/</code>下生成 <code>id_rsa.pub</code></p><h2 id="添加密钥">添加密钥</h2><p>假设我们已经在登陆节点login02上使用xshell登陆。将 <code>id_rsa.pub</code>改名<code>myDesktop_id_rsa.pub</code>上传到 <code>~/.ssh/</code>。然后将密钥添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> myDesktop_id_rsa.pub &gt;&gt; ./authorized_keys</span><br></pre></td></tr></table></figure><h2 id="更改VsCode-config">更改VsCode config</h2><p>打开VsCode的SSH配置文件，添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是连接登陆节点的配置</span></span><br><span class="line">Host earthlab_vscode <span class="comment"># 名字随便</span></span><br><span class="line">    HostName login.earthlab.iap.ac.cn</span><br><span class="line">    User elzd_2024_000125</span><br><span class="line">    IdentityFile <span class="string">&quot;c:\Users\dzz\Desktop\login.earthlab.iap.ac.cn_0419125906_rsa.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是连接计算节点的配置</span></span><br><span class="line">Host earthlab_Py_debug  <span class="comment"># 名字随便</span></span><br><span class="line">    HostName a3105n01</span><br><span class="line">    User elzd_2024_000125</span><br><span class="line">    ProxyCommand ssh.exe -W %h:%p earthlab_vscode <span class="comment"># 注意是ssh.exe,不是ssh</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CESM的安装及运行</title>
      <link href="/2024/03/21/CESM/"/>
      <url>/2024/03/21/CESM/</url>
      
        <content type="html"><![CDATA[<h2 id="关于CESM的安装">关于CESM的安装</h2><ul><li><p>总的过程下来，安装的问题基本出在 <code>config_machines.xml</code> 和 <code>config_compilers.xml</code> 上。 对于这两个文件一定要根据自己的机器情况进行设置。</p></li><li><p>除此之外，在安装过程中，库的依赖库需要统一。例如在编译 <code>esmf</code> 时使用的是 <code>mpich</code> , 而在配置CESM时，我设置的是 <code>openmpi</code>。 这就导致在 <code>./case.build</code> 中出现 <code>mct</code> 等报错问题，最后我删除了<code>esmf</code> 用<code>openmpi</code> 重新编译解决了问题。 应该把CESM所有的库，以及这些库的依赖库都统一起来 (类似的还有<code>pnetcdf</code> 也应该统一成用<code>openmpi</code> 编译)。</p></li><li><p>另一个问题是网络问题，不过是在<code>./manage_externals/checkout_externals</code> 还是 <code>./case.submit</code> 都需要从网络下载一些文件。然而网络被墙，这些步骤频繁失败。解决方案可以是在本地开启<code>Clash</code> 代理，然后在<code>linux</code> 中开启使用本地的代理，从而让<code>linux</code> 连上本地开启的VPN。</p></li><li><p>还有一个关于Lapack的问题。这个库的编译参照<a href="https://zhuanlan.zhihu.com/p/520848641">linux关于blas、lapack的安装和使用 - 知乎 (zhihu.com)</a> 但安装好在./case.build会出现类似<code>glam_strs2.F90:(.text+0x888): undefined reference to dcopy_</code> 的报错。主要是因为在gcc编译中链接库的顺序问题。解决方案是在config_compilers.xml的<code>&lt;SLIBS&gt;</code>中添加 <code> &lt;append&gt;-L/disk1/xhw/libs/lapack/lib -llapacke -llapack -lcblas -lrefblas -lm -lgfortran&lt;/append&gt;</code></p></li><li><p>build时报错 <code>relocation truncated to fit r_x86_64_32s against .data'</code> 。由于编译内存不足需要增加内存，在 <code>config_compilers.xml</code> 的 <code>FFLAGS</code> 里添加 <code>-mcmodel=medium</code>。<a href="https://blog.csdn.net/ai297313/article/details/42711837">GCC 编译错误 relocation truncated to fit: R_X86_64_32S against `.bss’_relocation truncated to fit 错误-CSDN博客</a></p></li><li><p>submit后运行中断并报错<code>prterun noticed that process rank 2 with PID 313682 on node charney exited on signal 11 (Segmentation fault)</code>.原因是编译参数限制了堆栈的大小，不利于并行计算。输入<code>ulimit -s unlimited</code> 解决。<a href="https://muchong.com/html/201308/6230859.html">并行计算错误提示 - 第一原理 - 小木虫 - 学术 科研 互动社区 (muchong.com)</a></p></li><li><p>./case.submit后 <code>ERROR: No result from jobs [('case.run', None), ('case.st_archive', 'case.run or case.test')]</code> 。一方面case默认跑5天，但以月平均输出。由于5天run不足以输出月平均，所以就<code>no result</code>。可以修改<code>./xmlchange STOP_N=1,STOP_OPTION=nmonths</code>。另一方面即使修改了运行时长，如果你的机器没有batch（任务调度系统），那么仍然会输出这个错误。但在<code>archive</code>里可以找到运行输出的历史文件，这样的情况下可以忽视这个报错。[<a href="https://bb.cgd.ucar.edu/cesm/threads/case-submit-error-error-no-result-from-jobs-case-run-none-case-st_archive-case-run-or-case-test.5740/#post-38647">case.submit error] ERROR: No result from jobs [(‘case.run’, None), (‘case.st_archive’, ‘case.run or case.test’)] | DiscussCESM Forums (ucar.edu)</a></p></li><li><p>一开始我使用的是系统自带的gcc，然后编译安装了一系列库。后来在编译运行CESM时，出现一些报错，发现可能是gcc版本太低导致的。于是我自己编译安装了高版本的gcc。这样的情况下，需要重新编译安装之前版本gcc编译的库，否则会出现类似<code>come from different version of gcc</code> 的错误。另外，自己编译安装gcc在某个文件夹下后，需要手动修改所有<code>gcc/lib64/*.la</code> 的<code>libdir='$gcc/lib64'</code>和<code>dependency_libs</code></p></li><li><p>FWHIST运行报错 <code> pio_support::pio_die:: myrank=-1 : ERROR: ionf_mod.F90:235 : NetCDF: Attempt to use feature that was not turned on when netCDF was built.MPI_ABORT was invoked on rank 1 in communicator MPI_COMM_WORLD</code> 。经历了用 <code>nccopy -k nc6 file.nc newfile.nc</code> 修改格式无果。最后在 <a href="https://bb.cgd.ucar.edu/cesm/threads/not-a-netcdf-error-for-ionf_mod-f90.3843/">Not a NetCDF error for ionf_mod.F90? | DiscussCESM Forums (ucar.edu)</a> 找到了答案。<code>./xmlchange PIO_TYPENAME='netcdf'</code></p></li><li><p>在大装置上还遇到了类似这个报错“<code>H5Zbzip2.c:6:18: fatal error: hdf5.h: No such file or directory</code>&quot;。在大装置上，库都是通过module load导入的。而大装置上的hdf5似乎在编译时没有开始并行功能，导致如上报错。 解决方案是我自己用intelmpi重新编译hdf5，./configure CC=mpiicc FC=mpiifort CXX=mpiicpc  --enable-parallel --enable-fortran --enable-shared --prefix=/home/ydn/opt/software/hdf5-1.10.6/build . 并导入该hdf5</p></li></ul><h2 id="CESM-文件夹结构">CESM 文件夹结构</h2><p><a href="https://imgse.com/i/pF2IJVU"><img src="https://s21.ax1x.com/2024/03/17/pF2IJVU.md.jpg" alt="pF2IJVU.md.jpg"></a></p><p><a href="https://imgse.com/i/pF2I1K0"><img src="https://s21.ax1x.com/2024/03/17/pF2I1K0.png" alt="pF2I1K0.png"></a></p><h2 id="CASE的建立到提交">CASE的建立到提交</h2><p>新建case</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/CESM/cime/scripts/</span><br><span class="line"></span><br><span class="line">./create_newcase --<span class="keyword">case</span> <span class="variable">$HOME</span>/CESM/cases/CASE --res RES --compset COMPSET --Mach myMach</span><br></pre></td></tr></table></figure><p>Setup：生成<code>case.run</code>; namelist<code>usr_nl_xxx</code>;  <code>CaseDocs</code>。 <code>pelayout</code> 被固定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./case.setup</span><br></pre></td></tr></table></figure><p>build</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./case.build</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./case.submit</span><br></pre></td></tr></table></figure><p>关于case的运行过程被记录在 <code>CaseStatus</code> 文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/CESM/cime/scripts/casename/CaseStatus</span><br></pre></td></tr></table></figure><h2 id="修改、查询-xml">修改、查询.xml</h2><p>-p 可以<strong>模糊查询</strong>名为<code>JOB_WALLCLOCK_TIME</code> 的变量设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xmlquery -p WALLCLOCK</span><br></pre></td></tr></table></figure><p>修改允许时长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xmlchange STOP_N=1,STOP_OPTION=nmonths</span><br></pre></td></tr></table></figure><p>修改pelayout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xmlchange NTASKS=xxx,NTHRDS=xxx,ROOTPE=xxx</span><br></pre></td></tr></table></figure><p>修改（在./case.setup之前）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xmlchange CONTINUE_RUN=TRUE</span><br></pre></td></tr></table></figure><p>或者直接修改 <code>env_run.xml</code></p><h2 id="namelist">namelist</h2><p>namelist文件在 <code>$CASEROOT</code> 里，CAM模块的namelist名为 <code>user_nl_cam</code></p><p>主要用于设置输出哪些变量，每几小时一平均，每个文件塞几个时次的变量</p><ul><li><strong><code>nhtfrq</code></strong>: 输出频率</li><li><strong><code>mfilt</code></strong>: 每个文件塞的时次数</li><li><strong><code>fincl</code></strong>: 额外增添一些变量</li></ul><p><code>nhtfrq</code></p><p><code>nhtfrq=0</code> 表示月平均输出，<code>nhtfrq&gt;0</code>按时间步长输出，<code>nhtfrq&lt;0</code>按小时输出</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nhtfrq = -<span class="number">24</span>  <span class="comment">! 逐日(24小时)</span></span><br><span class="line">nhtfrq = -<span class="number">3</span>  <span class="comment">! 逐3小时输出</span></span><br></pre></td></tr></table></figure><p><code>mfilt</code></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 逐日输出，每个文件里有365个时次</span></span><br><span class="line">nhtfrq = -<span class="number">24</span>   </span><br><span class="line">mfilt = <span class="number">365</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 对于逐月输出的情况，设置mfilt无效. For monthly frequency, we always have: <code>mfilt = 1</code>。 每个月作为一个文件是上限？不存在12个月为一个文件的情况？</p></blockquote><p><code>fincl</code></p><p>输出的历史文件的文件名会带有**<code>h0</code>**, <strong><code>h1</code></strong>, …, **<code>h9</code>**字段，一共至多有十个。<code>h0</code> 是默认输出的，带有这个字段的文件会输出模式默认输出的变量。如果我想增加几个变量输出，我可以进行一些设置<code>fincl2='xxx'</code>，这些变量会出现在<code>h1</code>字段的文件中。<code>fincl3</code> 控制<code>h2</code> …</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 在h0中以月平均输出默认变量。在h1中以逐小时输出UVT三个变量，十个小时为一个文件。在h2中以逐24小时输出UVT，十个小时为一个文件</span></span><br><span class="line">nhtfrq = <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">24</span> </span><br><span class="line">mfilt = <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span> </span><br><span class="line">fincl2 = <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;T&#x27;</span> </span><br><span class="line">fincl3 = <span class="string">&#x27;PRECT&#x27;</span></span><br></pre></td></tr></table></figure><p>默认情况是做平均输出，例如逐小时平均，逐24小时平均。可以通过添加flags变逐小时输出瞬时量。</p><ul><li><strong><code>A</code></strong> ==&gt; Average</li><li><strong><code>B</code></strong> ==&gt; GMT 00:00:00 average</li><li><strong><code>I</code></strong> ==&gt; Instantaneous</li><li><strong><code>M</code></strong> ==&gt; Minimum</li><li><strong><code>X</code></strong> ==&gt; Maximum</li><li><strong><code>L</code></strong> ==&gt; Local-time</li><li><strong><code>S</code></strong> ==&gt; Standard deviation</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 逐月平均输出默认变量。在h1中，每3小时输出TQUV的瞬时量</span></span><br><span class="line">fincl2   = <span class="string">&#x27;T:I&#x27;</span>,<span class="string">&#x27;Q:I&#x27;</span>,<span class="string">&#x27;U:I&#x27;</span>,<span class="string">&#x27;V:I&#x27;</span></span><br><span class="line">nhtfrq   = <span class="number">0</span>, -<span class="number">3</span> </span><br><span class="line">mfilt   = <span class="number">1</span>, <span class="number">8</span></span><br></pre></td></tr></table></figure><p>以上是CAM模块里的设置方法，对于海洋、陆面等模块的设置方法略有不同，参见 <a href="https://ncar.github.io/CESM-Tutorial/notebooks/namelist/output/output_cam.html">Customize CAM output — CESM Tutorial (ncar.github.io)</a></p><h3 id="如何关闭各分量的输出">如何关闭各分量的输出</h3><p><a href="https://bb.cgd.ucar.edu/cesm/threads/how-to-turn-off-cesm-history-output.7894/#post-47372">How to turn off CESM history output | DiscussCESM Forums (ucar.edu)</a></p><h2 id="附录">附录</h2><h3 id="xml-和-namelist-汇总">xml 和 namelist 汇总</h3><p><a href="https://www2.cesm.ucar.edu/models/cesm1.2/cesm/doc/modelnl/">CESM1.2 Model Component Namelists (ucar.edu)</a></p><h3 id="namelist-汇总">namelist 汇总</h3><p><a href="https://docs.cesm.ucar.edu/models/cesm2/settings/current/index.html">namelist</a></p><h3 id="compsets">compsets</h3><p><a href="https://docs.cesm.ucar.edu/models/cesm2/config/2.1.3/compsets.html">CESM2 Component Sets Definition (ucar.edu)</a></p><h3 id="variable-fields-汇总">variable fields 汇总</h3><p><a href="https://ncar.github.io/CAM/doc/build/html/users_guide/model-output.html#example-default-history-fields-and-master-field-lists">CAM</a></p><p><a href="https://ncar.github.io/CAM/doc/build/html/users_guide/model-output.html#example-default-history-fields-and-master-field-lists">POP</a></p><p><a href="https://www2.cesm.ucar.edu/models/cesm1.2/clm/models/lnd/clm/doc/UsersGuide/history_fields_table_40.xhtml">CLM</a></p><p><a href="https://ncar.github.io/CICE/users_guide/ice_history.html">CICE</a></p><p><a href="https://escomp.github.io/cism-docs/cism-in-cesm/versions/release-cesm2.0/html/controlling-output.html">CISM</a></p><h3 id="case-命名规则">case 命名规则</h3><p><a href="https://imgse.com/i/pF2IORs"><img src="https://s21.ax1x.com/2024/03/17/pF2IORs.png" alt="pF2IORs.png"></a></p><p><a href="https://www.cesm.ucar.edu/models/cesm2/naming-conventions">Naming Conventions | Community Earth System Model (ucar.edu)</a></p><h3 id="集群、节点、核心、任务">集群、节点、核心、任务</h3><p>集群：相当于一个机房，机房里有很多计算机。这些计算机的集合就是集群</p><p>节点：机房里的每个计算机相当于节点</p><p>核心：每个计算机的处理器核心</p><p>任务：例如跑一次CESM实验就是一次任务，这个任务可以拆分成若干小任务，每个小任务分配给核心。</p><h3 id="关于NTASKS，PES，MPITASK">关于NTASKS，PES，MPITASK</h3><p>XML设置中有若干设置并行计算的变量。经过一番探索初步摸清了它们的意义</p><table><thead><tr><th style="text-align:left">表头</th><th>表头</th></tr></thead><tbody><tr><td style="text-align:left">MAX_MPITASKS_PER_NODE</td><td>每个节点上<code>MPI task</code><strong>的最大数量</strong>。也可以在<code>config_machines.xml</code>里设置。</td></tr><tr><td style="text-align:left">MAX_TASKS_PER_NODE</td><td>所有分量每个节点上<code>(MPI tasks) * (threads)</code> 的总和。必须大于等于 <code>MAX_MPITASKS_PER_NODE</code>。也可以在 <code>config_machines.xml</code> 里设置。</td></tr><tr><td style="text-align:left">NTASKS</td><td>每个分量的<code>MPI task</code>数</td></tr><tr><td style="text-align:left">NTHRDS</td><td>每个分量每个任务的<code>threads</code>数。必须大于等于1。如果等于1，表示对应分量的并行关闭。</td></tr><tr><td style="text-align:left">ROOTPE</td><td><code>MPI task</code> 任务编号。</td></tr></tbody></table><p>对于一个case，如果</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTASKS_ATM = <span class="number">16</span></span><br><span class="line">NTHRDS_ATM = <span class="number">4</span></span><br><span class="line">ROOTPE_ATM = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">NTASKS_OCN = <span class="number">64</span></span><br><span class="line">NTHRDS_OCN = <span class="number">1</span></span><br><span class="line">ROOTPE_OCN = <span class="number">16</span></span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pFWvGCt"><img src="https://s21.ax1x.com/2024/03/20/pFWvGCt.png" alt="pFWvGCt.png"></a></p><p>从上图可以知道程序实际只用了80个tasks，那么程序会向服务器申请80个tasks和128个pes处理器。前16个task用于处理atm，每个task由4个pes负责计算。后64个tasks用于处理ocn，每个task由1个pes负责计算。</p><p>这80个tasks的是没有重叠的，atm和ocn同时计算。如果ROOTPE_OCN=0, 那么前16个task就是和atm重叠的，ocn的前16个task需要等atm计算完成才能开始计算。</p><p>如果这时候 <code>ROOTPE_OCN = 64</code></p><p><a href="https://imgse.com/i/pFWzGX8"><img src="https://s21.ax1x.com/2024/03/20/pFWzGX8.png" alt="pFWzGX8.png"></a></p><p>由于ocn的task编号从64开始，导致atm和ocn之间有48个task和pes不会被使用，但这些仍然由程序向服务器申请下来。</p><h3 id="Compset-字母意义">Compset 字母意义</h3><table><thead><tr><th>Designation</th><th>Active Components</th><th>Data Components</th><th>Notes</th></tr></thead><tbody><tr><td>A</td><td>–</td><td>various</td><td>All data components; used for software testing</td></tr><tr><td><strong>B</strong></td><td><strong>atm, lnd, ice, ocn</strong></td><td><strong>–</strong></td><td><strong>Fully active components</strong></td></tr><tr><td>C</td><td>ocn</td><td>atm, ice, rof</td><td></td></tr><tr><td>D</td><td>ice</td><td>atm, ocn, rof</td><td>Slab ocean model (SOM)</td></tr><tr><td>E</td><td>atm, lnd, ice</td><td>ocn</td><td>Slab ocean model (SOM)</td></tr><tr><td><strong>F</strong></td><td><strong>atm, lnd</strong></td><td><strong>ice, ocn</strong></td><td><strong>Sea ice in prescribed mode; some F compsets use fewer surface components</strong></td></tr><tr><td>G</td><td>ice, ocn</td><td>atm, rof</td><td></td></tr><tr><td>I</td><td>lnd</td><td>atm</td><td></td></tr><tr><td>J</td><td>lnd, ice, ocn</td><td>atm</td><td>Can be used to spin up the surface components</td></tr><tr><td><strong>P</strong></td><td><strong>atm</strong></td><td><strong>–</strong></td><td><strong>CAM PORT compsets</strong></td></tr><tr><td><strong>Q</strong></td><td><strong>atm</strong></td><td><strong>ocn</strong></td><td><strong>Aquaplanet compsets</strong></td></tr><tr><td>S</td><td>–</td><td>–</td><td>No components present; used for software testing</td></tr><tr><td>T</td><td>glc</td><td>lnd</td><td></td></tr><tr><td>X</td><td>–</td><td>–</td><td>Coupler-test components; used for software testing</td></tr></tbody></table><h3 id="关于BHIST和B1850">关于BHIST和B1850</h3><p>1850的强迫保持在工业化前水平，2000的强迫保持在near present day水平ya,hist的强迫则是随时间演化的，可以理解为近真实情景的强迫的时间演变。所以如果使用B1850,和BHIST使用相同的初始时间RUN_STARTDATE,两个case的演化也是非常不同的。</p><p>原文链接：<a href="https://blog.csdn.net/qq_27984679/article/details/134903532">https://blog.csdn.net/qq_27984679/article/details/134903532</a></p><h3 id="装库的一些编译选项">装库的一些编译选项</h3><p>ncview</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/disk1/xhw/opt/ncview --with-nc-config=<span class="variable">$libspath</span>/netcdf/bin/nc-config --with-udunits2_incdir=<span class="variable">$libspath</span>/udunits/include/ --with-udunits2_libdir=<span class="variable">$libspath</span>/udunits/lib/ --with-png_incdir=<span class="variable">$libspath</span>/libpng/include/ --with-png_libdir=<span class="variable">$libspath</span>/libpng/lib/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hdf5</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/hdf5 --with-zlib=/disk1/xhw/libs/zlib --enable-shared --enable-fortran --enable-parallel4 --enable-cxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#netcdf-c</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/netcdf LDFLAGS=<span class="string">&quot;-L/disk1/xhw/libs/hdf5/lib -L/disk1/xhw/libs/zlib/lib&quot;</span> CPPFLAGS=<span class="string">&quot;-I/disk1/xhw/libs/hdf5/include -I/disk1/xhw/libs/zlib/include&quot;</span> --enable-largefile --enable-netcdf-4 --enable-parallel4 --enable-shared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#netcdf-fortran</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/netcdf CPPFLAGS=-I/disk1/xhw/libs/netcdf/include LDFLAGS=-L/disk1/xhw/libs/netcdf/lib --enable-netcdf-4 --enable-shared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#netcdf-cxx</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/netcdf CPPFLAGS=-I/disk1/xhw/libs/netcdf/include LDFLAGS=-L/disk1/xhw/libs/netcdf/lib --enable-shared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#opempi</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/openmpi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pnetcdf</span></span><br><span class="line">./configure --prefix=/disk1/xhw/libs/pnetcdf --with-mpi=/disk1/xhw/libs/openmpi --enable-subfiling --enable-shared --enable-large-file-test --enable-null-byte-header-padding --enable-burst-buffering --enable-profiling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#lapack</span></span><br><span class="line">https://zhuanlan.zhihu.com/p/520848641</span><br><span class="line"><span class="built_in">cp</span> make.inc.example make.inc</span><br><span class="line">make blaslib</span><br><span class="line">make cblaslib</span><br><span class="line">make lapacklib</span><br><span class="line">make lapackelib</span><br></pre></td></tr></table></figure><h3 id="一些疑问">一些疑问</h3><ol><li>hybrid和branch区别，什么是hydrid，为什么新建case都是hydrid</li><li>pelayout到底改怎么规划</li><li>RUN_REFCASE和RUN_REFDATE是什么</li><li>BHIST和B1850的区别</li><li>很多文件的日期是从0001年开始算的，什么意思</li></ol><p>PIcontrol使用的是工业革命前的强迫，对1850年重复模拟500或者300年，模拟这么多年目的是为了使系统达到稳定。B1850则是在别人模拟好的PIcontrol实验的基础上，用他们得到的数据作为初始场（这也就是REFCASE的意义和REFDATE=0500或0300的原因）。而B1850其实也是PIcontrol, 从REFCESE读取初始场后B1850重复地对1850年进行模拟 (<a href="https://bb.cgd.ucar.edu/cesm/threads/suggestions-for-modifying-the-start-date-cesm2.4921/#post-35387">Suggestions for modifying the start date (CESM2) </a>， 所以B1850的STARTDATE是0001年这种形式，表示第一年、第二年…。如果随意改变B1850的REFDATE可能导致模式找不到初始场数据。如果改变STARTDATE，没有意义</p><p>BHIST是Historical run。使用的初始场来自于别人跑的Historical run。他的时间是推进的，例如第一年是1979，第二年就是1980…</p><p>以上说的基本都是hybrid，就运行的初始场是别人运行好的restart文件。通过咨询张贺老师了解到，CESM使用startup就相当于全部自己提供初始场，与WRF的运行方式相同了。如果只模拟几天则不需要spin up，如果运行超过一年则最好spin up.</p><ul><li>关于PElayout:</li></ul><p>以全部NTASK=4， NTHRDS=4,   ROOTPE=0，MAX_MPITASKS_PER_NODE=MAX_TASKS_PER_NODE=40 为例。这种情况下，每个分量占用4个并行任务，每个任务使用4个线程（4个核心）。由于ROOTPE相同，这些分量是按顺序依次运行的。</p><p>这个时候如果运行./preview_run将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nodes: 1</span><br><span class="line">total tasks: 4</span><br><span class="line">tasks per node: 4</span><br><span class="line">thread count: 4</span><br></pre></td></tr></table></figure><p>其中 <code>total task=4</code> 很好理解，因为所有NTAKS=4，ROOTPE=0即所有的分量在前四个TASK上运行。如果<code>ROOTPE_OCN=4</code>, 将有<code>total task=8</code> 。如果<code>ROOTPE_OCN=2</code>, 将有<code>total task=6</code> 。注意<code>total task</code>是<strong>总任务数</strong>， 这些个任务数会被分配到若干个<code>node</code>运行。是<code>node</code>数去适应<code>total taks</code>的变化。<code>total task</code>将只与我们对任务的排列分配(NTASK,ROOTPE)有关。</p><p>对于<code>tasks per node=4</code>，模式会优先将所有任务分配到一个<code>node</code>上。 因为我们设置了 <code>MAX_MPITASKS_PER_NODE=40</code>, 它是所有分量的<code>NTASKS</code>的最大值。  <code>MAX_MPITASKS_PER_NODE=40</code>远大于我们设置的<code>total tasks=4</code>, 所以这四个任务全部被放到了一个<code>node上</code>，所以<code>nodes=1， tasks per node=4</code></p><p>如果改变<code>MAX_MPITASKS_PER_NODE=3</code>，这意味着每个<code>node</code>上最多只能有3个任务，而我们一共有<code>total tasks=4</code> 。所以需要两个<code>node</code>。这时<code>nodes=2,  tasks per node=3</code>。(如果<code>total tasks &lt;= MAX_MPITASKS_PER_NODE</code>,  则 <code>tasks per node = MAX_MPITASKS_PER_NODE</code>。如果<code>total tasks &gt; MAX_MPITASKS_PER_NODE</code>,  则 <code>tasks per node &lt;= MAX_MPITASKS_PER_NODE</code>。)</p><p>由此我们知道<code>MAX_MPITASKS_PER_NODE</code>是限制每个<code>node</code>上的任务数用的。 相对的，<code>MAX_TASKS_PER_NODE</code>受限制每个<code>node</code>上 <code>NTASKS*NTHRDS</code>用的。例如现在<code>MAX_TASKS_PER_NODE=40</code>，而 <code>tasks per node * thread count=4*4=16</code> 那么这同样将使得<code>nodes=1</code>。如果改变<code>MAX_TASKS_PER_NODE=15</code>，那么<code>nodes</code>将增加为1，<code>tasks per node</code> 将减小到3以使得二者乘积小于15。这个过程中<code>total tasks</code>不变。</p><h3 id="未来计划">未来计划</h3><ol><li><p>看看文献，有没有人做个WACCM替换再分析，试着复现，建立 <strong>baseline</strong></p></li><li><p>试着用2°分辨率</p></li><li><p>试着预报爆发性增温</p></li><li><p>化学成分给气候态</p></li><li><p>MERRA2</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>气象知识随笔</title>
      <link href="/2024/03/08/atmosKnowledge/"/>
      <url>/2024/03/08/atmosKnowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-4">前言</h2><p>记录一些大气科学基础知识。例如水汽通量的定义和单位总是忘记。罗斯贝波波速也记不清。这篇文章就当是平时学习的note。</p><h2 id="水汽通量及散度">水汽通量及散度</h2><h2 id="罗斯贝波速">罗斯贝波速</h2><p>罗斯贝波频率：<br>$$<br>\begin{align}<br>\omega = Uk - \beta \frac{k} { { {k^2} + {l^2} } }<br>\end{align}<br>$$<br>相速度和群速度：<br>$$<br>\begin{align}<br>c &amp;= \frac{\omega } {k} = U - \frac{\beta } { { {k^2} + {l^2} } }\\<br>{c_g} &amp;= \frac{ {\partial \omega } } { {\partial k} } = U - \frac{ {\beta ({l^2} - {k^2})} } { { { { ( {k^2} + {l^2})}^2} } }<br>\end{align}<br>$$</p><h2 id="静力稳定度-Brunt-vaisala-frequency">静力稳定度/Brunt vaisala frequency</h2><p>$$<br>\begin{align}<br>{N^2} = \frac{g} {\theta }\frac{ {d\theta } } { {dz} }<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LBM 安装-运行-修改-debug</title>
      <link href="/2023/12/29/LBM/"/>
      <url>/2023/12/29/LBM/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言-2">前言</h2><p>LBM（linear baroclinic model）<a href="https://ccsr.aori.u-tokyo.ac.jp/~lbm/sub/lbm.html">LBM main (u-tokyo.ac.jp)</a>是日本人开发的线性斜压模式。它运行快，资源占用少，易上手。给定背景场和强迫场，可以得到大气的定常响应。利用LBM可以快速验证自己的猜测和结论。</p><p>这几天安装、运行、调试了LBM，大致摸清了整个流程。其中有许多坑点，但都被解决了，下文将记录安装运行流程和坑点。</p><h2 id="安装">安装</h2><p>首先需要向LBM的管理人员索要账号和密码以下载LBM，他的邮箱是 <a href="mailto:hayashi.michiya@nies.go.jp">hayashi.michiya@nies.go.jp</a></p><p>我的账号密码记录在所邮箱中。</p><p>接着安装LBM的流程基本是跟着洪海旭师兄在CDSN上的博文来的<a href="https://blog.csdn.net/weixin_42762673/article/details/124043455">LBM模式学习·保姆级安装及初步使用教程_lbm保姆-CSDN博客</a> 以及 <a href="https://www.cnblogs.com/jiangleads/p/11893290.html">线性斜压模式LBM学习&amp;安装实录 - chinagod - 博客园 (cnblogs.com)</a></p><p>两篇博文分别使用的是ICC和GCC编译模式，我只使用了GCC。第一篇博文提到<code>sysdep_linux20201125.tar.gz</code> 文件，也是从LBM官网上下载。</p><p>以下是文件结构</p><p><a href="https://imgse.com/i/piLQsOK"><img src="https://s11.ax1x.com/2023/12/29/piLQsOK.md.jpg" alt="piLQsOK.md.jpg"></a></p><h2 id="运行">运行</h2><h3 id="1-分辨率设置">1. 分辨率设置</h3><p>位置：$LNHOME/Lmake.inc</p><p>参见洪海旭博文</p><h3 id="2-生成可执行文件">2. 生成可执行文件</h3><p>位置: $LNHOME/model/src</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make lib lbm</span><br></pre></td></tr></table></figure><p>结果应在 $LNHOME/model/bin/linux 下生成一个 lbm2.t21ml20ctintgr (数字表示分辨率，随分辨率选择而改变)</p><h3 id="3-编译大气基本态">3. 编译大气基本态</h3><p>位置: $LNHOME/solver/util</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make bs</span><br></pre></td></tr></table></figure><p>位置: $LNHOME/solver/util/SETPAR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmcp cncep=<span class="string">&#x27;大气基本态.t21.grd&#x27;</span>,</span><br><span class="line">  cncep2=<span class="string">&#x27;大气基本态.ps.t21.grd&#x27;</span>, <span class="comment"># 地面气压</span></span><br><span class="line">  calt= <span class="string">&#x27;disk1/xhw/LBM/ln_solver/bs/gt3/grz/t21&#x27;</span>,</span><br><span class="line">  kmo=起始月份, navg=3三月平均, ozm=f是否纬向平均, osw=f是否纬向对称, ousez=t是否转化为sigma坐标系</span><br></pre></td></tr></table></figure><p>如果用EC模块，则改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmecm cecm=<span class="string">&#x27;大气基本态.t21.grd&#x27;</span>,</span><br><span class="line">  calt= <span class="string">&#x27;disk1/xhw/LBM/ln_solver/bs/gt3/grz/t21&#x27;</span>,</span><br><span class="line">  kmo=起始月份, navg=3三月平均, ozm=f是否纬向平均, osw=f是否纬向对称, ousez=t是否转化为sigma坐标系</span><br></pre></td></tr></table></figure><p>修改基本态文件输出位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmbs  cbs0=<span class="string">&#x27;/disk1/xhw/LBM/ln_solver/bs/gt3/ncepsum.t21l20&#x27;</span>,</span><br><span class="line"></span><br><span class="line">       cbs=<span class="string">&#x27;/disk1/xhw/LBM/ln_solver/bs/grads/ncepsum.t21l20.grd&#x27;</span></span><br></pre></td></tr></table></figure><p>生成大气基本态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./ncepsbs  # 调用NCEP模块</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line">$ ./ecmsbs  # 调用EC模块</span><br></pre></td></tr></table></figure><h3 id="4-编译大气强迫场">4. 编译大气强迫场</h3><p>位置: $LNHOME/solver/util/SETPAR</p><p>预先在 $LNHOME/data/ 下创建好 <code>frc</code> 文件夹和 <code>out</code> 文件夹用来存放强迫场和输出文件，文件夹名称可以根据case的内容自定义</p><p>修改强迫场输出位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmfin cfm=<span class="string">&#x27;/disk1/xhw/LBM/ln_solver/data/frc/frc.t21l20.classic.mat&#x27;</span>, <span class="comment"># 用不到可以不改</span></span><br><span class="line"></span><br><span class="line">       cfg=<span class="string">&#x27;/disk1/xhw/LBM/ln_solver/data/frc/frc.t21l20.classic.grd&#x27;</span> <span class="comment"># 强迫文件的输出位置，如果自己建立强迫场，不要把自建强迫场放在这</span></span><br><span class="line"></span><br><span class="line">       fact=1.0,1.0,1.0,1.0,1.0</span><br></pre></td></tr></table></figure><p>修改强迫方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmvar ovor=f, odiv=f, otmp=t, ops=f, osph=f</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 涡度强迫关闭，散度强迫关闭，温度强迫打开，地表气压强迫关闭，湿度强迫关闭</span></span><br></pre></td></tr></table></figure><p>强迫位置、形状</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmhpr khpr=1,  <span class="comment"># khpr=1/2代表椭圆/水平均匀的强迫</span></span><br><span class="line"></span><br><span class="line">       hamp=1.,  <span class="comment"># 振幅(单位是1/day)</span></span><br><span class="line"></span><br><span class="line">       xdil=40.,  <span class="comment"># xdil是纬向范围(就是多少个格点衰减到0)</span></span><br><span class="line"></span><br><span class="line">       ydil=12., <span class="comment"># ydil是经向范围</span></span><br><span class="line"></span><br><span class="line">       xcnt=210., <span class="comment"># xcnt是强迫的中心经度</span></span><br><span class="line"></span><br><span class="line">       ycnt=0.  <span class="comment"># ycnt是强迫的中心纬度</span></span><br><span class="line"></span><br><span class="line">&amp;end</span><br></pre></td></tr></table></figure><p>强迫廓线</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;nmvpr kvpr=2, <span class="comment"># kvpr是垂直廓线的函数(1.是正弦函数，2是gamma函数，3是上下均匀的)</span></span><br><span class="line"></span><br><span class="line">       vamp=8, <span class="comment"># 垂直廓线的振幅</span></span><br><span class="line"></span><br><span class="line">       vdil=20., <span class="comment"># 膨胀系数(仅在垂直廓线函数设置为gamma函数的时候才生效</span></span><br><span class="line"></span><br><span class="line">       vcnt=0.45 <span class="comment"># vcnt是垂直方向上强迫最大值所在的层次</span></span><br><span class="line"></span><br><span class="line">&amp;end</span><br></pre></td></tr></table></figure><p>所有参数的意思都可以查阅：$LNHOME/solver/util/param_list</p><p>编译并输出强迫场<br>位置: $LNHOME/solver/util</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">$ make</span><br><span class="line">$ ./mkfrcng</span><br></pre></td></tr></table></figure><h3 id="5-结合强迫场和基本态并运行模式">5. 结合强迫场和基本态并运行模式</h3><p>位置: $LNHOME/model/sh/tintgr<br>找一个 <code>.csh</code> 文件作为修改模板，可以选择 <code>linear-run.classic.copy.csh</code> ，修改以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setenv FDIR     <span class="variable">$LNHOME</span>/data/frc                 <span class="comment"># 强迫场所在位置</span></span><br><span class="line">setenv DIR      <span class="variable">$LNHOME</span>/data/out                 <span class="comment"># 模式输出位置</span></span><br><span class="line"></span><br><span class="line">setenv BSFILE   <span class="variable">$LNHOME</span>/bs/gt3/ncepsum.t21l20    <span class="comment"># 基本态位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setenv FRC      <span class="variable">$FDIR</span>/frc.t21l20.classic.grd      <span class="comment"># 用于强迫场随时间改变的情况，如果设置了SFRC</span></span><br><span class="line">  <span class="comment"># 这一项不生效</span></span><br><span class="line">setenv SFRC     <span class="variable">$FDIR</span>/frc.t21l20.classic.grd      <span class="comment"># 稳定强迫场的文件名，</span></span><br><span class="line">  <span class="comment"># 是之前我们./mkfrcng生成的强迫场。 如果自建强迫场，把自建强迫场路径放在这</span></span><br><span class="line"></span><br><span class="line">setenv TEND     59 <span class="comment"># 模式积分的时长，根据摸鱼咯的博客的说明可知，tend=51天的时候，模式运行20天，tend=59的时候模式运行27天，这里设置了tend=59，使其运行27天。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;nmtime start=0,1,1,0,0,0, end=0,1,<span class="variable">$TEND</span>,0,0,0             &amp;end <span class="comment"># 这一项作用未知，注意0,1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csh linear-run.classic.copy.csh</span><br></pre></td></tr></table></figure><h3 id="6-简短运行流程">6. 简短运行流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 编译模式</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/model/src</span><br><span class="line">make clean</span><br><span class="line">make lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 准备背景场（如果改背景场了，就必须从这步开始）</span></span><br><span class="line"><span class="comment"># 编辑SETPAR</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/solver/util</span><br><span class="line">make clean</span><br><span class="line">make bs</span><br><span class="line">./ncepsbs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译模式</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/model/src</span><br><span class="line">make clean.special</span><br><span class="line">make lbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 准备强迫场 (如果不改背景场，只做4和5就行)</span></span><br><span class="line"><span class="comment"># 编辑SETPAR</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/solver/util</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./mkfrcng</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 运行模式</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/model/sh/tintgr</span><br><span class="line">csh linear-run.classic.copy3.csh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 用 gt2gr 输出合并的grd</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/solver/util</span><br><span class="line">./gt2gr</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/data/out_indianOcean</span><br><span class="line">cdo -f nc import_binary combinedt42.ctl combined.nc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 强迫场转nc</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$LNHOME</span>/data/frc_indianOcean</span><br><span class="line">cdo -f nc import_binary frc.t42l20.classic.ctl frc.t42l20.classic.nc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行Debug">运行Debug</h2><p>如果出现如下错误,  是 <code>/disk1/xhw/LBM/ln_solver/model/src/sysdep/Makedef.linux</code> 和 <code>/disk1/xhw/LBM/ln_solver/model/src/sysdep/Makedef.linux</code>没有设置好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不应该是 -convert big_endian , 这种写法是icc的写法。我用的是gcc，应该在Makedef.linux 中改成 -fconvert=bing-endian</span><br><span class="line"></span><br><span class="line">gfortran -O2 -u -mcmodel=medium -shared-intel -convert big_endian -no-vec    -I/disk1/xhw/LBM/ln_solver/model/src/include  -DSYS_AVATAR -DSYS_UNIX -DCODE_ASCII -DCODE_IEEE -DOPT_NOPHYSICS -DOPT_NOUSER -DOPT_CLASSIC -I/disk1/xhw/LBM/ln_solver/model/src/include   -c -o pmisc.o pmisc.F</span><br><span class="line">gfortran: error: big_endian: No such file or directory</span><br><span class="line">gfortran: error: unrecognized command line option ‘-shared-intel’</span><br><span class="line">gfortran: error: unrecognized command line option ‘-convert’</span><br><span class="line">gfortran: error: unrecognized command line option ‘-no-vec’</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这个错误是啥原因忘记了</span><br><span class="line">gfortran -O2 -u -mcmodel=medium -fconvert=big-endian    -I/disk1/xhw/LBM/ln_solver/model/src/include  -DSYS_AVATAR -DSYS_UNIX -DCODE_ASCII -DCODE_IEEE -DOPT_NOPHYSICS -DOPT_NOUSER -DOPT_CLASSIC -I/disk1/xhw/LBM/ln_solver/model/src/include   -c -o atmmain.o atmmain.F</span><br><span class="line">gfortran -O2 -u  atmmain.o astrt-2.o aadmn-2.o dadmn-2.o dterm-2.o dgdyn-2.o dstep-2.o dintg-2.o dsetd-2.o dbulk.o          /disk1/xhw/LBM/ln_solver/model/lib/linux/liblbm2t21ml20c.a   -o /disk1/xhw/LBM/ln_solver/model/bin/linux/lbm2.t21ml20ctintgr</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o: In function `_start&#x27;:</span><br><span class="line">(.text+0x20): undefined reference to `main&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里再贴一下 <code>/disk1/xhw/LBM/ln_solver/model/src/sysdep/Makedef.linux</code> 和 <code>/disk1/xhw/LBM/ln_solver/solver/include/make.inc.linux</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /disk1/xhw/LBM/ln_solver/model/src/sysdep/Makedef.linux</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Linux system dependent include for Makefile</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SYSFFLAGS= -O -u</span></span><br><span class="line"><span class="comment">#SYSFFLAGS       = -O2 -u -mcmodel=medium -shared-intel -convert big_endian -no-vec</span></span><br><span class="line">SYSFFLAGS= -O2 -u -mcmodel=medium -fconvert=big-endian</span><br><span class="line"><span class="comment">#SYSCFLAGS= </span></span><br><span class="line"><span class="comment">#SYSCFLAGS       = -DX_WCHAR -shared -mcmodel=medium</span></span><br><span class="line">SYSCFLAGS= -DX_WCHAR</span><br><span class="line"><span class="comment">#SYSLDFLAGS      = -O2 -u</span></span><br><span class="line">SYSLDFLAGS= </span><br><span class="line"><span class="comment">#SYSCPPFLAGS     = -DSYS_AVATAR -DSYS_UNIX -DCODE_ASCII -DCODE_IEEE</span></span><br><span class="line">SYSCPPFLAGS = -DSYS_Linux -DSYS_UNIX -DCODE_ASCII -DCODE_IEEE <span class="comment">#-DCODE_ENDIAN</span></span><br><span class="line">SYSAUTODBL= -r8</span><br><span class="line">SYSDEBUG= -g</span><br><span class="line">SYSCHECK= -C</span><br><span class="line">LINKOPT=</span><br><span class="line">SYSLIBINC       = yy$(SYSTEM).o</span><br><span class="line"><span class="comment">#SYSLIB          = -lc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MAKE= make</span></span><br><span class="line">CC= gcc</span><br><span class="line"><span class="comment">#FC= g77</span></span><br><span class="line"><span class="comment">#LD= g77</span></span><br><span class="line"><span class="comment">#FC= f77</span></span><br><span class="line"><span class="comment">#LD= f77</span></span><br><span class="line">FC= gfortran</span><br><span class="line">LD= gfortran</span><br><span class="line"><span class="comment">#FC= gfortran</span></span><br><span class="line"><span class="comment">#LD= gfortran</span></span><br><span class="line">AR= ar vru</span><br><span class="line">RM= <span class="built_in">rm</span> -f</span><br><span class="line">CP= <span class="built_in">cp</span></span><br><span class="line">MV= <span class="built_in">mv</span> -f</span><br><span class="line">LN= <span class="built_in">ln</span> -s</span><br><span class="line">RANLIB= ranlib</span><br><span class="line">CAT= <span class="built_in">cat</span></span><br><span class="line">INSTALL= <span class="built_in">cp</span></span><br><span class="line">MD= mkdirhier</span><br><span class="line">JLATEX= bigjlatex</span><br><span class="line">DVI2JPS= dvi2ps</span><br><span class="line">PRINT= ltype</span><br><span class="line">PRINTSTAMP= .<span class="built_in">print</span></span><br><span class="line">INDEX= etags -wx</span><br><span class="line">TAGS= etags</span><br><span class="line">TOUCH= <span class="built_in">touch</span></span><br><span class="line">ECHO= <span class="built_in">echo</span></span><br><span class="line">CPP= cpp</span><br><span class="line">FPP     = </span><br><span class="line"></span><br><span class="line">SYSXLIBDIR= /usr/X11R6/lib</span><br><span class="line">SYSXLIBNAME= X11</span><br><span class="line">SYSXLIBS= -L$(SYSXLIBDIR) -l$(SYSXLIBNAME)</span><br><span class="line"><span class="comment">###SYSXLIBS= -l$(SYSXLIBNAME)</span></span><br><span class="line"></span><br><span class="line">PACKFILE        = Linux.ftr</span><br><span class="line">PACKDIR= $(SRCDIR)/Linux</span><br><span class="line"></span><br><span class="line">world:all</span><br><span class="line"></span><br><span class="line">.SUFFIXES : .pac .F</span><br><span class="line"></span><br><span class="line">$(PACKFILE):</span><br><span class="line"></span><br><span class="line">.F.pac:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/ADD NAME=&quot;</span>$*.F &gt;&gt; $(PACKFILE)</span><br><span class="line"><span class="built_in">cat</span> $&lt; &gt;&gt; $(PACKFILE)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># /disk1/xhw/LBM/ln_solver/solver/include/make.inc.linux</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#  LAPACK make include file.                                       #</span><br><span class="line">#  LAPACK, Version 2.0                                             #</span><br><span class="line">#  September 30, 1994                                                 #</span><br><span class="line">####################################################################</span><br><span class="line">#</span><br><span class="line">#  The machine (platform) identifier to append to the library names</span><br><span class="line">#</span><br><span class="line">PLAT = LINUX</span><br><span class="line">#  </span><br><span class="line">#  Modify the FORTRAN and OPTS definitions to refer to the</span><br><span class="line">#  compiler and desired compiler options for your machine.  NOOPT</span><br><span class="line">#  refers to the compiler options desired when NO OPTIMIZATION is</span><br><span class="line">#  selected.  Define LOADER and LOADOPTS to refer to the loader and </span><br><span class="line">#  desired load options for your machine.</span><br><span class="line">#</span><br><span class="line">FORTRAN  = gfortran</span><br><span class="line">OPTS     = -O2 -fconvert=big-endian -mcmodel=medium </span><br><span class="line">#-fallow-argument-mismatch</span><br><span class="line">NOOPT    = -O0 -fconvert=big-endian -mcmodel=medium</span><br><span class="line">LOADER   = gfortran</span><br><span class="line">LOADOPTS = -fconvert=big-endian </span><br><span class="line">#-fallow-argument-mismatch</span><br><span class="line">#FORTRAN  = ifort -lgfortran</span><br><span class="line">#OPTS     = -O -u -convert big_endian -mcmodel=medium -fpe0 -traceback -g -check all</span><br><span class="line">#NOOPT    = -u -convert big_endian  -mcmodel=medium -fpe3 -traceback -g -check all</span><br><span class="line">#LOADER   = ifort -lgfortran</span><br><span class="line">#LOADOPTS = -convert big_endian -mcmodel=medium -fpe3 -traceback -g -check all</span><br><span class="line">#</span><br><span class="line">#  The archiver and the flag(s) to use when building archive (library)</span><br><span class="line">#  If you system has no ranlib, set RANLIB = echo.</span><br><span class="line">#</span><br><span class="line">ARCH     = ar</span><br><span class="line">ARCHFLAGS= cr</span><br><span class="line">RANLIB   = ranlib</span><br><span class="line">#</span><br><span class="line">RM       = rm -f</span><br><span class="line">CP = cp -f</span><br><span class="line">MV = mv -f</span><br><span class="line">#</span><br><span class="line">#  The location of the libraries to which you will link.  (The </span><br><span class="line">#  machine-specific, optimized BLAS library should be used whenever</span><br><span class="line">#  possible.)</span><br><span class="line">#</span><br><span class="line">BLASLIB      = /disk1/xhw/LBM/lapack-3.9.0/librefblas.a</span><br><span class="line">LAPACKLIB    = /disk1/xhw/LBM/lapack-3.9.0/liblapack.a</span><br><span class="line">TMGLIB       = /disk1/xhw/LBM/lapack-3.9.0/libtmglib.a</span><br><span class="line">EIGSRCLIB    = </span><br><span class="line">#</span><br><span class="line">#  LBM library</span><br><span class="line">#</span><br><span class="line">LDLIBS       = $(LNHOME)/model/lib/$(ARC)/liblbm2$(HRES)m$(VRES)c.a</span><br><span class="line">#</span><br><span class="line"># byte unit</span><br><span class="line">#</span><br><span class="line">MBYT= 1</span><br><span class="line">#MBYT= 4</span><br></pre></td></tr></table></figure><h2 id="自制强迫场">自制强迫场</h2><p>LBM支持自动生成椭圆等形状的强迫场，包括温度、涡度、散度、气压强迫。然而当我们想要加多个强迫场，比如一个热源，一个冷源就比较麻烦了。但是我们可以自己根据LBM强迫场的格式，生成对应的文件，替换掉LBM自建的强迫场文件。这样可以随心所欲地加入强迫场的强度、形状，而且更贴近观测。</p><p>LBM强迫场是由 <code>.grd</code> 和 <code>.ctl</code> 给出的。我们需要做的是，读出 <code>.grd</code> ，查看内部变量内容，分辨率等要素。然后做出自己期望的强迫场，替换掉<code>.grd</code>。具体步骤如下</p><ol><li><p>用 <code>cdo</code> 将LBM自建强迫场转为 nc 文件方便读取查看。<code>cdo -f nc import_binary frc.t42l20.classic.ctl frc.t42l20.classic.nc</code></p></li><li><p>python 读取 <code>frc.t42l20.classic.nc</code> 查看其内容。以设定温度强迫为例。改变nc文件中的 <code>t</code> 变量。</p></li><li><p>将新的强迫场输出为新的 nc 文件<code>newFrc.nc</code> 。变量t, d ,v 都是多高度层的，而变量p是地面气压是单高度层的，由于后续需要用 <code>Grads</code> 读取，而 <code>Grads</code> 无法直接用 <code>sdfopen</code> 同时读取多个高度维数据集，需要分两个文件读取。所以需要先输出一个 <code>newFrc.nc</code> 变量包括t,d,v。再另输出一个 <code>newFrc_p.nc</code> 变量包括p。如果使用 <code>xarray.Dataset.to_netcdf()</code> 输出nc文件。需添加 <code>format='NETCDF3_CLASSIC'</code></p><p><code>forcing['p'].to_netcdf('/disk1/xhw/LBM/ln_solver/data/frc_indianOcean/newFrc_p.nc',format='NETCDF3_CLASSIC')</code></p></li></ol><p>​原因在于如果直接 <code>to_netcdf</code> 输出的是netcdf4，是 <code>little_endian</code> 小字节序的。而LBM全程使用的是 <code>big_endian</code> 大字节序的，会造成不匹配。添加 <code>format='NETCDF3_CLASSIC'</code> 后，python会以netcdf3输出nc文件，这个格式是 <code>little_endian</code> 的。</p><blockquote><p>*注意：LBM 自带的<code>.ctl</code> 的时间填的是 <code>TDEF 1 LINEAR 15jan0000 1mo</code> 这在转为nc文件并读取后时间会显示为</p><p><code>array([cftime.DatetimeGregorian(-1, 1, 15, 0, 0, 0, 0, has_year_zero=False)],dtype=object)</code></p><p>这在后续的处理中可能引起不便，因此可以将 强迫场<code>.ctl</code> 中的时间改为 <code>TDEF 1 LINEAR 15jan2000 1mo</code> 或在python输出nc文件之前将时间替换<code>forcing['time'] = np.array([np.datetime64('2000-01-15')])</code></p></blockquote><ol start="4"><li><p>得到 <code>newFrc.nc</code> 和 <code>newFrc_p.nc</code> 后，使用 <code>Grads</code> 读取, 我用的是opengrads气象家园整合版。（由于ip原因，我在服务器上没有用grads，文件是传到本地用grads处理的，原因见<a href="https://664787022.github.io/2023/11/19/ncview/">ncview安装和踩坑 | XHW’s Blog (664787022.github.io)</a>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x27;reinit&#x27;</span><br><span class="line">&#x27;sdfopen d:/user/pycode/LBM/makeFrc/newFrc.nc&#x27;</span><br><span class="line">&#x27;sdfopen d:/user/pycode/LBM/makeFrc/newFrc_p.nc&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;set gxout fwrite&#x27;</span><br><span class="line">* 输出参数sq顺序输出，cl覆写，be大字节序输出，可在谷歌查到</span><br><span class="line">&#x27;set fwrite -sq -cl -be d:/user/pycode/LBM/makeFrc/newFrc.grd&#x27; </span><br><span class="line">&#x27;set lon 0 357.1875&#x27;</span><br><span class="line">&#x27;set lat -87.864 87.864&#x27;</span><br><span class="line"></span><br><span class="line">* 循环写入顺序： 高度-&gt;变量-&gt;时间</span><br><span class="line">i=1</span><br><span class="line">while(i&lt;=1)</span><br><span class="line">    &#x27;set t &#x27;i&#x27;&#x27;</span><br><span class="line">    </span><br><span class="line">    &#x27;set dfile 1&#x27;</span><br><span class="line">    j=1</span><br><span class="line">    while(j&lt;=20)</span><br><span class="line">        &#x27;set z &#x27;j&#x27;&#x27;</span><br><span class="line">        &#x27;d v&#x27;</span><br><span class="line">        j=j+1</span><br><span class="line">    endwhile</span><br><span class="line">    </span><br><span class="line">    j=1</span><br><span class="line">    while(j&lt;=20)</span><br><span class="line">        &#x27;set z &#x27;j&#x27;&#x27;</span><br><span class="line">        &#x27;d d&#x27;</span><br><span class="line">        j=j+1</span><br><span class="line">    endwhile</span><br><span class="line">    </span><br><span class="line">    j=1</span><br><span class="line">    while(j&lt;=20)</span><br><span class="line">        &#x27;set z &#x27;j&#x27;&#x27;</span><br><span class="line">        &#x27;d t&#x27;</span><br><span class="line">        j=j+1</span><br><span class="line">    endwhile</span><br><span class="line">    </span><br><span class="line">    &#x27;set dfile 2&#x27;</span><br><span class="line">    j=1</span><br><span class="line">    while(j&lt;=1)</span><br><span class="line">        &#x27;set z &#x27;j&#x27;&#x27;</span><br><span class="line">        &#x27;d p&#x27;</span><br><span class="line">        j=j+1</span><br><span class="line">    endwhile  </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    i=i+1</span><br><span class="line">endwhile</span><br><span class="line"></span><br><span class="line">&#x27;disable fwrite&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>*注意：在写入之前应该先使用 <code>q ctlinfo</code> 看出 <code>Grads</code> 读取后数据的排列顺序（例如纬度是由北到南还是由南到北，高度是由小到大还是有大到小）。一般来说，不过当时python 输出的顺序是怎样的，<code>Grads</code> 读取后纬度是-90~90，高度是0~1（sigma坐标系）。这时写入 <code>newFrc.grd</code> 后顺序也是这样的。但是LBM给的 强迫场 <code>.ctl</code>示例文件是的纬度是-90~90，高度是1~0，且设置了<code>OPTIONS SEQUENTIAL YREV</code> 。 本来<code>.ctl</code> 与 grads输出的<code>.grd</code> 的纬度都是-90~90，是相匹配的。但是设置 <code>YREV</code>  （y轴reverse）意味着LBM读取 grads输出的 <code>.grd</code> 会以 90~-90的方式读入，这就反了。而真正需要 <code>reverse</code> 的是z轴。 所以需要更改 <code>.ctl</code> 里的option为 <code>OPTIONS SEQUENTIAL ZREV</code>。 当然直接更改XDEF、YDEF、ZDEF以匹配输出的 <code>.grd</code> 也可以。下面给出一个示例 <code>.ctl</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* sample forcing pattern</span><br><span class="line">DSET ^newFrc.grd</span><br><span class="line">* BYTESWAPPED</span><br><span class="line">OPTIONS SEQUENTIAL ZREV</span><br><span class="line">TITLE dumy</span><br><span class="line">UNDEF -999.</span><br><span class="line">OPTIONS big_endian</span><br><span class="line">XDEF 128 LINEAR 0. 2.81250</span><br><span class="line">YDEF 64  LEVELS </span><br><span class="line">-87.864 -85.097 -82.313 -79.526 -76.737 -73.948 -71.158 -68.368 -65.578 </span><br><span class="line">-62.787 -59.997 -57.207 -54.416 -51.626 -48.835 -46.045 -43.254 -40.464 </span><br><span class="line">-37.673 -34.883 -32.092 -29.301 -26.511 -23.720 -20.930 -18.139 -15.348 </span><br><span class="line">-12.558  -9.767  -6.976  -4.186  -1.395   1.395   4.186  6.976   9.767  </span><br><span class="line">12.558  15.348  18.139  20.930  23.720  26.511  29.301 32.092  34.883  </span><br><span class="line">37.673  40.464  43.254  46.045  48.835  51.626  54.416  57.207  59.997  </span><br><span class="line">62.787  65.578  68.368  71.158  73.948  76.737  79.526  82.313  85.097  </span><br><span class="line">87.864 </span><br><span class="line">ZDEF 20 LEVELS 0.99500 0.97999 0.94995 0.89988 0.82977 0.74468 </span><br><span class="line">0.64954 0.54946 0.45447 0.36948 0.29450 0.22953 0.17457 0.12440 </span><br><span class="line">0.0846830 0.0598005 0.0449337 0.0349146 0.0248800 0.00829901</span><br><span class="line">TDEF 1 LINEAR 15jan2000 1mo</span><br><span class="line">VARS 4</span><br><span class="line">v      20 99 vor.   forcing [s**-2]</span><br><span class="line">d      20 99 div.   forcing [s**-2]</span><br><span class="line">t      20 99 temp.  forcing [K s**-1]</span><br><span class="line">p      1  99 sfc.Ln(Ps) forcing</span><br><span class="line">ENDVARS</span><br></pre></td></tr></table></figure><ol start="5"><li><p>将生成了 <code>newFrc.grd</code> 和对应 <code>newFrc.ctl</code> （需同名）放入 <code>/disk1/xhw/LBM/ln_solver/data/frc_indianOcean</code> (自建)。修改 <code>/disk1/xhw/LBM/ln_solver/model/sh/tintgr</code> 里的 <code>linear-run.classic.copy3.csh</code> （根据需要调整）。将 FRC 和 SFRC改为自建强迫场路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv FRC      $FDIR/newFrc.grd               # initial perturbation</span><br><span class="line">setenv SFRC     $FDIR/newFrc.grd               # steady forcing</span><br></pre></td></tr></table></figure><p>完整文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"> <span class="comment"># @Author: xhw</span></span><br><span class="line"> <span class="comment"># @Date: 2023-12-10 22:32:50</span></span><br><span class="line"> <span class="comment"># @LastEditTime: 2023-12-11 16:18:39</span></span><br><span class="line"> <span class="comment"># @FilePath: /xhw/LBM/ln_solver/model/sh/tintgr/linear-run.classic.copy3.csh</span></span><br><span class="line"> <span class="comment"># @Description: </span></span><br><span class="line"><span class="comment">### </span></span><br><span class="line"><span class="comment">#!/bin/csh -f</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      sample script for linear model run (dry model)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NQS command for mail</span></span><br><span class="line"><span class="comment">#@$-q   b</span></span><br><span class="line"><span class="comment">#@$-N   1</span></span><br><span class="line"><span class="comment">#@$-me</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">setenv LNHOME   /disk1/xhw/LBM/ln_solver                 <span class="comment"># ROOT of model</span></span><br><span class="line">setenv LBMDIR   <span class="variable">$LNHOME</span>/model                          <span class="comment"># ROOT of LBM </span></span><br><span class="line">setenv SYSTEM   linux                                 <span class="comment"># execute system</span></span><br><span class="line">setenv RUN      <span class="variable">$LBMDIR</span>/bin/<span class="variable">$SYSTEM</span>/lbm2.t42ml20ctintgr <span class="comment"># Excutable file</span></span><br><span class="line">setenv TDIR     <span class="variable">$LNHOME</span>/solver/util</span><br><span class="line"><span class="comment">#setenv FDIR     $LNHOME/data                           # Directory for Output</span></span><br><span class="line">setenv FDIR     <span class="variable">$LNHOME</span>/data/frc_indianOcean                 <span class="comment"># Directory for Output</span></span><br><span class="line">setenv DIR      <span class="variable">$LNHOME</span>/data/out_indianOcean                       <span class="comment"># Directory for Output</span></span><br><span class="line"><span class="comment">#setenv BSFILE   $LNHOME/bs/gt3/ncepwin.t21l20          # Atm. BS File</span></span><br><span class="line">setenv BSFILE   <span class="variable">$LNHOME</span>/bs/gt3/ncepwin.t42l20          <span class="comment"># Atm. BS File</span></span><br><span class="line">setenv RSTFILE  <span class="variable">$DIR</span>/Restart.amat                      <span class="comment"># Restart-Data File</span></span><br><span class="line"><span class="comment">#setenv FRC      $FDIR/frc.t21l20.classic.grd           # initial perturbation</span></span><br><span class="line"><span class="comment">#setenv SFRC     $FDIR/frc.t21l20.classic.grd           # steady forcing</span></span><br><span class="line"><span class="comment"># setenv FRC      $FDIR/frc.t42l20.classic.grd               # initial perturbation</span></span><br><span class="line"><span class="comment"># setenv SFRC     $FDIR/frc.t42l20.classic.grd               # steady forcing</span></span><br><span class="line">setenv FRC      <span class="variable">$FDIR</span>/newFrc.grd               <span class="comment"># initial perturbation</span></span><br><span class="line">setenv SFRC     <span class="variable">$FDIR</span>/newFrc.grd               <span class="comment"># steady forcing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setenv TRANS    gt2gr</span><br><span class="line">setenv TEND     59</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> (! -e <span class="variable">$DIR</span>) <span class="built_in">mkdir</span> -p <span class="variable">$DIR</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$DIR</span></span><br><span class="line">\<span class="built_in">rm</span> SYSOUT</span><br><span class="line"><span class="built_in">echo</span> job started at `<span class="built_in">date</span>` &gt; <span class="variable">$DIR</span>/SYSOUT</span><br><span class="line">/bin/rm -f <span class="variable">$DIR</span>/SYSIN</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">END_OF_DATA &gt;&gt;! $DIR/SYSIN</span></span><br><span class="line"><span class="string"> &amp;nmrun  run=&#x27;linear model&#x27;                                 &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmtime start=0,1,1,0,0,0, end=0,1,$TEND,0,0,0             &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhdif order=4, tefold=0.5, tunit=&#x27;DAY&#x27;                   &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmdelt delt=40, tunit=&#x27;MIN&#x27;, inistp=2                     &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmdamp ddragv=0.5,0.5,0.5,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,1.,1.,</span></span><br><span class="line"><span class="string">         ddragd=0.5,0.5,0.5,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,1.,1.,</span></span><br><span class="line"><span class="string">         ddragt=0.5,0.5,0.5,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,20.,1.,1.,</span></span><br><span class="line"><span class="string">         tunit=&#x27;DAY&#x27;                                           &amp;end</span></span><br><span class="line"><span class="string"> &amp;nminit file=&#x27;$BSFILE&#x27; , DTBFR=0., DTAFTR=0., TUNIT=&#x27;DAY&#x27;   &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmrstr file=&#x27;$RSTFILE&#x27;, tintv=1, tunit=&#x27;MON&#x27;,  overwt=t    &amp;end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &amp;nmvdif vdifv=1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,</span></span><br><span class="line"><span class="string">         vdifd=1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,</span></span><br><span class="line"><span class="string">         vdift=1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,1.d3,                         &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmbtdif tdmpc=0.                                           &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmfrc  ffrc=&#x27;$FRC&#x27;,   oper=f, nfcs=1                       &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmsfrc fsfrc=&#x27;$SFRC&#x27;, ofrc=t, nsfcs=1, fsend=-1,1,30,0,0,0 &amp;end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &amp;nmchck ocheck=f, ockall=f                                  &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmdata item=&#x27;GRZ&#x27;,    file=&#x27;&#x27;                              &amp;end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &amp;nmhisd tintv=1, tavrg=1, tunit=&#x27;DAY&#x27;                       &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;PSI&#x27;,  file=&#x27;psi&#x27;, tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;CHI&#x27;,  file=&#x27;chi&#x27;, tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;U&#x27;,    file=&#x27;u&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;V&#x27;,    file=&#x27;v&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;OMGF&#x27;, file=&#x27;w&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;T&#x27;,    file=&#x27;t&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;Z&#x27;,    file=&#x27;z&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string"> &amp;nmhist item=&#x27;PS&#x27;,   file=&#x27;p&#x27;,   tintv=1, tavrg=1, tunit=&#x27;DAY&#x27; &amp;end</span></span><br><span class="line"><span class="string">END_OF_DATA</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  run</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$RUN</span> &lt; <span class="variable">$DIR</span>/SYSIN &gt;&gt; <span class="variable">$DIR</span>/SYSOUT</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$TDIR</span></span><br><span class="line"><span class="variable">$TRANS</span></span><br><span class="line"><span class="built_in">echo</span> job end at `<span class="built_in">date</span>` &gt;&gt; <span class="variable">$DIR</span>/SYSOUT</span><br></pre></td></tr></table></figure><h2 id="关于Grads">关于Grads</h2><p>对于使用opengrads气象家园整合版，需要设置一些环境变量。以管理员模式运行编辑器。参考<a href="http://bbs.06climate.com/forum.php?mod=viewthread&amp;tid=37910&amp;fromuid=103735">解决opengrads打开NC格式文件显示ununits.dat error的方法-编程作图-气象家园_气象人自己的家园 (06climate.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面系统变量值根据安装版本不同有所修改，用EXE安装的opengrads2.0设置如下：</span><br><span class="line">在“系统变量”中选“Path&quot;----点“编辑”----加入“C:\OpenGrADS\Contents\Cygwin\Versions\2.0.2.oga.2\i686;”</span><br><span class="line">              在“系统变量”中点“新建”----设置变量名“GADDIR”----变量值“C:\OpenGrADS\Contents\Resources\SupportData”</span><br><span class="line">              在“系统变量”中点“新建”----设置变量名“GASCRP”----变量值“C:\OpenGrADS\Contents\Resources\Scripts&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ncview安装和踩坑</title>
      <link href="/2023/11/19/ncview/"/>
      <url>/2023/11/19/ncview/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-14">前言</h2><p>最近在尝试跑WRF，WRF输出的数据想要快速查看画图的话ncview是一个很好的工具。然而在安装ncview的过程中遇到了诸多困难，搞了好几天才终于成功，需要总结一下经验。</p><h2 id="安装ncview">安装ncview</h2><p>ncview是一款linux系统上的软件，他可通过至少一下两种方法安装。</p><ol><li>conda 安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install -c conda-forge ncview</span><br></pre></td></tr></table></figure><ol start="2"><li>apt 安装(需要sudo)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ncview</span><br></pre></td></tr></table></figure><p>我只试过第一种方法。在使用conda完成后，会出现几个包被自动升级。导致conda出现一些问题，具体报错信息我忘了。当时将报错信息贴到百度里，解决方法就是将那几个包降回原版本就可以了。</p><h2 id="配置">配置</h2><p>安装完成后，需要修改.bashrc，添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=172.16.4.224:0.0</span><br></pre></td></tr></table></figure><p>其中172.16.4.224是本地电脑的ip，可通过<code>cmd</code>命令<code>ipconfig</code>查看，<code>IPv4地址</code>那一行显示的就是ip。</p><p><code>.bashrc</code>修改后后记得<code>source .bashrc</code></p><p>在本地电脑中，需要下载安装Xming，安装完成后在Xming安装目录的下有一个<code>X0.hosts</code> 文件，在文件中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br><span class="line">172.16.0.125</span><br></pre></td></tr></table></figure><p>其中172.16.0.125是服务器ip。</p><h2 id="运行-2">运行</h2><p>做完以上步骤后基本可以运行ncview了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ncview filename.nc</span><br></pre></td></tr></table></figure><p>可能会出现说找不到<code>.ncviewrc</code>的情况，这个是不需要管的</p><h2 id="一些坑">一些坑</h2><p>以上步骤看起来很简单，但是在这些天我却始终不能成功运行ncview。原因在于一直报错说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncview error: can&#x27;t open display: 192.168.1.186:0.0</span><br></pre></td></tr></table></figure><p>其中<code>192.168.1.186</code>是在我成功之前本地电脑使用的ip地址。也就是ncview无法通过这个ip地址将图像展示到我的本地电脑上。</p><p>后来通过闲鱼咨询了解到，服务器ip的172开头，我的本地电脑通过连接路由器，路由器重新分配ip地址，将192开头的ip分配给了我。172和192不属于同一网段，因而无法实现<code>ssh</code> , <code>ping</code> 等远程连接。ncview无法成功运行的原因就在这。</p><p>那么我需要让路由器不要随便分配ip地址，我需要得到一个172开头的ip。进一步通过闲鱼了解到，进入路由器的管理页面，关闭DHCP服务(即关闭ip自动分配)。之后将路由器WAN口的线插在LAN口 (原先一个插在WAN口连接路由器和墙体，一个插在LAN口连接路由器和电脑)。然后断电重启路由器。之后果然得到172开头的ip，ncview也可以顺利运行了！</p><p>本地地址改成172后，我发现无法打开路由器的管理页面了。原因是路由器本身的ip也变了（百度说的），这时想再进入管理页面，需要将ip地址设置手动获取到192开头。步骤如下</p><p><a href="https://imgse.com/i/piUFfxJ"><img src="https://z1.ax1x.com/2023/11/19/piUFfxJ.md.jpg" alt="piUFfxJ.md.jpg"></a></p><p>手动输入ip地址<code>192.168.1.2</code> , 这时本机ip就变回192了，就可以登陆路由器管理页面了。 如果要再变回172就将上图改为自动获得ip即可。</p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ncview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各类网站数据下载</title>
      <link href="/2023/11/15/dataDownload/"/>
      <url>/2023/11/15/dataDownload/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-7">前言</h2><p>前段时间在各种网站上下载数据，发现不是所有数据都想ERA5，NCEP资料那样用鼠标点击就很容易获取。例如EASE积雪、JRA55，FNL数据等等。在数据下载这方面就费了很大功夫。有必要整理一下，各类网站资料下载的快捷方法，以免重复造轮子</p><h2 id="FNL">FNL</h2><p>当初下载这个数据是为了用它启动WRF，参考的教程是 <a href="https://zhuanlan.zhihu.com/p/368000766">NECP FNL数据批量下载 - 知乎 (zhihu.com)</a></p><p>这个教程说得挺详细，我一遍就成功了。</p><p><a href="https://link.zhihu.com/?target=https%3A//rda.ucar.edu/datasets/ds083.2/index.html%23%21access">https://rda.ucar.edu/datasets/ds083.2/index.html#!access</a> 如下，点击Web File Listing</p><p><a href="https://imgse.com/i/piY4asx"><img src="https://z1.ax1x.com/2023/11/15/piY4asx.md.png" alt="piY4asx.md.png"></a></p><p>然后：</p><p><a href="https://imgse.com/i/piY40eK"><img src="https://z1.ax1x.com/2023/11/15/piY40eK.md.png" alt="piY40eK.md.png"></a></p><p>找到自己需要的年份，我这里需要2019年的数据<br><a href="https://imgse.com/i/piY4oFg"><img src="https://z1.ax1x.com/2023/11/15/piY4oFg.md.png" alt="piY4oFg.md.png"></a></p><p>勾选需要的数据，然后选择下载方式，这里建议直接选择第一个，下载快还方便(✪ω✪)</p><p><a href="https://imgse.com/i/piY4WOP"><img src="https://z1.ax1x.com/2023/11/15/piY4WOP.md.png" alt="piY4WOP.md.png"></a></p><p>最后，把下载到的download.csh文件放到你想要的存放数据的文件夹，打开终端输入指令（Linux系统下）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./download.csh password（后面跟你的NECP账户密码：我的是A开头，特殊符号结尾的那个）</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如有权限问题（permission），则输入指令chmod 777 download.csh 如果文件中修改了密码，还是报错未设置密码，可以输入dos2unix download.csh指令</span><br></pre></td></tr></table></figure><h2 id="EASE-积雪">EASE 积雪</h2><p>官方网站 <a href="https://nsidc.org/data/nsidc-0046/versions/4%EF%BC%8C%E4%BD%BF%E7%94%A8">https://nsidc.org/data/nsidc-0046/versions/4，使用</a><code>wget</code>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget --load-cookies ~/.urs_cookies --save-cookies ~/.urs_cookies --keep-session-cookies --no-check-certificate --auth-no-challenge=on -r --reject <span class="string">&quot;index.html*&quot;</span> -np -nH -r -e robots=off https://daacdata.apps.nsidc.org/pub/DATASETS/nsidc0046_weekly_snow_seaice/data/</span><br></pre></td></tr></table></figure><p>在下载之前需要在home下添加 <code>.netrc</code> 文件，并添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine urs.earthdata.nasa.gov login 用户名(xiaoh*****66**) password 密码(A66*****22a*h)</span><br></pre></td></tr></table></figure><p>顺便贴一下处理程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 坐标信息</span></span><br><span class="line">coords = xr.open_dataset(<span class="string">&#x27;/disk3/snow.nsidc0046_weekly_snow_seaice/EASE2_N25km.geolocation.v0.9.nc&#x27;</span>)</span><br><span class="line">latitude = coords.latitude</span><br><span class="line">longitude = coords.longitude</span><br><span class="line"></span><br><span class="line">filelist = glob.glob(<span class="string">&#x27;/disk1/xhw/code/Myresearch/SavedData/EASE/pub/DATASETS/nsidc0046_weekly_snow_seaice/data/EASE2_N25km.snowice.*.bin&#x27;</span>)</span><br><span class="line">filelist.sort()</span><br><span class="line">time = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snow = np.zeros((<span class="built_in">len</span>(filelist),<span class="number">720</span>*<span class="number">720</span>))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(filelist)):</span><br><span class="line">    time.append(np.datetime64(pd.to_datetime(filelist[j][-<span class="number">25</span>:-<span class="number">17</span>])))</span><br><span class="line">    f = <span class="built_in">open</span>(filelist[j],<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        snow[j,i] = data[i]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(j,<span class="string">&#x27;/&#x27;</span>,<span class="built_in">len</span>(filelist))</span><br><span class="line"></span><br><span class="line">snow = snow.reshape((<span class="built_in">len</span>(filelist),<span class="number">720</span>,<span class="number">720</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些装机软件</title>
      <link href="/2023/09/04/SomeSoftwares/"/>
      <url>/2023/09/04/SomeSoftwares/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-6">前言</h2><p>记录一下最近用的一些实用软件，因为这些软件需要配置一些插件才好使。插件多，配置过程繁琐，所以记录一下。</p><h2 id="Zotero">Zotero</h2><ul><li><p><a href="https://github.com/windingwind/zotero-pdf-translate">zotero-pdf-translate</a> ：文献翻译插件，几乎不用怎么额外设置，很实用。支持Zotero7 beta</p></li><li><p><a href="https://github.com/windingwind/zotero-tag">zotero-tag</a> ：标签插件，能够以颜色和标志给文献添加标签。添加文献后能够自动添加 “未读” 标签，打开pdf后自动去除 “未读”。但是目前（2023.9.4）作者还没有支持Zotero7。</p></li><li><p><a href="https://github.com/MuiseDestiny/zotero-style">zotero-style</a> ：能够为Zotero添加更多列，能够将文献标签直接展示在主页面并可以为标签创建分类。实现类似Endnote的 “未读” 粗体和文献评级。支持Zotero7 beta</p></li></ul><h2 id="Obsibian">Obsibian</h2><ul><li><a href="https://github.com/ZekunC/Obsidian-Typora-Vue-Theme">Obsidian-Typora-Vue-Theme</a> : Obsibian的一款外观主题，仿Typora。我觉得比较好看</li><li><a href="https://github.com/PKM-er/obsidian-editing-toolbar">obsidian-editing-toolbar</a> ：Obsibian不能直接对文本进行高亮、字体颜色等更改。这个插件安装后会出现一个工具栏，能够实现对文本的富文本操作（高亮等）</li><li><a href="https://github.com/pjeby/tag-wrangler">tag-wrangler</a> ：标签管理插件，与 <code>zotero-tag</code> 类似为能够为标签创建分类。在文本内加入 <code>#标签</code> 即可创建一个标签(井号后没有空格)。</li><li><a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin">obsidian-image-auto-upload-plugin</a> ：自动将图片上传图床插件。当我们从Zotero笔记中复制一个图过来或屏幕截屏直接粘贴进Obsidian中时，这个插件会将该图通过 <code>PicGo</code> 自动上传图床。图片位置也会自动添加 <code>![](url)</code> 方便存储笔记图片。使用该插件前需要先下载安装 <code>PicGo</code> 软件</li></ul><h2 id="PicGo">PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 这是一款将图片快速上传图床的软件。提供 Github、腾讯云、阿里云、七牛图床等接口。我一般使用 Github作为图床， 图片存在仓库664787022/imagSave 内，使用前需要对 PicGo 进行配置。配置方法见文档：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#smms">配置手册 | PicGo</a></p><h2 id="ClickRun">ClickRun</h2><p><a href="https://github.com/InJeCTrL/ClickRun">ClickRun鼠标连点器</a> 一个简易鼠标连点器。<code>F1,2,3,4...</code> 等键启动暂停。可设置点击间隔。</p><h2 id="EV录屏">EV录屏</h2><p><a href="https://www.ieway.cn/evcapture.html">EV录屏 - 免费高清无水印的屏幕录制软件</a>  免费无水印录屏软件，很好用</p><h2 id="VScode插件">VScode插件</h2><ul><li><p>Bookmarks: 书签，可以跳转代码</p></li><li><p>folder-alias：可以给文件或文件夹加上别名，等于是一个备注</p></li><li><p>vscode-icons: 改变文件图标</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义Python函数</title>
      <link href="/2023/07/22/Pyfunction/"/>
      <url>/2023/07/22/Pyfunction/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言-3">前言</h2><p>存储一下自己定义的常用函数。</p><h2 id="标准化">标准化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getnorm</span>(<span class="params">array</span>):</span><br><span class="line">    array = (array - array.mean())/array.std()</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="提取冬季">提取冬季</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getDJF</span>(<span class="params">DataArray</span>):</span><br><span class="line">  mat_w = DataArray.resample(time=<span class="string">&#x27;QS-DEC&#x27;</span>).mean()</span><br><span class="line">  mat_w = mat_w.sel(time=mat_w[<span class="string">&#x27;time.month&#x27;</span>] == <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">return</span> mat_w</span><br></pre></td></tr></table></figure><h2 id="线性回归">线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> f_regression</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getReg</span>(<span class="params">mat, sequence</span>):</span><br><span class="line">    A = np.vstack((sequence, np.ones((<span class="number">1</span>, sequence.shape[<span class="number">0</span>])))).T</span><br><span class="line">    (a, b, c) = mat.shape</span><br><span class="line">    mat_rshp = mat.copy().values.reshape((a, b*c))</span><br><span class="line">    index = np.isnan(mat_rshp).<span class="built_in">any</span>(axis=<span class="number">0</span>)</span><br><span class="line">    mat_rshp[:, index] = -<span class="number">999</span></span><br><span class="line">    mat_rshp_reg = np.linalg.lstsq(A, mat_rshp)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    mat_rshp_reg[index] = np.nan</span><br><span class="line">    mat_reg = mat_rshp_reg.reshape((b, c))</span><br><span class="line">    pvalue = f_regression(mat_rshp, sequence)[<span class="number">1</span>].reshape(b, c)</span><br><span class="line">    <span class="keyword">return</span> mat_reg, pvalue</span><br></pre></td></tr></table></figure><h2 id="去趋势">去趋势</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> detrend</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDetrend</span>(<span class="params">array</span>):</span><br><span class="line">    index = np.isnan(array.values).<span class="built_in">any</span>(axis=<span class="number">0</span>)</span><br><span class="line">    array.values[:, index] = -<span class="number">999</span></span><br><span class="line">    array_detrend = detrend(array.values, axis=<span class="number">0</span>)</span><br><span class="line">    array_detrend[:, index] = np.nan</span><br><span class="line">    <span class="keyword">return</span> array.copy(data=array_detrend)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="滑动平均">滑动平均</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PointSmo</span>(<span class="params">array, num=<span class="number">9</span>, add=<span class="literal">False</span></span>):</span><br><span class="line">    start = <span class="built_in">int</span>((num-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    end = array.shape[<span class="number">0</span>] - <span class="built_in">int</span>((num-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    result = np.zeros_like(array) * np.nan</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">        result[i] = array[i-<span class="built_in">int</span>((num-<span class="number">1</span>)/<span class="number">2</span>):i+<span class="built_in">int</span>((num-<span class="number">1</span>)/<span class="number">2</span>)+<span class="number">1</span>].mean()</span><br><span class="line">    <span class="keyword">if</span> add:</span><br><span class="line">        result = np.where(np.isnan(result), sequence, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="计算相关">计算相关</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr, linregress</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getCor</span>(<span class="params">mat, sequence</span>):</span><br><span class="line">    cor = np.zeros(mat.shape[<span class="number">1</span>:])</span><br><span class="line">    pvalue = np.zeros(mat.shape[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mat.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mat.shape[<span class="number">2</span>]):</span><br><span class="line">            cor[i,j], pvalue[i,j] = pearsonr(mat[:,i,j].values, sequence.values)</span><br><span class="line">    <span class="keyword">return</span> cor, pvalue</span><br></pre></td></tr></table></figure><h2 id="Bootstrap合成检验">Bootstrap合成检验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getBootstrap</span>(<span class="params">mat1, mat2, comValue</span>):</span><br><span class="line">    comSize1 = mat1.shape[<span class="number">0</span>]</span><br><span class="line">    comSize2 = mat2.shape[<span class="number">0</span>]</span><br><span class="line">    N = <span class="number">1000</span></span><br><span class="line">    Mean1 = np.zeros((N, mat1.shape[<span class="number">1</span>], mat1.shape[<span class="number">2</span>]))</span><br><span class="line">    Mean2 = np.zeros((N, mat2.shape[<span class="number">1</span>], mat2.shape[<span class="number">2</span>]))</span><br><span class="line">    p = np.ones(mat1.shape[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        seed = np.random.randint(<span class="number">0</span>, mat1.shape[<span class="number">0</span>] , size=mat1.shape[<span class="number">0</span>])</span><br><span class="line">        sample = np.random.choice(seed, size=comSize1, replace=<span class="literal">True</span>)</span><br><span class="line">        Mean1[k,...] = mat1[sample,...].mean(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        seed = np.random.randint(<span class="number">0</span>, mat2.shape[<span class="number">0</span>] , size=mat2.shape[<span class="number">0</span>])</span><br><span class="line">        sample = np.random.choice(seed, size=comSize2, replace=<span class="literal">True</span>)</span><br><span class="line">        Mean2[k,...] = mat2[sample,...].mean(axis=<span class="number">0</span>)</span><br><span class="line">    Mean = Mean2 - Mean1</span><br><span class="line">    p[np.where((comValue&lt;np.percentile(Mean,<span class="number">2.5</span>,axis=<span class="number">0</span>)) | (comValue&gt;np.percentile(Mean,<span class="number">97.5</span>,axis=<span class="number">0</span>)))] = <span class="number">0.01</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="计算科氏参数">计算科氏参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metpy.constants <span class="keyword">import</span> earth_avg_angular_vel</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getCorio</span>(<span class="params">latmat</span>):</span><br><span class="line">    _f = <span class="number">2</span> * earth_avg_angular_vel.magnitude * np.sin(np.deg2rad(latmat))</span><br><span class="line">    <span class="keyword">return</span> _f</span><br></pre></td></tr></table></figure><h2 id="Proplot投影">Proplot投影</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;cyl&#x27;</span>) <span class="comment"># npaeqd 北极投影</span></span><br><span class="line">ax.contourf(lon, lat, mat, colorbar=<span class="literal">True</span>)</span><br><span class="line">ax.<span class="built_in">format</span>(coast=<span class="literal">True</span>, labels=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="画矩形">画矩形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> PathPatch</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRect</span>(<span class="params">points, color=<span class="string">&#x27;blue&#x27;</span>,lw=<span class="number">1</span>, flag=<span class="literal">True</span>, path=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># [75,90,50,60] # 经度，纬度</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        rec = np.array([[points[<span class="number">0</span>], points[<span class="number">3</span>]], [points[<span class="number">0</span>], points[<span class="number">2</span>]], </span><br><span class="line">                        [points[<span class="number">1</span>], points[<span class="number">2</span>]], [points[<span class="number">1</span>], points[<span class="number">3</span>]], [points[<span class="number">0</span>], points[<span class="number">3</span>]]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rec = points</span><br><span class="line">    pa = Path(rec)</span><br><span class="line">    pathcopy = pa.copy()</span><br><span class="line">    pa = pa.interpolated(<span class="number">100</span>)</span><br><span class="line">    patch = PathPatch(pa, facecolor=<span class="string">&#x27;None&#x27;</span>, edgecolor=color,</span><br><span class="line">            transform=ccrs.PlateCarree(), lw=lw)</span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        <span class="keyword">return</span> pathcopy</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> patch</span><br><span class="line">    </span><br><span class="line">ax[i].add_patch(getRect([-<span class="number">180</span>,-<span class="number">120</span>,<span class="number">5</span>,<span class="number">25</span>])) <span class="comment"># 矩形</span></span><br><span class="line">ax[i].add_patch(getRect(np.array([[<span class="number">150</span>,<span class="number">0</span>],[<span class="number">210</span>,<span class="number">0</span>],[<span class="number">240</span>,<span class="number">10</span>],[<span class="number">240</span>,<span class="number">40</span>],[<span class="number">150</span>,<span class="number">0</span>]]), flag=<span class="literal">False</span>)) <span class="comment"># 非矩形用，如平行四边形</span></span><br></pre></td></tr></table></figure><h2 id="特定年份范围数据路径">特定年份范围数据路径</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数保留1979-2022年数据</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDataPath</span>(<span class="params">_path</span>):</span><br><span class="line">    pathFilter = glob.glob(_path)</span><br><span class="line">    index = ((pd.Series(pathFilter).<span class="built_in">str</span>[-<span class="number">7</span>:-<span class="number">3</span>].astype(<span class="built_in">int</span>)&gt;=<span class="number">1979</span>)&amp;(pd.Series(pathFilter).<span class="built_in">str</span>[-<span class="number">7</span>:-<span class="number">3</span>].astype(<span class="built_in">int</span>)&lt;=<span class="number">2022</span>)).to_list()</span><br><span class="line">    pathFilter = np.array(pathFilter)[index].tolist()</span><br><span class="line">    <span class="keyword">return</span> pathFilter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EP通量、能量与eddy通量关系推导</title>
      <link href="/2023/05/09/Eliassen-Palm/"/>
      <url>/2023/05/09/Eliassen-Palm/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>前言</h1><p>Eliassem-Palm，1961第二章能量通量与eddy通量关系推导整理</p><p>参考文献：</p><ol><li>Eliassen &amp; Palm. On the transfer of energy in stationary mountain waves. <em>Geofys. Publ.</em> (1961).</li></ol><h1>扰动方程组</h1><p>由原始方程组 (绝热、静力平衡、无摩擦)<br>$$<br>\begin{align}<br>&amp;\frac{ {du} }{ {dt} } =  - \frac{ {\partial \phi } }{ {\partial x} } + fv\\<br>&amp;\frac{ {dv} }{ {dt} } =  - \frac{ {\partial \phi } }{ {\partial y} } - fu\\<br>&amp;\frac{ {\partial p} }{ {\partial z} } =  - \rho g\\<br>&amp;\frac{ {\partial u} }{ {\partial x} } + \frac{ {\partial v} }{ {\partial y} } + \frac{ {\partial \omega } }{ {\partial p} } = 0\\<br>&amp;\frac{ {d\theta } }{ {dt} } = 0<br>\end{align}<br>$$<br>考虑基本流场为纬向均匀的U风场，无大尺度垂直运动，缓变（时间偏导数为0），即<br>$$<br>\begin{align}<br>u &amp;= \bar u + u’\\<br>v &amp;= v’\\<br>\omega  &amp;= \omega’\\<br>\phi &amp;= \bar \phi + \phi’\\<br>\frac{\partial}{\partial t} &amp;= 0\\<br>\frac{\partial \bar u}{\partial x} &amp;= \frac{\partial \bar \phi}{\partial x} = 0\\<br>\end{align}<br>$$<br>认为各动力学变量纬向均匀即 $\bar \phi=\bar \phi(y,p)$, $\bar u=\bar u(y,p)$, $\rho=\rho(y,p)$ 。</p><h2 id="x方向">x方向</h2><p>将公式 (6-11) 代入公式 (1) 得<br>$$<br>\begin{align}<br>(\bar u + u’)\frac{ {\partial \bar u + u’} }{ {\partial x} } + v’\frac{ {\partial \bar u + u’} }{ {\partial y} } + \omega’\frac{ {\partial \bar u + u’} }{ {\partial p} } &amp;=  - \frac{ {\partial \bar \phi  + \phi’} }{ {\partial x} } + fv’\\(消去偏x和二阶小量)<br>\bar u\frac{ {\partial u’} }{ {\partial x} } + v’\frac{ {\partial \bar u} }{ {\partial y} } + \omega’\frac{ {\partial \bar u} }{ {\partial p} } &amp;=  - \frac{ {\partial \phi’} }{ {\partial x} } + fv’\\<br>\bar u\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)v’ + \omega’\frac{ {\partial \bar u} }{ {\partial p} } + \frac{ {\partial \phi’} }{ {\partial x} } &amp;= 0<br>\end{align}<br>$$</p><h2 id="y方向">y方向</h2><p>由于平均量需要满足公式 (2) 即<br>$$<br>\begin{align}<br>\frac{ {d\bar v} }{ {dt} } &amp;=  - \frac{ {\partial \bar \phi } }{ {\partial y} } - f\bar u\\(\bar v=0)<br>f\bar u &amp;=  - \frac{ {\partial \bar \phi } }{ {\partial y} }<br>\end{align}<br>$$</p><p>将公式 (6-11) 代入公式 (2) 得<br>$$<br>\begin{align}<br>(\bar u + u’)\frac{ {\partial v’} }{ {\partial x} } + v’\frac{ {\partial v’} }{ {\partial y} } + \omega’\frac{ {\partial v’} }{ {\partial p} } &amp;=  - \frac{ {\partial \bar \phi  + \phi’} }{ {\partial y} } - f(\bar u + u’)\\(代入公式16, 消去二阶小量)<br>\bar u\frac{ {\partial v’} }{ {\partial x} } &amp;=  - \frac{ {\partial \phi’} }{ {\partial y} } - fu’\\<br>fu’ + \bar u\frac{ {\partial v’} }{ {\partial x} } + \frac{ {\partial \phi’} }{ {\partial y} } &amp;= 0<br>\end{align}<br>$$</p><h2 id="热力学">热力学</h2><p>又静力平衡公式 (3) 得<br>$$<br>\begin{align}<br>\frac{ {\partial \phi } }{ {\partial p} } =  - \frac{1}{\rho }<br>\end{align}<br>$$<br>公式 (20) 对 y 偏导，公式 (16) 对 p 偏导，两者消去 $\phi$ 项得<br>$$<br>\begin{align}<br>f\frac{ {\partial \bar u} }{ {\partial p} } &amp;= \frac{\partial }{ {\partial y} }(\frac{1}{\rho })\\<br>f\frac{ {\partial \bar u} }{ {\partial p} } &amp;= \frac{\partial }{ {\partial y} }(\frac{ {RT} }{p})\\<br>f\frac{ {\partial \bar u} }{ {\partial p} } &amp;= \frac{R}{p}\frac{ {\partial \theta } }{ {\partial y} }{(\frac{ { {p_0} } }{p})^{ - \frac{R}{ { {c_p} } } } }\\<br>\frac{ {\partial \theta } }{ {\partial y} } &amp;= \frac{ {fp} }{R}{(\frac{ { {p_0} } }{p})^{\frac{R}{ { {c_p} } } } }\frac{ {\partial \bar u} }{ {\partial p} }<br>\end{align}<br>$$</p><p>将公式 (9) 代入公式 (20) 得<br>$$<br>\begin{align}<br>\frac{ {\partial \bar \phi  + \phi’} }{ {\partial p} } &amp;=  - \frac{1}{\rho }\\<br>\frac{ {\partial \bar \phi  + \phi’} }{ {\partial p} } &amp;=  - \frac{R}{p}{(\frac{ { {p_0} } }{p})^{ - \frac{R}{ { {c_p} } } } }\theta \\(两边对x求导)<br>\frac{ { {\partial ^2}\bar \phi  + \phi’} }{ {\partial x\partial p} } &amp;=  - \frac{R}{p}{(\frac{ { {p_0} } }{p})^{ - \frac{R}{ { {c_p} } } } }\frac{ {\partial \theta } }{ {\partial x} }\\(\bar \phi 与x无关)<br>\frac{ {\partial \theta } }{ {\partial x} } &amp;=  - \frac{R}{p}{(\frac{ { {p_0} } }{p})^{ - \frac{R}{ { {c_p} } } } }\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} }<br>\end{align}<br>$$</p><p>将公式 (6-11) 代入公式 (5) 得<br>$$<br>\begin{align}<br>(\bar u + u’)\frac{ {\partial \theta } }{ {\partial x} } + v’\frac{ {\partial \theta } }{ {\partial y} } + \omega’\frac{ {\partial \theta } }{ {\partial p} } = 0<br>\end{align}<br>$$<br>将公式 (24、28) 代入公式 (29)<br>$$<br>\begin{align}<br>-(\bar u + u’)\frac{p}{R}{(\frac{ { {p_0} } }{p})^{\frac{R}{ { {c_p} } } } }\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } + v’\frac{ {fp} }{R}{(\frac{ { {p_0} } }{p})^{\frac{R}{ { {c_p} } } } }\frac{ {\partial \bar u} }{ {\partial p} } + \omega’\frac{ {\partial \theta } }{ {\partial p} } = 0\\ (消去二阶小量)<br>-\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } + v’f\frac{ {\partial \bar u} }{ {\partial p} } + \frac{ {\omega’\frac{ {\partial \theta } }{ {\partial p} } } }{ {\frac{p}{R}{ {(\frac{ { {p_0} } }{p})}^{\frac{R}{ { {c_p} } } } } } } = 0 \\<br>\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } - v’f\frac{ {\partial \bar u} }{ {\partial p} } + \frac{ {\omega’\frac{ {\partial \theta } }{ {\partial p} } } }{ { -\rho \theta } } = 0 \\<br>\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } - v’f\frac{ {\partial \bar u} }{ {\partial p} } + \sigma \omega’ = 0<br>\end{align}<br>$$<br>其中 $\sigma= -\frac{ {\frac{ {\partial \theta } }{ {\partial p} } } }{ {\rho \theta } }$</p><p>联立公式 (14、19、33、4) 得扰动方程组<br>$$<br>\begin{align}<br>\bar u\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)v’ + \omega’\frac{ {\partial \bar u} }{ {\partial p} } + \frac{ {\partial \phi’} }{ {\partial x} } &amp;= 0\\<br>fu’ + \bar u\frac{ {\partial v’} }{ {\partial x} } + \frac{ {\partial \phi’} }{ {\partial y} } &amp;= 0\\<br>\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } - v’f\frac{ {\partial \bar u} }{ {\partial p} } + \sigma \omega’ &amp;= 0\\<br>\frac{ {\partial u’} }{ {\partial x} } + \frac{ {\partial v’} }{ {\partial y} } + \frac{ {\partial \omega’ } }{ {\partial p} } &amp;= 0<br>\end{align}<br>$$</p><h1>能量散度方程</h1><p>公式 (34) 乘 $u’$ , 公式 (35) 乘 $v’$ , 公式 (36) 乘 $\sigma^{-1} \frac{\partial \phi’}{\partial p}$<br>$$<br>\begin{align}<br>\bar uu’\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)u’v’ + u’\omega’\frac{ {\partial \bar u} }{ {\partial p} } + u’\frac{ {\partial \phi’} }{ {\partial x} } = 0\\<br>fu’v’ + \bar uv’\frac{ {\partial v’} }{ {\partial x} } + v’\frac{ {\partial \phi’} }{ {\partial y} } = 0\\<br>\bar u{\sigma ^{ - 1} }\frac{ {\partial \phi’} }{ {\partial p} }\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } - v’f{\sigma ^{ - 1} }\frac{ {\partial \phi’} }{ {\partial p} }\frac{ {\partial \bar u} }{ {\partial p} } + \omega’\frac{ {\partial \phi’} }{ {\partial p} } = 0<br>\end{align}<br>$$<br>公式 (38-40) 相加得<br>$$<br>\begin{align}<br>\frac{1}{2}\bar u\frac{ {\partial { {u’}^2} + { {v’}^2} } }{ {\partial x} } + \frac{1}{ {2\sigma } }\bar u\frac{\partial }{ {\partial x} }{(\frac{ {\partial \phi’ } }{ {\partial p} })^2} + \frac{ {\partial \phi’u’} }{ {\partial x} } + \frac{ {\partial \phi’v’} }{ {\partial y} } + \frac{ {\partial \phi’\omega’} }{ {\partial p} } = …\\<br>-\frac{ {\partial \bar u} }{ {\partial y} }u’v’ - \frac{ {\partial \bar u} }{ {\partial p} }u’\omega’ + \frac{ {f\frac{ {\partial \bar u} }{ {\partial p} } } }{\sigma }v’\frac{ {\partial \phi’} }{ {\partial p} }\\<br>\frac{ {\partial E\bar u + \phi’u’} }{ {\partial x} } + \frac{ {\partial \phi’v’} }{ {\partial y} } + \frac{ {\partial \phi’\omega’} }{ {\partial p} } =  - \frac{ {\partial \bar u} }{ {\partial y} }u’v’ - \frac{ {\partial \bar u} }{ {\partial p} }u’\omega’ + \frac{ {f\frac{ {\partial \bar u} }{ {\partial p} } } }{\sigma }v’\frac{ {\partial \phi’} }{ {\partial p} }<br>\end{align}<br>$$<br>其中  $E=\frac{1}{2}\frac{ {\partial { {u’}^2} + { {v’}^2} } }{ {\partial x} } + \frac{1}{ {2\sigma } }\frac{\partial }{ {\partial x} }{(\frac{ {\partial \phi’ } }{ {\partial p} })^2}$  表示单位质量的波能量（动能+有效位能）</p><h1>经向、垂直方向能量输送</h1><h3 id="经向输送">经向输送</h3><p>将公式 (36) 代入公式 (34) 消去 $\omega’$<br>$$<br>\begin{align}<br>\bar u\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)v’ + {\sigma ^{ - 1} }( - \bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } + v’f\frac{ {\partial \bar u} }{ {\partial p} })\frac{ {\partial \bar u} }{ {\partial p} } + \frac{ {\partial \phi’} }{ {\partial x} } = 0\\<br>\bar u\frac{ {\partial u’} }{ {\partial x} } - {\sigma ^{ - 1} }\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} }\frac{ {\partial \bar u} }{ {\partial p} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})v’ + \frac{ {\partial \phi’} }{ {\partial x} } = 0\\<br>\frac{\partial }{ {\partial x} }(\bar uu’ + \phi’ - {\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} }) = (f - \frac{ {\partial \bar u} }{ {\partial y} } - {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})v’<br>\end{align}<br>$$</p><blockquote><p>公式 (45) 到 (46) 过程中，$\bar u$ 与 $x$ 无关所以可以放入偏微分号内部。但 $\sigma$ 这一项是与 $\theta$ 关联的，而 $\theta$ 是否与 $x$ 有关呢？</p></blockquote><p>对公式 (46) 乘 $\bar uu’ + \phi’ - {\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} }$ 并对方程两边求纬向平均<br>$$<br>\begin{align}<br>{\rm{0} } &amp;= \overline {(\bar uu’ + \phi’ - {\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} })(f - \frac{ {\partial \bar u} }{ {\partial y} } - {\sigma ^{ - 1} }f{ {(\frac{ {\partial \bar u} }{ {\partial p} })}^2})v’} \\ (下面纬向平均符号省略)<br>0 &amp;= (f\bar uu’ + f\phi’ - f{\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} } - \frac{ {\partial \bar u} }{ {\partial y} }\bar uu’ - \frac{ {\partial \bar u} }{ {\partial y} }\phi’ + {\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \bar u} }{ {\partial y} }\frac{ {\partial \phi’} }{ {\partial p} } + …\\<br>&amp;… - \bar uu’{\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2} - \phi’{\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2} + {\sigma ^{ - 2} }\bar uf{(\frac{ {\partial \bar u} }{ {\partial p} })^3}\frac{ {\partial \phi’} }{ {\partial p} })v’\\<br>(\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})\phi’v’ &amp;= (f\bar uu’ - f{\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} } - \frac{ {\partial \bar u} }{ {\partial y} }\bar uu’ + {\sigma ^{ - 1} }\bar u\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \bar u} }{ {\partial y} }\frac{ {\partial \phi’} }{ {\partial p} } + …\\<br>&amp;… - \bar uu’{\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2} + {\sigma ^{ - 2} }\bar uf{(\frac{ {\partial \bar u} }{ {\partial p} })^3}\frac{ {\partial \phi’} }{ {\partial p} })v’\\<br>(\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})\phi’v’ &amp;= \bar u(f - \frac{ {\partial \bar u} }{ {\partial y} } - {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})u’v’ + …\\<br>&amp;… + \bar u({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial y} }\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} } - {\sigma ^{ - 1} }f\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} } + {\sigma ^{ - 2} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^3}\frac{ {\partial \phi’} }{ {\partial p} })v’\\<br>(\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})\phi’v’ &amp;=  - \bar u(\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})u’v’ + …\\<br>&amp;… + \bar u{\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} }(\frac{ {\partial \bar u} }{ {\partial y} } - f + {\sigma ^{ - 1} }f{(\frac{ {\partial \bar u} }{ {\partial p} })^2})v’\\<br>\phi’v’ &amp;=  - \bar uu’v’ + \bar u{\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\frac{ {\partial \phi’} }{ {\partial p} }v’\\<br>\overline {\phi’v’}  &amp;= \bar u({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} )<br>\end{align}<br>$$</p><h3 id="垂直输送">垂直输送</h3><p>对公式 (34) 乘 $\bar uu’ + \phi’ $<br>$$<br>\begin{align}<br>{ {\bar u}^2}u’\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)\bar uu’v’ + \bar uu’\omega’\frac{ {\partial \bar u} }{ {\partial p} } + \bar uu’\frac{ {\partial \phi’} }{ {\partial x} } + …\\<br>… + \bar u\phi’\frac{ {\partial u’} }{ {\partial x} } + (\frac{ {\partial \bar u} }{ {\partial y} } - f)v’\phi’ + \phi’\omega’\frac{ {\partial \bar u} }{ {\partial p} } + \phi’\frac{ {\partial \phi’} }{ {\partial x} } = 0\\<br>\frac{ {\partial \bar u} }{ {\partial p} }(\bar uu’\omega’ + \phi’\omega’) + \bar uu’v’(\frac{ {\partial \bar u} }{ {\partial y} } - f) + v’\phi’(\frac{ {\partial \bar u} }{ {\partial y} } - f) + …\\<br>… + \frac{1}{2}{ {\bar u}^2}\frac{ {\partial { {u’}^2} } }{ {\partial x} } + \frac{1}{2}\frac{ {\partial { {\phi’}^2} } }{ {\partial x} } + \bar u\frac{ {\partial u’\phi’} }{ {\partial x} } = 0<br>\end{align}<br>$$<br>做纬向平均得<br>$$<br>\begin{align}<br>(\bar u\overline {u’v’}  + \overline {v’\phi’} )(f - \frac{ {\partial \bar u} }{ {\partial y} }) = \frac{ {\partial \bar u} }{ {\partial p} }(\bar u\overline {u’\omega’}  + \overline {\phi’\omega’} )<br>\end{align}<br>$$<br>将公式 (57) 代入 公式 (62) 得<br>$$<br>\begin{align}<br>(\bar u\overline {u’v’}  + \bar u({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} ))(f - \frac{ {\partial \bar u} }{ {\partial y} }) = \frac{ {\partial \bar u} }{ {\partial p} }(\bar u\overline {u’\omega’}  + \overline {\phi’\omega’} )\\<br>\bar u{\sigma ^{ - 1} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’} (f - \frac{ {\partial \bar u} }{ {\partial y} }) = (\bar u\overline {u’\omega’}  + \overline {\phi’\omega’} )\\<br>\overline {\phi’\omega’}  = \bar u[{\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’} ]<br>\end{align}<br>$$</p><p>对公式 (43) 求纬向平均并将公式 (57) 和 (65) 代入方程<br>$$<br>\begin{align}<br>&amp;\frac{ {\partial \overline {\phi’v’} } }{ {\partial y} } + \frac{ {\partial \overline {\phi’\omega’} } }{ {\partial p} } =  - \frac{ {\partial \bar u} }{ {\partial y} }\overline {u’v’}  - \frac{ {\partial \bar u} }{ {\partial p} }\overline {u’\omega’}  + \frac{ {f\frac{ {\partial \bar u} }{ {\partial p} } } }{\sigma }\overline {v’\frac{ {\partial \phi’} }{ {\partial p} } } \\<br>&amp;\frac{\partial }{ {\partial y} }[\bar u({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} )] + \frac{\partial }{ {\partial p} }[\bar u[{\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’} ]] =  - \frac{ {\partial \bar u} }{ {\partial y} }\overline {u’v’}  - \frac{ {\partial \bar u} }{ {\partial p} }\overline {u’\omega’}  + \frac{ {f\frac{ {\partial \bar u} }{ {\partial p} } } }{\sigma }\overline {v’\frac{ {\partial \phi’} }{ {\partial p} } } \\<br>&amp;\frac{ {\partial \bar u} }{ {\partial y} }({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} ) + \bar u\frac{\partial }{ {\partial y} }({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} ) + …\\<br>&amp;… + \frac{ {\partial \bar u} }{ {\partial p} }({\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’} ) + \bar u\frac{\partial }{ {\partial p} }({\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’} ) =  - \frac{ {\partial \bar u} }{ {\partial y} }\overline {u’v’}  - \frac{ {\partial \bar u} }{ {\partial p} }\overline {u’\omega’}  + \frac{ {f\frac{ {\partial \bar u} }{ {\partial p} } } }{\sigma }\overline {v’\frac{ {\partial \phi’} }{ {\partial p} } } \\<br>&amp;\frac{\partial }{ {\partial y} }({\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’} ) + \frac{\partial }{ {\partial p} }({\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’} ) = 0<br>\end{align}<br>$$<br>记 $\frac{ {\partial \psi } }{ {\partial p} }={\sigma ^{ - 1} }\frac{ {\partial \bar u} }{ {\partial p} }\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’v’}$ 和 $\frac{ {\partial \psi } }{ {\partial y} }={\sigma ^{ - 1} }(f - \frac{ {\partial \bar u} }{ {\partial y} })\overline {\frac{ {\partial \phi’} }{ {\partial p} }v’}  - \overline {u’\omega’}$  因此<br>$$<br>\begin{align}<br>\overline {\phi’v’}  &amp;= \bar u\frac{ {\partial \psi } }{ {\partial p} }\\<br>\overline {\phi’\omega’}  &amp;=  - \bar u\frac{ {\partial \psi } }{ {\partial y} }<br>\end{align}<br>$$</p><h1>准地转近似</h1><p>上述公式在准地转近似下会有更为简单的形式</p><h3 id="扰动方程组">扰动方程组</h3><p>由公式 (1)，(2) 得地转关系<br>$$<br>\begin{align}<br>fv = \frac{ {\partial \phi } }{ {\partial x} }\\<br>fu =  - \frac{ {\partial \phi } }{ {\partial y} }<br>\end{align}<br>$$<br>基本流场需满足地转关系，同时扰动也满足地转关系<br>$$<br>\begin{align}<br>f\bar v = \frac{ {\partial \bar \phi } }{ {\partial x} }\\<br>f\bar u =  - \frac{ {\partial \bar \phi } }{ {\partial y} }\\<br>fv’ = \frac{ {\partial \phi’} }{ {\partial x} }\\<br>fu’ =  - \frac{ {\partial \phi’} }{ {\partial y} }<br>\end{align}<br>$$<br>对公式 (1), (2) 的平流项取地转风 ($\bar u$, $\bar v$ )，公式 (5) 的经向平流取地转风， 忽略 $\omega$ 平流<br>$$<br>\begin{align}<br>\frac{ {\partial u} }{ {\partial t} } + \bar u\frac{ {\partial u} }{ {\partial x} } + \bar v\frac{ {\partial u} }{ {\partial y} } &amp;=  - \frac{ {\partial \phi } }{ {\partial x} } + fv\\<br>\frac{ {\partial v} }{ {\partial t} } + \bar u\frac{ {\partial v} }{ {\partial x} } + \bar v\frac{ {\partial v} }{ {\partial y} } &amp;=  - \frac{ {\partial \phi } }{ {\partial y} } - fu\\<br>\frac{ {\partial \theta } }{ {\partial t} } + u\frac{ {\partial \theta } }{ {\partial x} } + \bar v\frac{ {\partial \theta } }{ {\partial y} } &amp;= 0<br>\end{align}<br>$$<br>将公式 (6)-(11) 代入公式(3)-(4), (79)-(81) 得扰动方程组<br>$$<br>\begin{align}<br>\bar u\frac{ {\partial u’} }{ {\partial x} } - fv’ + \frac{ {\partial \phi’} }{ {\partial x} } = 0\\<br>fu’ + \bar u\frac{ {\partial v’} }{ {\partial x} } + \frac{ {\partial \phi’} }{ {\partial y} } = 0\\<br>\bar u\frac{ { {\partial ^2}\phi’} }{ {\partial x\partial p} } + \sigma \omega’ = 0\\<br>\frac{ {\partial u’} }{ {\partial x} } + \frac{ {\partial v’} }{ {\partial y} } + \frac{ {\partial \omega’} }{ {\partial p} } = 0<br>\end{align}<br>$$</p><h3 id="经向输送-2">经向输送</h3><p>公式 (82) 整理得<br>$$<br>\begin{align}<br>\frac{ {\partial \bar uu’ + \phi’} }{ {\partial x} } = fv’<br>\end{align}<br>$$<br>两边同乘 ${\bar uu’ + \phi’}$ 并纬向平均得<br>$$<br>\begin{align}<br>0 &amp;= \overline {(\bar uu’ + \phi’)fv’} \\<br>\overline {\phi’v’}  &amp;=  - \bar u\overline {u’v’}<br>\end{align}<br>$$</p><h3 id="垂直输送-2">垂直输送</h3><blockquote><p>准地转近似下没推导出来(ಥ﹏ಥ)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大气数学理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大气理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lorenz 能量循环框架推导</title>
      <link href="/2023/04/17/Lorenz-energy/"/>
      <url>/2023/04/17/Lorenz-energy/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>Lorenz大气能量循环框架推导。</p><p>参考文献：</p><ol><li><p>Lorenz, E. N. Available Potential Energy and the Maintenance of the General Circulation. <em>Tellus</em> <strong>7</strong>, 157–167 (1955).</p></li><li><p>大气动力学，刘式适、刘式达，第一版和第二版</p></li><li><p>动力气象学，吕美仲，第一版</p></li></ol><h1>有效位能的定义</h1><p>有效位能是大气全位能与最小全位能之差。</p><p>全位能是位能 $P$ 与内能 $I$ 之和，垂直积分结果为</p><p>$$<br>\begin{align}<br>P + I &amp;= \int_0^{ + \infty } {\rho (gz + {c_v}T)} dz\\<br>&amp;= \int_0^{ + \infty } { - \frac{ {\partial p} }{ {\partial z} }z} dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\(静力平衡)<br>&amp;=  - \int_{ {p_s} }^0 z dp + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;=  - \int_{ {p_s} }^0 z dp + \int_0^{ + \infty } {\rho {c_v}T} dz,\\(分部积分)<br>&amp;=  - [pz]_{ {p_s} }^0 + \int_0^{ + \infty } p dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho RT} dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho (R + {c_v})T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho {c_p}T} dz\\<br>&amp;= \frac{ { {c_p} } }{g}\int_0^{ {p_0} } T dp<br>\end{align}<br>$$</p><p>其中 $ p_s $ 是地面气压，由于 $ T=\theta(\frac{p_{0} }{p})^{-\frac{R}{c_p} } $ 代入公式 (9)</p><p>$$<br>\begin{align}<br>P + I &amp;= \frac{ { {c_p} } }{g}{\int_0^{ {p_s} } {\theta (\frac{ { {p_0} } }{p})} ^{ - \frac{R}{ { {c_p} } } } }dp\\<br>&amp; = \frac{ { {c_p} } }{g}(1 + \frac{R}{ { {c_p} } }){p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } {\theta d{p^{1 + \frac{R}{ { {c_p} } } } } } \\ （分部积分）<br>&amp;= \frac{ { {c_p} } }{g}(1 + \frac{R}{ { {c_p} } }){p_0}^{ - \frac{R}{ { {c_p} } } }([\theta {p^{1 + \frac{R}{ { {c_p} } } } }]_0^{ {p_s} } - \int_0^{ {p_s} } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta } )\\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta }<br>\end{align}<br>$$</p><p>由于定义地表以下$\theta=0$,对$p$的积分范围$\int_0^{ {p_s} }$相当于对$\theta$的积分范围$\int_{+\infty}^{ {0} }$</p><p>那么有效位能可以用大气全位能与大气参考状态的全位能之差来表示</p><p>$$<br>\begin{align}<br>\ A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta  - } \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta }<br>\end{align}<br>$$</p><p>$\bar p$  表示等熵参考面上气压的平均值。全球平均（水平平均）有效位能为</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta }<br>\end{align}<br>$$</p><p>取 $p=\bar p + p\prime$</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {(\overline {\bar p + p’{)^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }({ {(1 + \frac{ {p’} }{ {\bar p} })}^{1 + \frac{R}{ { {c_p} } } } } - 1)d\theta } \\(\frac{\bar p}{p\prime}=0处泰勒展开)<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }(1 + \frac{ {(1 + \frac{R}{ { {c_p} } }){ {(1 + 0)}^{\frac{R}{ { {c_p} } } } } } }{ {1!} }(\frac{ {p’} }{ {\bar p} } - 0) + } } \\<br>&amp;\overline { + \frac{ {(1 + \frac{R}{ { {c_p} } })\frac{R}{ { {c_p} } }{ {(1 + 0)}^{\frac{R}{ { {c_p} } } - 1} } } }{ {2!} }{ {(\frac{ {p’} }{ {\bar p} } - 0)}^2} + … - 1)} d\theta \\(保留到2阶，1阶平均为0)<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }{ {(\overline {\frac{ {p’} }{ {\bar p} } } )}^2}d\theta }<br>\end{align}<br>$$</p><p>即</p><p>$$<br>\begin{align}<br>\bar A &amp;=\frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }{ {(\overline {\frac{ {p’} }{ {\bar p} } } )}^2}d\theta }<br>\end{align}<br>$$</p><h2 id="P坐标系下有效位能">P坐标系下有效位能</h2><p>定义 $\bar \theta$, $\theta’$ , $\bar T$, $T’$ 分别是等压面上的均值和偏差。对于等熵面上的气压，近似有 $ p=\bar p(\bar {\theta} ( p ) ) $ 。由此</p><p>$$<br>\begin{align}<br>p’ &amp;= p - \bar p\\<br>&amp;= \bar p(\bar \theta ) - \bar p(\theta )\\<br>&amp;= \bar p(\theta  - \theta ‘) - \bar p(\theta )\\(\bar p(\theta-\theta\prime)在\theta处泰勒展开)<br>&amp;= \bar p(\theta ) + \frac{ {\bar p(\theta )’} }{ {1!} }(\theta  - \theta ’ - \theta ) - \bar p(\theta )\\<br>&amp;=  - \theta '\frac{ {\partial \bar p} }{ {\partial \theta } }<br>\end{align}<br>$$</p><p>公式 (28) 代入 $\overline{(\frac{p’}{\bar p})^2}$ ，并设 $\bar p(\theta)$ 和 $\bar \theta§$ 互为反函数 ($\frac{\partial \bar p }{\theta}=(\frac{\partial \bar \theta }{p})^{-1}$, 动力气象P145)</p><p>$$<br>\begin{align}<br>\overline { { {(\frac{ {p’} }{ {\bar p} })}^2} }  &amp;= \frac{1}{ { { {\bar p}^2} } }\overline { { {(\theta '\frac{ {\partial \bar p} }{ {\partial \theta } })}^2} } \\<br>&amp;= \frac{1}{ { { {\bar p}^2} } }\overline { { {(\theta ')}^2}{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} } }<br>\end{align}<br>$$</p><p>将公式 (30) 代入公式 (23) ，(认为 $d\theta≈\frac{\partial \bar \theta}{\partial p}dp$, 动力气象P145) 得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }\frac{1}{ { { {\bar p}^2} } }\overline { { {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }{ {(\theta ')}^2} } d\theta } \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_{ {p_s} }^0 { { {\bar p}^{\frac{R}{ { {c_p} } } - 1} }{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }\overline { { {(\theta ')}^2} } \frac{ {\partial \bar \theta } }{ {\partial p} }dp} \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } { { {\bar \theta }^2}{ {\bar p}^{\frac{R}{ { {c_p} } } - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } { {( - \frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 1} }dp}<br>\end{align}<br>$$</p><h3 id="位温对气压的偏微分">位温对气压的偏微分</h3><p>由于 $\theta=T(\frac{p_{0} }{p})^{\frac{R}{c_p} }$ 取对数</p><p>$$<br>\begin{align}<br>\ln \theta  = \ln T + \frac{R}{ { {c_p} } }\ln {p_0} - \frac{R}{ { {c_p} } }\ln p<br>\end{align}<br>$$</p><p>对 $p$ 求偏导</p><p>$$<br>\begin{align}<br>\frac{1}{\theta }\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{1}{T}\frac{ {\partial T} }{ {\partial p} } - \frac{R}{ { {c_p}p} }\\<br>\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{\theta }{T}\frac{ {\partial T} }{ {\partial p} } - \frac{R}{ { {c_p} } }\frac{\theta }{p}<br>\end{align}<br>$$</p><p>又</p><p>$$<br>\begin{align}<br>\frac{ {\partial T} }{ {\partial p} } &amp;= \frac{ {\partial T} }{ {\partial z} }\frac{ {\partial z} }{ {\partial p} }\\<br>&amp;=  - \gamma ( - \frac{1}{ {\rho g} })\\<br>&amp;= \gamma \frac{1}{ {\rho g} }<br>\end{align}<br>$$</p><p>其中 $\gamma = -\frac{\partial T}{\partial z}$ 是温度递减率。将公式 (39) 代入公式 (36)</p><p>$$<br>\begin{align}<br>\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{\theta }{T}\gamma \frac{1}{ {\rho g} } - \frac{ {gR} }{ {g{c_p} } }\frac{\theta }{p}\\<br>&amp;= \frac{\theta }{ {T\rho g} }\gamma  - \frac{R}{g}\frac{\theta }{p}{\gamma _d}\\<br>&amp;= (\frac{\theta }{ {T\rho g} }\gamma  - \frac{R}{g}\frac{\theta }{p}{\gamma _d})\frac{ {\frac{g}{ { {c_p} } } } }{ { {\gamma _d} } }\\<br>&amp;= \frac{ {\frac{\theta }{p}\frac{R}{ { {c_p} } }(\frac{ {p\gamma } }{ {T\rho R} } - {\gamma _d})} }{ { {\gamma _d} } }\\(状态方程)<br>&amp;=  - \theta {p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \gamma ){\gamma _d}^{ - 1}<br>\end{align}<br>$$</p><p>其中 $\gamma_d = \frac{g}{c_p}$ 是干绝热减温率。做等压面平均得</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar \theta } }{ {\partial p} }= - \bar \theta {\bar p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1}<br>\end{align}<br>$$</p><p>将公式 (45) 代入公式 (33)得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }\frac{1}{ { { {\bar p}^2} } }\overline { { {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }{ {(\theta ')}^2} } d\theta } \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_{ {p_s} }^0 { { {\bar p}^{\frac{R}{ { {c_p} } } - 1} }{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }\overline { { {(\theta ')}^2} } \frac{ {\partial \bar \theta } }{ {\partial p} }dp} \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } { { {\bar \theta }^2}{ {\bar p}^{\frac{R}{ { {c_p} } } - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } \frac{ {\bar p{\gamma _d} } }{ {\bar \theta \frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma )} }dp} \\<br>&amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } dp}<br>\end{align}<br>$$</p><p>将 $\theta=\bar \theta+\theta’$ 和 $T=\bar T+T’$ 代入公式 (34) 得</p><p>$$<br>\begin{align}<br>\ln (\bar \theta  + \theta ‘) &amp;= \ln (\bar T + T’) + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p)\\<br>\ln \bar \theta (1 + \frac{ {\theta ‘} }{ {\bar \theta } }) &amp;= \ln \bar T(1 + \frac{ {T’} }{ {\bar T} }) + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p),(T’,\theta ’ \ll \bar T,\bar \theta )\\<br>\ln \bar \theta  &amp;= \ln \bar T + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p)<br>\end{align}<br>$$</p><p>公式 (51) 减公式 (52)得 （大气动力学P128）:</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\ln (1 + \frac{ {\theta ‘} }{ {\bar \theta } }) &amp;= \ln (1 + \frac{ {T’} }{ {\bar T} }),(\frac{ {T’} }{ {\bar T} },\frac{ {\theta '} }{ {\bar \theta } } \ll 1)\\<br>\Rightarrow \frac{ {\theta ‘} }{ {\bar \theta } } &amp;= \frac{ {T’} }{ {\bar T} }<br>\end{align}<br>$$</p><p>将公式 (54) 代入公式 (49) 得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {T’} }{ {\bar T} })}^2} } dp}<br>\end{align}<br>$$</p><h2 id="有效位能倾向">有效位能倾向</h2><p>由熵形式热力学方程 (大气动力学P10)：</p><p>$$<br>\begin{align}<br>{c_p}T\frac{ {d\ln \theta } }{ {dt} } &amp;= Q\\<br>\frac{ {d\ln (\bar \theta  + \theta ‘)} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d\ln \bar \theta (1 + \frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d\ln \bar \theta } }{ {dt} } + \frac{ {d\ln (1 + \frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \omega \frac{ {\partial \ln \bar \theta } }{ {\partial p} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>其中 $Q=\bar Q + Q’$ 是单位质量空气在单位时间内从外界得到的能量，包括分子热传导、辐射、相变等方式。 $\bar Q，Q’$ 分别是 $Q$ 在等压面上的均值和偏差。另外 $\frac{\theta’}{\bar \theta}\ll 1$， $\bar \theta$ 只于垂直坐标有关。$ T’ \ll \bar T$</p><p>由公式 (40)-(44)知，公式 (60) 可进一步变化为</p><p>$$<br>\begin{align}<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \frac{\omega }{ {\bar \theta } }\frac{ {\partial \bar \theta } }{ {\partial p} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \frac{\omega }{ {\bar \theta } }( - \bar \theta {p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1}) &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } - \omega \frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>对公式 (60) 两边同乘 $\bar T (\gamma_d-\bar \gamma)^{-1}\frac{\theta’}{\bar \theta}$</p><p>$$<br>\begin{align}<br>\bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } } \cdot \frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } - \bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } } \cdot \omega \frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} } \cdot \bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } }\\<br>\frac{1}{2}\bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {d{ {(\frac{ {\theta ‘} }{ {\bar \theta } })}^2} } }{ {dt} } - \bar T\frac{ {\theta ‘} }{ {\bar \theta } }\omega \frac{R}{ {p{c_p} } }{\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p} } }{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } }\\<br>\frac{ {dA} }{ {dt} } - \int_0^{ps} {\bar T\frac{ {T’} }{ {\bar T} }\omega \frac{R}{ {p{c_p} } }\frac{ { {c_p} } }{g} } dp &amp;= \int_0^{ps} {\frac{ {\bar Q + Q’} }{ { {c_p} } }{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\frac{ {T’} }{ {\bar T} } } dp\\<br>\frac{ {dA} }{ {dt} } = \int_0^{ps} {T’\omega \frac{R}{ {pg} } } dp + \int_0^{ps} {\frac{ {(\bar Q + Q’)T’} }{ { {c_p}\bar T} }{ {({\gamma _d} - \bar \gamma )}^{ - 1} } } dp\\<br>\frac{ {\partial \bar A} }{ {\partial t} } = \int_0^{ps} {\overline {T\omega } \frac{R}{ {pg} } } dp + \int_0^{ps} {\frac{ {\overline {Q’T’} } }{ { {c_p}\bar T} }{ {({\gamma _d} - \bar \gamma )}^{ - 1} } } dp\\<br>\frac{ {\partial \bar A} }{ {\partial t} } = \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><blockquote><p>在公式 (65) 到 (66) 的步骤中，等号左边 $\bar T$ 是与垂直坐标有关的，因此严格得来说不能直接放入微分号内凑出 $A$。</p><p>在公式 (67) 到 (68) 的步骤中，等号左边的平流项先转为通量与散度的和的形式，通量在全球积分中为0，散度通过连续方程消去。<code>在等号右边第一项</code> $T’\omega$ <code>本应在水平平均中消去，Lorenz的文章中最终形式是</code> $\overline{T\omega}$ 。<code>不知如何处理</code></p></blockquote><p>因此全球积分的有效位能随时间倾向为</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial \bar A} }{ {\partial t} } &amp;= \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\(状态方程)<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= \int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><p>公式 (72) 就是Lorenz 文章中的有效位能倾向方程。公式 (71) 到公式 (72)有点难理解，但可以反过来推导：</p><p>$$<br>\begin{align}<br>\int_0^{ps} {\overline {V \cdot \nabla z} } dp &amp;= \int_0^{ps} {\overline {\nabla Vz} }  - \overline {z\nabla V} dp\\<br>&amp;=  - \int_0^{ps} {\overline {z\nabla V} } dp\\(连续方程)<br>&amp;= \int_0^{ps} {\overline {z\frac{ {\partial \omega } }{ {\partial p} } } } dp\\<br>&amp;= \int_0^{ps} {\overline z } d\omega \\<br>&amp;= [\overline {z\omega } ]_0^{ps} - \int_0^{ps} {\overline \omega  } dz\\(静力平衡)<br>&amp;=  - \int_0^{ps} {\overline {\omega \frac{1}{ { - \rho g} } } } dp\\<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp<br>\end{align}<br>$$</p><h2 id="纬向平均与扰动有效位能">纬向平均与扰动有效位能</h2><p>将物理量分解为纬向平均 (用 $[m]$ 表示) 与纬向偏差 (用 $m^*$ 表示)</p><p>$$<br>\begin{align}<br>u &amp;= [u] + u^* \\<br>v &amp;= [v] + v^* \\<br>\omega  &amp;= [\omega ] + \omega ^* \\<br>\theta '&amp;= [\theta '] + \theta '^* \\<br>T '&amp;= [T '] + T '^* \\<br>Q '&amp;= [Q '] + Q '^*<br>\end{align}<br>$$</p><p>热力学量 $\theta$ 在前文已经分解为 $\bar \theta + \theta’$ 。其中 $\bar \theta$ 表示水平平均。将公式 (84) 代入公式 (55) (不做水平积分平均)</p><p>$$<br>\begin{align}<br>A=\frac{1}{2}\int_0^{ps} {\bar T{ { ( {\gamma_d} - \bar \gamma ) }^{ - 1} }\frac{ { { {[T’]}^2} + 2[T’]{ {T’}^* } + { { ( { {T’}^* } ) }^2} } }{ { { {\bar T}^2} } } } dp<br>\end{align}<br>$$</p><p>对方程纬向平均</p><p>$$<br>\begin{align}<br>[A] &amp;= \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\frac{ {[{ {T’}^2}] + [{ {({ {T’}^* })}^2}]} }{ { { {\bar T}^2} } } } dp \\<br>&amp;= \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {(\frac{ {[T’]} }{ {\bar T} })}^2} } dp + \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }[{ {(\frac{ { { {T’}^* } } }{ {\bar T} })}^2}]} dp \\<br>&amp;= { { A}_m} + { { A}_p}<br>\end{align}<br>$$</p><p>即<code>有效位能沿纬圈的平均值</code> $[A]$ 可以分解为<code>基本气流的有效位能</code>也称平均有效位能 $A_m$ 与 <code>空气扰动的有效位能</code>也称扰动有效位能 $ A_p$ 。</p><blockquote><p>学术研究中似乎并不是将<code>有效位能纬圈的平均值</code> 进行分解，而是分解<code>有效位能</code>。如果公式 (85) 到 (86) 不进行纬圈平均。那么<code>有效位能</code> 同样可以分解为 <code>平均有效位能</code> 和 <code>扰动有效位能</code>，但会多出一项 $[T’]T’^*$ 。所以学术研究中一般是将这一项忽略掉？</p></blockquote><h2 id="纬向平均与扰动有效位能倾向">纬向平均与扰动有效位能倾向</h2><p>将公式 (80)-(85) 代入公式 (63)</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial t} } + ([u] + {u^* })\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial x} } + ([v] + {v^* })\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial y} } +… \\<br>…+ ([\omega ] + {\omega ^* })\frac{ {\partial (\frac{ {[\theta ‘] + { {\theta ‘}^* } } }{ {\bar \theta } })} }{ {\partial p} } - ([\omega ] + {\omega ^* })\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’] + { {Q’}^* } } }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>利用连续方程将 $\frac{\partial}{\partial x}$ $\frac{\partial}{\partial y}$, $\frac{\partial}{\partial p}$ 项写为通量减散度的形式，利用连续方程消去散度项, 并对方程纬向平均</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial t} } + \frac{ {\partial ([v]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial y} } + \frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial p} } + \frac{ {\partial ([{\omega ^* }\frac{ { { {\theta ‘}^* } } }{ {\bar \theta } }])} }{ {\partial p} } - [\omega ]\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’]} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>方程两边同乘 $\frac{\bar T}{\gamma_d-\gamma} \frac{[\theta’]}{\bar \theta}$ 。</p><p>$$<br>\begin{align}<br>\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial (\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial t} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([v]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial y} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([\omega ]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial p} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{\omega ^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial p} } + …\\<br>… - \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ {\bar \theta } }[\omega ]\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’]} }{ { {c_p}\bar T} }\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }<br>\end{align}<br>$$</p><p>整理且代入公式 (54) $\frac{ {\theta ‘} }{ {\bar \theta } } = \frac{ {T’} }{ {\bar T} }$</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial t} } + \frac{ {\partial ([v]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial y} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial p} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ {\bar \theta } }\frac{ {\partial ([{\omega ^* }\frac{ { { {\theta ‘}^* } } }{ {\bar \theta } }])} }{ {\partial p} } + …\\<br>… - [T’][\omega ]\frac{R}{ {pg} } = \frac{ {(\bar Q + [Q’])[\theta ']} }{ { {c_p}\bar \theta} }\frac{1}{ { {\gamma _d} - \gamma } }<br>\end{align}<br>$$</p><p>将上式第三项和第五项写为通量减散度的形式, 且代入公式 (54) $\frac{ {\theta ‘} }{ {\bar \theta } } = \frac{ {T’} }{ {\bar T} }$</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial t} } + \frac{ {\partial ([v]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial y} } + \frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } }[{v^* }{ {\theta '}^* }])} }{ {\partial y} } - [{v^* }{ {\theta '}^* }]\frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } })} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial p} } + \frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } }[{\omega ^* }{ {\theta ‘}^* }])} }{ {\partial p} } - [{\omega ^* }{ {\theta ‘}^* }]\frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ { { {\bar \theta }^2} } })} }{ {\partial p} } + …\\<br>… - [T’][\omega ]\frac{R}{ {pg} } = \frac{ {(\bar Q + [Q’])[T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \gamma } }<br>\end{align}<br>$$</p><p>$\int_0^{ps}{dp}$ 垂直积分且水平积分(平均)得</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp - \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp = \int_0^{ps} {\overline {\frac{ {[Q’][T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \bar \gamma } } } } dp\\<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } = \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp + \int_0^{ps} {\overline {\frac{ {[Q’][T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \bar \gamma } } } } dp<br>\end{align}<br>$$</p><blockquote><p>上式的 $[T’][\omega]$ 在Lorenz的文章中写为 $[T][\omega]$。也不知道是哪里出了问题，还是用了什么近似。</p></blockquote><p>将公式 (80)-(85) 代入公式 (70) （不做水平积分)</p><p>$$<br>\begin{align}<br>\frac{ {\partial A} }{ {\partial t} } = \int_0^{ps} {\frac{R}{ {gp} } } ([T] + {T^* })([\omega ] + {\omega ^* })dp + …\\<br>… + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’] + { {Q’}^* })([T’] + { {T’}^* })}dp<br>\end{align}<br>$$</p><p>纬向平均结合公式 (89) 得</p><p>$$<br>\begin{align}<br>\frac{ {\partial [A]} }{ {\partial t} } &amp;= \int_0^{ps} {\frac{R}{ {gp} } } ([T][\omega ] + [{T^* }{\omega ^* }])dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’][T’] + [{ {Q’}^* }{ {T’}^* }])} dp\\<br>\frac{ {\partial {A_m} } }{ {\partial t} } + \frac{ {\partial {A_p} } }{ {\partial t} } &amp;= \int_0^{ps} {\frac{R}{ {gp} } } ([T][\omega ] + [{T^* }{\omega ^* }])dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’][T’] + [{ {Q’}^* }{ {T’}^* }])} dp<br>\end{align}<br>$$</p><p>用公式 (108) 减公式 (104) (公式104做了全球平均，即使不做全球平均，相减后再平均也能消去通量项)</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_p} } }{ {\partial t} } =  - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \overline \gamma  ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \overline \gamma  ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[{ {Q’}^* }{ {T’}^* }]} } dp<br>\end{align}<br>$$</p><h2 id="有效位能小节">有效位能小节</h2><ul><li>有效位能表达式（同公式55）</li></ul><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {T’} }{ {\bar T} })}^2} } dp}<br>\end{align}<br>$$</p><ul><li>有效位能时间倾向（同公式70-72）</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial \bar A} }{ {\partial t} } &amp;= \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= \int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><ul><li>纬向平均有效位能和扰动有效位能（同公式88）</li></ul><p>$$<br>\begin{align}<br>{ { A}_m} = \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {(\frac{ {[T’]} }{ {\bar T} })}^2} } dp\\<br>{ { A}_p} = \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }[{ {(\frac{ { { {T’}^* } } }{ {\bar T} })}^2}]} dp<br>\end{align}<br>$$</p><ul><li>纬向平均有效位能和扰动有效位能时间倾向 （同公式104、109）</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } = \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[Q’][T’]} } dp\\<br>\frac{ {\partial { {\bar A}_p} } }{ {\partial t} } =  - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[{ {Q’}^* }{ {T’}^* }]} } dp<br>\end{align}<br>$$</p><blockquote><p>上式与大气动力学P469等价</p></blockquote><hr><h1>动能的定义</h1><p>在某个气压层上单位质量空气的动能是</p><p>$$<br>\begin{align}<br>K = \frac{1}{2}({u^2} + {v^2}) = \frac{1}{2}{\vec V^2}<br>\end{align}<br>$$</p><p>对于单位面积上整层大气的动能为</p><p>$$<br>\begin{align}<br>K &amp;= \int_0^{ + \infty } {\frac{1}{2}\rho { {\vec V}^2} } dz\\<br>&amp;= \int_{ps}^0 {\frac{1}{2}\rho { {\vec V}^2} } ( - \frac{1}{ {\rho g} })dp\\<br>&amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {\vec V}^2} } dp<br>\end{align}<br>$$</p><p>对于全球积分(平均)的动能为 $\bar K= \frac{1}{2}{g^{ - 1} }\int_0^{ps} \overline { { {\vec V}^2} } dp$</p><h2 id="动能时间倾向">动能时间倾向</h2><p>对于二维动量方程</p><p>$$<br>\begin{align}<br>\frac{ {d\vec V} }{ {dt} } + \omega \frac{ {\partial \vec V} }{ {\partial p} } =  - f\vec k \times \vec V - \nabla \Phi  + \vec F<br>\end{align}<br>$$</p><p>其中 $\frac{d}{dt}=\frac{\partial}{\partial t}+u\frac{\partial}{\partial x}+v\frac{\partial}{\partial y}$ ，$f$ 是科氏参数，$\vec F$ 是水平摩擦力，$\phi$ 是位势</p><p>对公式 (125) 两边同乘 $\frac{1}{g}\vec V$ , 结合连续方程有</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{1}{g}\vec V\frac{ {d\vec V} }{ {dt} } + \frac{1}{g}\vec V\omega \frac{ {\partial \vec V} }{ {\partial p} } = \frac{1}{g}\vec V \cdot ( - f\vec k \times \vec V) - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{1}{g}\vec V\frac{ {\partial \vec V} }{ {\partial t} } + \frac{1}{g}\vec Vu\frac{ {\partial \vec V} }{ {\partial x} } + \frac{1}{g}\vec Vv\frac{ {\partial \vec V} }{ {\partial y} } + \frac{1}{g}\vec V\omega \frac{ {\partial \vec V} }{ {\partial p} } &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + u\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial x} } + v\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial y} } + \omega \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial p} } &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } - \frac{1}{ {2g} }{ {\vec V}^2}(\frac{ {\partial u} }{ {\partial x} } + \frac{ {\partial v} }{ {\partial y} } + \frac{ {\partial \omega } }{ {\partial p} }) &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } &amp;=  - \frac{1}{g}\nabla (\vec V\Phi ) + \frac{1}{g}\Phi \nabla  \cdot \vec V + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } &amp;=  - \frac{1}{g}\nabla (\vec V\Phi ) - \frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } + \frac{1}{g}\vec V \cdot \vec F<br>\end{align}<br>$$</p><p>对公式 (131)做全球积分</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \int_0^{ps} {\frac{1}{g}\nabla (\vec V\Phi )} dp - \int_0^{ps} {\frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \int_0^{ps} {\frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \frac{1}{g}\int_0^{ps} {\frac{ {\partial \omega \Phi } }{ {\partial p} }dp + \frac{1}{g}\int_0^{ps} {\omega \frac{ {\partial \Phi } }{ {\partial p} } } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;= \frac{1}{g}\int_0^{ps} {\omega \frac{1}{ { - \rho } } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><blockquote><p>在公式 (69) 中将 $T’$ 换为了 $T$ 。如果不换的话就不能与动能倾向公式 (136) 相对应，有点难理解。公式 (69) 的推导过程可能还存在一些问题</p></blockquote><p>即动能时间倾向为 (类比公式 (70)-(79))</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><h2 id="纬向平均与扰动动能定义">纬向平均与扰动动能定义</h2><p>将公式 (80) 和 (81) 代入公式 (124)，并纬向平均</p><p>$$<br>\begin{align}<br>K &amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} + 2[\vec V] \cdot { {\vec V}^* } + { {\vec V}^* }^2} dp\\<br>(纬向平均)[K] &amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} } dp + \frac{1}{2}{g^{ - 1} }\int_0^{ps} {[{ {\vec V}^* }^2]} dp\\<br>&amp;= {K_m} + {K_p}<br>\end{align}<br>$$</p><p>即<code>动能沿纬圈的平均值</code> $[K]$ 可以分解为<code>基本气流的动能</code>也称平均动能 $K_m$ 与 <code>空气扰动的动能</code>也称扰动动能  $K_p$ 。其中</p><p>$[\vec V]^2=[u]^2+[v]^2 $，$[\vec V^* ]^2=[{u^{* } }^2+{v^* }^2]$</p><h2 id="纬向平均与扰动动能倾向">纬向平均与扰动动能倾向</h2><p>将公式 (125) 写为通量减散度的形式，并代入连续方程化简</p><p>$$<br>\begin{align}<br>\frac{ {\partial \vec V} }{ {\partial t} } + \frac{ {\partial \vec Vu} }{ {\partial x} } + \frac{ {\partial \vec Vv} }{ {\partial y} } + \frac{ {\partial \vec V\omega } }{ {\partial p} } - \vec V \cdot (\frac{ {\partial u} }{ {\partial x} } + \frac{ {\partial v} }{ {\partial y} } + \frac{ {\partial \omega } }{ {\partial p} }) =  - f\vec k \times \vec V - \nabla \Phi  + \vec F\\<br>\frac{ {\partial \vec V} }{ {\partial t} } + \frac{ {\partial \vec Vu} }{ {\partial x} } + \frac{ {\partial \vec Vv} }{ {\partial y} } + \frac{ {\partial \vec V\omega } }{ {\partial p} } =  - f\vec k \times \vec V - \nabla \Phi  + \vec F<br>\end{align}<br>$$</p><p>将公式 (80)-(82) 以及 $\Phi=[\Phi]+\Phi^* $，$\vec F=[\vec F]+\vec F^* $  代入公式 (144)</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial [\vec V] + { {\vec V}^* } } }{ {\partial t} } + \frac{ {\partial ([\vec V] + { {\vec V}^* })([u] + {u^* })} }{ {\partial x} } + \frac{ {\partial ([\vec V] + { {\vec V}^* })([v] + {v^* })} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\vec V] + { {\vec V}^* })([\omega ] + {\omega ^* })} }{ {\partial p} } =  - f\vec k \times ([\vec V] + { {\vec V}^* }) - \nabla ([\Phi ] + {\Phi ^* }) + [\vec F] + { {\vec F}^* }<br>\end{align}<br>$$</p><p>纬向平均得</p><p>$$<br>\begin{align}<br>\frac{ {\partial [\vec V]} }{ {\partial t} } + \frac{ {\partial [\vec V][v]} }{ {\partial y} } + \frac{ {\partial [\vec V][\omega ]} }{ {\partial p} } + …\\<br>… + \frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } =  - f\vec k \times [\vec V] - \nabla [\Phi ] + [\vec F]<br>\end{align}<br>$$</p><p>方程两边同乘 $\frac{1}{g}[\vec V]$</p><p>$$<br>\begin{align}<br>\frac{1}{g}[\vec V]\frac{ {\partial [\vec V]} }{ {\partial t} } +  + \frac{1}{g}[\vec V]\frac{ {\partial [\vec V][v]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [\vec V][\omega ]} }{ {\partial p} } + …\\<br>… + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } = \frac{1}{g}[\vec V]( - f\vec k \times [\vec V]) + …\\<br>… - \frac{1}{g}[\vec V] \cdot \nabla [\Phi ] + \frac{1}{g}[\vec V][\vec F]\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2}[v]} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2}[\omega ]} }{ {\partial p} } + …\\<br>… + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } =  - \frac{1}{g}[\vec V] \cdot \nabla [\Phi ] + \frac{1}{g}[\vec V][\vec F]<br>\end{align}<br>$$</p><p>公式 (152) 中 $[\vec V]$ 放进了 $\frac{\partial}{\partial x}$，$\frac{\partial}{\partial y}$ 内部。结合连续方程，这步是正确的。</p><p>对公式 (152)-(153) 全球积分</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K_m} }{ {\partial t} } + \int_0^{ps} {\overline {\frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } } } dp =  - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial \bar K_m} }{ {\partial t} } - \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp =  - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial \bar K_m} }{ {\partial t} } = \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp<br>\end{align}<br>$$</p><blockquote><p>公式 (154) 的平流部分写成了通量减散度形式，结合连续方程得到公式 (155)</p></blockquote><p>公式 (156) 右边第三项参考 公式 (132)-(136) 过程进行化简，得到纬向平均动能时间倾向方程</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } = {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[\omega ][\alpha ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>= {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp<br>\end{align}<br>$$</p><p>对于公式 (138) 做水平平均之前，用 $T=[T]+T^* $，$\vec F=[\vec F]+\vec F^* $ ，$\vec V=[\vec V]+\vec V^* $，$\omega=[\omega]+\omega^* $ 代入 (之后再水平平均仍能消去通量项), 结合公式 (142)</p><p>$$<br>\begin{align}<br>\frac{ {\partial K} }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T] + {T^* })([\omega ] + {\omega ^* })} dp + {g^{ - 1} }\int_0^{ps} {([\vec V] + { {\vec V}^* })([\vec F] + { {\vec F}^* })} dp\\(纬向平均)<br>\frac{ {\partial [K]} }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T][\omega ] + [{T^* }{\omega ^* }])} dp + {g^{ - 1} }\int_0^{ps} {([\vec V][\vec F] + [{ {\vec V}^* }{ {\vec F}^* }])} dp\\<br>\frac{ {\partial {K_m} } }{ {\partial t} } + \frac{ {\partial {K_p} } }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T][\omega ] + [{T^* }{\omega ^* }])} dp + {g^{ - 1} }\int_0^{ps} {([\vec V][\vec F] + [{ {\vec V}^* }{ {\vec F}^* }])} dp\\(水平平均)<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } + \frac{ {\partial { {\bar K}_p} } }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }(\overline {[T][\omega ]}  + \overline {[{T^* }{\omega ^* }]} )} dp + {g^{ - 1} }\int_0^{ps} {(\overline {[\vec V][\vec F]}  + \overline {[{ {\vec V}^* }{ {\vec F}^* }]} )} dp<br>\end{align}<br>$$</p><p>用公式 (162) 减公式 (156)得扰动动能时间倾向方程</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_p} } }{ {\partial t} } =  - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{ {\vec F}^* }]} } dp<br>\end{align}<br>$$</p><h2 id="动能小节">动能小节</h2><ul><li>动能表达式 (同公式124)</li></ul><p>$$<br>\begin{align}<br>\bar K = \frac{1}{2}{g^{ - 1} }\int_0^{ps} \overline { { {\vec V}^2} } dp<br>\end{align}<br>$$</p><ul><li>有效位能时间倾向 (同公式137-139)</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><ul><li>纬向平均动能和扰动动能 (同公式141-142)</li></ul><p>$$<br>\begin{align}<br>{K_m} = \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} } dp\\<br>{K_p} = \frac{1}{2}{g^{ - 1} }\int_0^{ps} {[{ {\vec V}^* }^2]} dp<br>\end{align}<br>$$</p><ul><li>纬向平均动能和扰动动能时间倾向 (公式158、163)</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } &amp;= {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial { {\bar K}_p} } }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{ {\vec F}^* }]} } dp<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 大气数学理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大气理论 </tag>
            
            <tag> 数学推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cartopy 调用&quot;天地图&quot;底图</title>
      <link href="/2023/03/16/cartopyAPI/"/>
      <url>/2023/03/16/cartopyAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-5">前言</h2><p>科研绘图上地图底图一般是白色的，加上海岸线也就成底图。这种做法的好处是如果我们需要向底图上添加等值线、填色图等附有彩色信息的图案或线条，这种信息在白底下更突出。作为可以绘图，这种白底也最简单、严肃。</p><p>但是如果我们要画出某个台风的移动路径，偌大的白图上就横躺这几根线条略显单调。这时如果能丰富底图，整张图的效果会有很大提升。</p><p>使用这种底图需要调用其他网站的地图接口，让图像叠加在<code>Cartopy</code>的坐标轴内。</p><h2 id="Cartopy无网络底图">Cartopy无网络底图</h2><p><code>Cartopy</code>内置了一种底图 <code>ax.stock_img()</code>，不需要利用网络接口。缺点就是分辨率很差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.gridliner <span class="keyword">import</span> LONGITUDE_FORMATTER, LATITUDE_FORMATTER</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lon = np.array([<span class="number">126.4</span>, <span class="number">126.1</span>, <span class="number">125.9</span>, <span class="number">125.6</span>, <span class="number">125.2</span>, <span class="number">124.8</span>, <span class="number">124.5</span>, <span class="number">124.1</span>, <span class="number">123.7</span>,</span><br><span class="line">       <span class="number">123.4</span>, <span class="number">123.3</span>, <span class="number">123.5</span>, <span class="number">123.5</span>, <span class="number">123.5</span>, <span class="number">123.4</span>, <span class="number">123.</span> , <span class="number">122.6</span>, <span class="number">122.1</span>,</span><br><span class="line">       <span class="number">121.5</span>, <span class="number">121.2</span>, <span class="number">120.6</span>, <span class="number">119.8</span>, <span class="number">119.8</span>, <span class="number">120.1</span>, <span class="number">120.5</span>, <span class="number">120.8</span>, <span class="number">121.3</span>,</span><br><span class="line">       <span class="number">122.6</span>, <span class="number">123.7</span>, <span class="number">125.5</span>, <span class="number">126.3</span>, <span class="number">127.6</span>, <span class="number">130.1</span>, <span class="number">131.3</span>, <span class="number">132.3</span>, <span class="number">133.3</span>,</span><br><span class="line">       <span class="number">134.6</span>, <span class="number">136.2</span>, <span class="number">137.6</span>, <span class="number">139.4</span>])</span><br><span class="line"></span><br><span class="line">lat = np.array([<span class="number">20.1</span>, <span class="number">20.2</span>, <span class="number">20.1</span>, <span class="number">19.8</span>, <span class="number">19.3</span>, <span class="number">18.7</span>, <span class="number">18.5</span>, <span class="number">18.3</span>, <span class="number">18.1</span>, <span class="number">18.</span> , <span class="number">18.1</span>,</span><br><span class="line">       <span class="number">18.6</span>, <span class="number">19.3</span>, <span class="number">20.3</span>, <span class="number">21.2</span>, <span class="number">22.4</span>, <span class="number">23.2</span>, <span class="number">24.1</span>, <span class="number">24.7</span>, <span class="number">25.2</span>, <span class="number">26.1</span>, <span class="number">26.8</span>,</span><br><span class="line">       <span class="number">27.3</span>, <span class="number">28.1</span>, <span class="number">29.4</span>, <span class="number">31.4</span>, <span class="number">33.</span> , <span class="number">33.8</span>, <span class="number">35.2</span>, <span class="number">37.6</span>, <span class="number">38.4</span>, <span class="number">39.1</span>, <span class="number">40.1</span>,</span><br><span class="line">       <span class="number">41.</span> , <span class="number">42.</span> , <span class="number">42.7</span>, <span class="number">43.3</span>, <span class="number">44.1</span>, <span class="number">44.6</span>, <span class="number">45.</span> ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#%% 定义绘图函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMap</span>(<span class="params">proj=ccrs.PlateCarree(<span class="params"></span>), extent=[<span class="number">100</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">60</span>]</span>):</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">    proj = ccrs.PlateCarree()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>, projection=proj)</span><br><span class="line">    ax.set_extent(extent, crs=ccrs.PlateCarree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加刻度</span></span><br><span class="line">    lon_lat = ax.gridlines(draw_labels=<span class="literal">True</span>, linewidth=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.2</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">    lon_lat.xlabels_top = <span class="literal">False</span></span><br><span class="line">    lon_lat.ylabels_right = <span class="literal">False</span> </span><br><span class="line">    lon_lat.xformatter = LONGITUDE_FORMATTER </span><br><span class="line">    lon_lat.yformatter = LATITUDE_FORMATTER</span><br><span class="line">    <span class="keyword">return</span> fig, ax </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig1, ax1 = getMap()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加底图</span></span><br><span class="line">ax1.stock_img()</span><br><span class="line">ax1.plot(lon, lat, <span class="string">&#x27;.-r&#x27;</span>,transform=ccrs.PlateCarree())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Aoad.png" title="" alt="" data-align="center"><h2 id="Cartopy-连接国外API">Cartopy 连接国外API</h2><p>暂时连不上，以后再码</p><p><a href="https://scitools.org.uk/cartopy/docs/latest/gallery/web_services/index.html">Web services — cartopy 0.21.0 documentation</a></p><h2 id="Cartopy-理解国内”天地图“网站API">Cartopy 理解国内”天地图“网站API</h2><h3 id="第一步：修改Cartopy文件">第一步：修改Cartopy文件</h3><p>安装好Cartopy后，修改以下文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda3\envs\你的虚拟环境名称\Lib\site-packages\cartopy\io\img_tiles.py</span><br></pre></td></tr></table></figure><p>如果用的是base环境，路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda3\Lib\site-packages\cartopy\io\img_tiles.py</span><br></pre></td></tr></table></figure><p>在<code>imh_tiles.py</code>文件末尾添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 天地图矢量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_vec</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=vec_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 天地图遥感</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_img</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=img_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 天地图地形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_ter</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=ter_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><h3 id="第二部：申请“天地图”密钥">第二部：申请“天地图”密钥</h3><p>在网站 <a href="http://lbs.tianditu.gov.cn/server/MapService.html">天地图API</a> 注册登陆账号。申请密钥：</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2Avqg.png" alt="" data-align="center" width="358"><p>点击“创建新应用”，内容随便填写</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EFzV.png" alt="" data-align="center" width="440"><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EEsU.png" alt="" data-align="center" width="337"><p>然后就得到密钥了：</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EeZ4.png" alt="" data-align="center" width="477"><p>如果不想申请密钥，可以用我以前的密钥，就是<code>imh_tiles.py</code>中已经填好的，key = ‘f51d7378813e172b83c8edc7ddedb1c9’。但是这个申请的不知道什么时候可能会失效。</p><blockquote><p>个人申请的密钥一天调用上限是1万次。如果程序运行遇到网络问题、被禁止访问时，程序会不停地调用这个接口，很容易超过1万次。所以遇到报错要及时手动停止程序。</p></blockquote><h3 id="第三步：程序使用，绘图程序">第三步：程序使用，绘图程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cartopy.io.img_tiles <span class="keyword">as</span> cimgt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMap</span>(<span class="params">nrows=<span class="number">1</span>, ncols=<span class="number">1</span>, proj=ccrs.PlateCarree(<span class="params"></span>), extent=[<span class="number">100</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">60</span>]</span>):</span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(nrows, ncols, subplot_kw=<span class="built_in">dict</span>(projection=proj),figsize=(<span class="number">36</span>,<span class="number">12</span>))</span><br><span class="line">    <span class="keyword">for</span> axx <span class="keyword">in</span> ax:</span><br><span class="line">        axx.set_extent(extent, crs=ccrs.PlateCarree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加刻度</span></span><br><span class="line">        lon_lat = axx.gridlines(draw_labels=<span class="literal">True</span>, linewidth=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.2</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">        lon_lat.xlabels_top = <span class="literal">False</span></span><br><span class="line">        lon_lat.ylabels_right = <span class="literal">False</span> </span><br><span class="line">        lon_lat.xformatter = LONGITUDE_FORMATTER </span><br><span class="line">        lon_lat.yformatter = LATITUDE_FORMATTER</span><br><span class="line">    <span class="keyword">return</span> fig, ax </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig3, ax3 = getMap(nrows=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用天地图</span></span><br><span class="line">a = cimgt.TDT_vec() <span class="comment"># 矢量图</span></span><br><span class="line">b = cimgt.TDT_img() <span class="comment"># 影像图</span></span><br><span class="line">c = cimgt.TDT_ter() <span class="comment"># 地形图</span></span><br><span class="line"></span><br><span class="line">ax3[<span class="number">0</span>].add_image(a, <span class="number">4</span>) <span class="comment"># 数字4表示第四图层。1-9数字越高清晰度越好，但程序花费时间越多</span></span><br><span class="line">ax3[<span class="number">1</span>].add_image(b, <span class="number">4</span>)</span><br><span class="line">ax3[<span class="number">2</span>].add_image(c, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    ax3[i].plot(lon, lat, <span class="string">&#x27;.-r&#x27;</span>,transform=ccrs.PlateCarree())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2EmdJ.png" title="" alt="" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cartopy调用地图底图AIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lanczos 滤波</title>
      <link href="/2023/02/10/Lanczos/"/>
      <url>/2023/02/10/Lanczos/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在使用上一篇讲述的傅里叶滤波作出一些结果后，王老师建议我换一下其他滤波方法试一下。我注意到文献中使用 Lanczos 和 Butterworth 滤波方法较多，所以打算研究一下这类滤波方法。</p><p>本文参考的文献有：</p><p>《Data Analysis Methods in Physical Oceanography, Third Edition》</p><p>《lanczos filtering in one and two dimensions》</p><p>《气候变率诊断和预测方法》</p><hr><h2 id="Lanczos-滤波">Lanczos 滤波</h2><p>Lanczos滤波的本质是对时间长度为 $N$ 的原时间序列 $x(n)$ 的各个点进行加权，形成新的序列 $y(n)$。即</p><p>$$<br>\begin{equation}<br>{y_n} = \sum\limits_{k =  - M}^M { {w_k} x_{n - k} } {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} ,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} n = 0,1,…,N - 1<br>\end{equation}<br>$$</p><p>其中 $w_{k}$ 即是权重。$M$ 表征权重点的个数 ($2M+1$个)，它是根据需要自己定义的， $M$ <code>越大滤波的效果越好，但损失的数据越多</code>。</p><ul><li><p><strong>为什么会损失数据？</strong></p><p>公式 (1) 中 $n$ 最大是N-1, 最小是0。然而 $x$ 的小标为 $n-k$ 。当 $n=0, k=M$ 时，$ x_{n-k}=x_{-M} $ , 然而 $x$ 的索引不可能取到负数。因此 $n=0$ 这个点无法通过公式计算出新序列。同样的 $n=0,1,…M-1$ 和 $n=N-M,…,N-1$ 都无法通过公式计算得到新序列值。新序列会比原序列在左端少 $M$ 个，在右端少 $M$ 个，共少 $2M$ 个。(类似于5点滑动平均，左端和右端会各少2个点)。</p><p>以上损失数据的情况在NCL的函数 <code>filwgts_lanczos</code> 体现出来。 然而，在我自己进行编程计算的时候发现，如果把原序列看做周期为其自身长度的周期信号，即 $x_{0} = x_{N}, x_{-1}=x_{N-1}$ （傅里叶变换中也用了相似的思想）。这样计算就不会产生数据损失，在序列两端的滤波结果仍具有很好的准确性 (将在下面的程序试验中验证)。</p></li></ul><p>如果 $M=4, w_{k}=\frac{1}{2M+1}=\frac{1}{9}$, 那么公式 (1) 变为</p><p>$$<br>\begin{equation}<br>{y_n} = \frac{1}{9}\sum\limits_{k = - 4}^4 { {x_{n - k} } }<br>\end{equation}<br>$$</p><p>这就是九点滑动平均公式，它是一种低通滤波，过滤掉周期小于9年的信号。在这里权重被设为常数 $\frac{1}{9}$ 。一旦权重 $w_{k}$ 被确定下来，那么这个滤波也就完成了。因此Lanczos滤波就是要找到一个合适权重系数，至少要比九点滑动平均的权重系数要好。</p><h3 id="高通-低通滤波">高通/低通滤波</h3><p>这个权重系数就是</p><ul><li><p>低通</p><p>$$<br>\begin{align}<br>&amp;{w_k} = \frac{ { {\omega _c} } } { { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{w_0} = \frac{ { {\omega _c} } }{ { {\omega _N} } }<br>\end{align}<br>$$</p></li><li><p>高通</p><p>$$<br>\begin{align}<br>&amp;{w_k} = -\frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{w_0} = 1-\frac{ { {\omega _c} } }{ { {\omega _N} } }<br>\end{align}<br>$$</p><p>其中 ${\omega_c}$ 是 cutoff 频率 (角频率)。${\omega_N}$ 是 Nyquist 频率 (角频率)。</p></li></ul><blockquote><p>例如原序列是逐日的气温数据，时间步长是1天。做低通滤波，保留周期大于10天 ($f=\frac{1}{10}$) 的信号，那么</p><p>(1) 采样频率$sample=\frac{1}{1 day}=1$</p><p>(2) $\omega_{N}=0.5*sample *2\pi=\pi$  (Nyquist频率是构成序列的波的最大频率。想象至少三个点才能确定一个完整的波形，而三个点包含两个时间步长。也就是说一个波形对应的最小周期就是2个时间步长，那么频率是周期的倒数，一个波形对应的最大频率就是 $\omega_{N}$)</p><p>(3) $\omega_{c}=f*2\pi=\frac{1}{10day}*2\pi=\frac{\pi}{5}$    (角频率等于频率乘2$\pi$)<br>再例如原序列是逐小时的气温数据，时间步长是 1小时=$\frac{1}{24}$天。做高通滤波，保留周期小于30天 ($f=\frac{1}{30}$) 信号，那么</p><p>(1) 采样频率$sample=\frac{1}{1/24 day}=24$</p><p>(2) $\omega_{N}=0.5*sample *2\pi=24\pi $</p><p>(3) $\omega_{c}=f*2\pi=\frac{1}{30day}*2\pi=\frac{\pi}{15}$</p></blockquote><h3 id="带通滤波">带通滤波</h3><p>带通滤波的权重公式为</p><p>$$<br>\begin{align}<br>&amp;{w_k} = \frac{ { {\omega _2} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _2}/{\omega _N})} }{ {\pi k{\omega _2}/{\omega _N} } } - \frac{ { {\omega _1} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _1}/{\omega _N})} }{ {\pi k{\omega _1}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{\omega _2} &gt; {\omega _1}\\<br>&amp;{w_0}=\frac{\omega _2 - \omega _1}{\omega _y}<br>\end{align}<br>$$</p><p>其中 $\omega_{0}$ 是通过 $k→0$ 取极限得到。使用带通滤波将保留角频率在 [$\omega_{1}, \omega_{2}$] 之间的信号。</p><h3 id="响应函数">响应函数</h3><p>既然有了 $w_{k}$ 那么我们就可以通过公式 (1) 进行计算，得到滤波结果。那么为什么乘了这样的权重系数能达滤波的作用呢？</p><p>首先我们可以看一下滤波结果 $y_{n}$ 究竟是不是保留了我们想要的频率的信号。怎么看呢？就是用傅里叶变换把时域信号转换到频域上。即</p><p>$$<br>\begin{align}<br>Y(\omega ) = \sum\limits_{n =  - M}^M { {y_n}{e^{ - i\omega n\Delta t} } }<br>\end{align}<br>$$</p><p>该公式同 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中的公式 (14)。将公式 (1) 代入公式 (10)，得</p><p>$$<br>\begin{align}<br>Y(\omega ) &amp;= \sum\limits_{n =  - M}^M { {y_n}{e^{ - i\omega n\Delta t} } } \\<br>&amp;= \sum\limits_{k =  - M}^M { {w_k}{e^{ - i\omega k\Delta t} } } \sum\limits_{n =  - M}^M { {x_{n - k} }{e^{ - i\omega (n - k)\Delta t} } } \\<br>&amp;= W(\omega )X(\omega )<br>\end{align}<br>$$</p><p>可见 $y_{n}$ 的傅里叶变换等于 $w_{k}$ 和 $x_{n}$ 的傅里叶变换的乘积。也就是说<code>新信号的频谱等于原信号的频谱乘权重系数的频谱。</code> 如果 $W(\omega)$ 在 [$\omega_{1}, \omega_{2}$] 上等于0，在 [$\omega_{3}, \omega_{4}$] 等于1，那么与 $X(\omega)$ 相乘就会导致频谱在 [$\omega_{1}, \omega_{2}$] 上等于0，在 [$\omega_{3}, \omega_{4}$] 上保持不变。这就相当于 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中所做的滤波一样，这不过在这里使用特定的函数，而 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中人为手动地通过赋值改变频谱。</p><p>事实上公式 (3)(5)(7) 的频谱 $W(\omega)$ 就是能取得这种效果, 它也被称为响应函数。为了克服滤波前后造成的相位偏移，通常认为 $W(\omega)$ 是偶函数，即 $W(\omega)=W(-\omega)$ 。因此 $W(\omega)$ 的计算公式也写为()</p><p>$$<br>\begin{align}<br>W(\omega ) = {w_0} + 2\sum\limits_{k = 1}^M { {w_k}\cos (\pi k\omega /{\omega _N})}<br>\end{align}<br>$$</p><p><code>《Data Analysis Methods in Physical Oceanography, Third Edition》里的公式 (6.41) 少了系数2 ？</code>下面通过举例来看看这个响应函数的曲线。</p><p>以低通滤波为例，条件如下：</p><blockquote><p>原序列是逐小时的气温数据，时间步长是 1小时=$\frac{1}{24}$天。原信号由周期1,3,5,7天四个余弦波叠加，数据长度为3000，也就是3000/24=125天。通过低通滤波得到周期大于6天的信号(也就是得到周期7天的波)。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组长度</span></span><br><span class="line">N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">sample = <span class="number">24</span> </span><br><span class="line">omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line">M = <span class="number">240</span> </span><br><span class="line">k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通权重公式</span></span><br><span class="line">wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">w0 = omega_c/omega_ny</span><br><span class="line">wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">term = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">    term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">Wk = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(fft_x, Wk)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vy1x.png" title="" alt="" data-align="center"><p>这就是低通滤波响应函数的图像。可以看到在高频部分 (f&gt;1/7), $W_{k}=0$ 这样通过公式 (13) 将导致新序列在高频部分的频率为0，经过傅里叶逆变换之后，新序列的高频信号就被滤掉了，而只保留了低频部分 (因为 f&lt;1/7的部分 $W_{k}=1$)。</p><p>可以看到 $W_k$ 由1到0的转变很迅速，几乎是垂直的，这就意味着这种响应函数滤波滤得很干净。<code>这与 M 的选取有关，M 越大滤波效果越好，但会造成更多的数据损失。</code> 下面代码展现 M 的选取对响应函数的影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getWk</span>(<span class="params">M</span>):</span><br><span class="line">    N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">    sample = <span class="number">24</span> </span><br><span class="line">    omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">    omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line"></span><br><span class="line">    k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 低通权重公式</span></span><br><span class="line">    wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">    w0 = omega_c/omega_ny</span><br><span class="line">    wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">    fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    Wk = w0 + <span class="number">2</span>*term</span><br><span class="line">    <span class="keyword">return</span> Wk</span><br><span class="line"></span><br><span class="line">Wlist = []</span><br><span class="line">label = []</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> [<span class="number">20</span>,<span class="number">80</span>,<span class="number">120</span>,<span class="number">240</span>]:</span><br><span class="line">    Wlist.append(getWk(M))</span><br><span class="line">    label.append(<span class="built_in">str</span>(M))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Wlist)):</span><br><span class="line">    ax.plot(fft_x, Wlist[i], label=label[i])</span><br><span class="line">ax.set_xlim([-<span class="number">1</span>,<span class="number">1</span>]) <span class="comment"># x 轴范围缩小到 [-1, 1]</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Frequency f&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Amplitude $W_&#123;k&#125;$&#x27;</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2VcjK.png" title="" alt="" data-align="center"><p>图中为 M=20,80,120,240 的情况下 $W_k$ 的曲线，是对 $f=[-1,1]$ 的局部放大。很明显 M 越大， $W_k$ 的最大值维持在1， 最小值维持在0，且0,1之间的转变迅速 (斜率大)。<code>因此在对不同数据进行滤波时，应该选取合适的 M， 看一下</code> $W_k$ <code>是否合理。从滤波效果来说，M 越大越好</code></p><p> </p><p>那么具体的滤波手段有两种，一种是通过公式 (1) 原信号直接乘权重系数。另一种是通过公式 (13) ，原信号先转为频域，乘响应函数，最后傅里叶逆变换转为时域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组长度</span></span><br><span class="line">N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">sample = <span class="number">24</span> </span><br><span class="line">omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line">M = <span class="number">240</span> </span><br><span class="line">k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通权重公式</span></span><br><span class="line">wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">w0 = omega_c/omega_ny</span><br><span class="line">wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">term = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">    term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">Wk = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">y2 = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        y2[t] = y2[t] + wk[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(fft_x, Wk)</span><br><span class="line"></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * Wk</span><br><span class="line">y = ifft(Y)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax[<span class="number">0</span>].plot(n, y, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n,  np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;7&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n,  y2, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2V2nO.png" title="" alt="" data-align="center"><p>蓝线是频谱相乘再傅里叶变换的结果，橙线是周期为7天的波，绿线是直接乘权重系数的结果。可以看出三根线都较为接近，说明滤波起到了很好的效果。<code>此外，蓝线并没有损失数据，而绿线损失了数据。</code> 因此可以通过傅里叶变换的方法避免数据的损失，从图中可以看出这种方法保留下的两端的数据仍具有较好的准确性。图中绿线在两端各损失了 $M=240$ 个点，共480个点。<code>从图中看出蓝线和绿线的最大值都小于1，也就是说滤波后振幅减弱了，这主要是因为 M 的值不够大。</code></p><h3 id="Lanczos-Window">Lanczos Window</h3><p>以上的滤波操作还不能被称为 Lanczos 滤波。Lanczos滤波需要对以上的权重函数再乘一个因子 $\sigma$ 。其公式为</p><p>$$<br>\begin{align}<br>\sigma (M,k) = \frac{ {\sin (\pi k/M)} }{ {\pi k/M} }<br>\end{align}<br>$$</p><p>于是公式 (3)(5)(7) 变成</p><p>$$<br>\begin{align}<br>&amp;低通{w_k} = \frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } }\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}\\<br>&amp;高通{w_k} = -\frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } }\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}\\<br>&amp;带通{w_k} = (\frac{ { {\omega _2} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _2}/{\omega _N})} }{ {\pi k{\omega _2}/{\omega _N} } } - \frac{ { {\omega _1} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _1}/{\omega _N})} }{ {\pi k{\omega _1}/{\omega _N} } })\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}<br>\end{align}<br>$$</p><p>$\sigma$ 因子的作用是加快响应函数从在0,1之间的转变，并且减弱 Gibbs 现象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getWk</span>(<span class="params">M</span>):</span><br><span class="line">    N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">    sample = <span class="number">24</span> </span><br><span class="line">    omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">    omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line"></span><br><span class="line">    k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 低通权重公式</span></span><br><span class="line">    wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">    w0 = omega_c/omega_ny</span><br><span class="line">    wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">    fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line">    sigma = np.sin(np.pi * k_plus / M) / (np.pi * k_plus / M)</span><br><span class="line"></span><br><span class="line">    wk_plus = wk_plus * sigma</span><br><span class="line">    <span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    Wk = w0 + <span class="number">2</span>*term</span><br><span class="line">    <span class="keyword">return</span> Wk</span><br><span class="line"></span><br><span class="line">Wlist = []</span><br><span class="line">label = []</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> [<span class="number">20</span>,<span class="number">80</span>,<span class="number">120</span>,<span class="number">240</span>]:</span><br><span class="line">    Wlist.append(getWk(M))</span><br><span class="line">    label.append(<span class="built_in">str</span>(M))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Wlist)):</span><br><span class="line">    ax.plot(fft_x, Wlist[i], label=label[i])</span><br><span class="line">ax.set_xlim([-<span class="number">1</span>,<span class="number">1</span>]) <span class="comment"># x 轴范围缩小到 [-1, 1]</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Frequency f&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Amplitude $W_&#123;k&#125;$&#x27;</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2VWHe.png" title="" alt="" data-align="center"><p>Gibbs 现象就是在0,1,转换出曲线强烈振荡的现象，与前天相比较。加入了 $\sigma$ 因子很好地减弱了 Gibbs 现象。</p><hr><h2 id="总结">总结</h2><p>下面把Lanczos代码做一下汇总总结</p><p>首先定义一个生成响应函数 $W(\omega)$ 和 权重系数 $w_k$ 的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lanczos</span>(<span class="params">N, sample, M, _f, _tp</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    N : int</span></span><br><span class="line"><span class="string">        数据长度.</span></span><br><span class="line"><span class="string">    sample : float</span></span><br><span class="line"><span class="string">        采样频率.</span></span><br><span class="line"><span class="string">    M : int</span></span><br><span class="line"><span class="string">        权重点数，总权重数为2M+1个.</span></span><br><span class="line"><span class="string">    _f : float or list</span></span><br><span class="line"><span class="string">        cutoff频率。低通和高通为一个数，带通为列表，长度为2，由小到大.</span></span><br><span class="line"><span class="string">    _tp : TYPE</span></span><br><span class="line"><span class="string">        滤波类型。 低通:&#x27;low&#x27; ; 高通: &#x27;high&#x27; ; 带通: &#x27;band&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    W : array</span></span><br><span class="line"><span class="string">        响应函数.</span></span><br><span class="line"><span class="string">    wk : array</span></span><br><span class="line"><span class="string">        权重系数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>   </span><br><span class="line">    <span class="comment"># cutoff频率</span></span><br><span class="line">    <span class="keyword">if</span> (_tp==<span class="string">&#x27;low&#x27;</span>)| (_tp==<span class="string">&#x27;high&#x27;</span>):</span><br><span class="line">        omega_c = _f * (<span class="number">2</span> * np.pi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;band&#x27;</span>:</span><br><span class="line">        omega1 = _f[<span class="number">0</span>] * <span class="number">2</span> * np.pi</span><br><span class="line">        omega2 = _f[<span class="number">1</span>] * <span class="number">2</span> * np.</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Nyquist频率</span></span><br><span class="line">    omega_ny = sample*<span class="number">0.5</span> * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line">    k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算权重系数</span></span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;low&#x27;</span>:</span><br><span class="line">        wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">        w0 = omega_c/omega_ny</span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;high&#x27;</span>:</span><br><span class="line">        wk = -omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">        w0 = <span class="number">1</span> - omega_c/omega_ny</span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;band&#x27;</span>:</span><br><span class="line">        wk = omega2/omega_ny * np.sin(np.pi * k * omega2 / omega_ny) / (np.pi * k * omega2/omega_ny) - \</span><br><span class="line">        omega1/omega_ny * np.sin(np.pi * k * omega1 / omega_ny) / (np.pi * k * omega1/omega_ny)</span><br><span class="line">        w0 = (omega2 - omega1)/omega_ny</span><br><span class="line"></span><br><span class="line">    wk[k==<span class="number">0</span>] = w0</span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>]</span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fft_x=fftfreq(N,T/N) </span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算sigma因子</span></span><br><span class="line">    sigma = np.sin(np.pi * k / M) / (np.pi * k / M)</span><br><span class="line">    sigma_plus = np.sin(np.pi * k_plus / M) / (np.pi * k_plus / M)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 系数乘sigma因子</span></span><br><span class="line">    wk = wk * sigma </span><br><span class="line">    wk_plus = wk_plus * sigma_plus</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算响应函数</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    W = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W, wk</span><br></pre></td></tr></table></figure><p>然后可以分别利用响应函数 $W(\omega)$ 和权重系数 $w_k$ 进行滤波</p><ul><li>低通 (高通)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft </span><br><span class="line"></span><br><span class="line">N = <span class="number">3000</span></span><br><span class="line">T = <span class="number">125</span></span><br><span class="line">M = <span class="number">800</span></span><br><span class="line">k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fft_x = fftfreq(N, T/N) </span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WL, wkL = lanczos(N=N, T=T, M=M, _f=<span class="number">1</span>/<span class="number">6</span>, _tp=<span class="string">&#x27;low&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用响应函数做傅里叶逆变换</span></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * WL</span><br><span class="line">yW = ifft(Y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">yw = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        yw[t] = yw[t] + wkL[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yW, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;7&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yw, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(omega, WL)</span><br><span class="line">ax[<span class="number">1</span>].set_xlim([-<span class="number">10</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2V54A.png" title="" alt="" data-align="center"><p>图2 是响应函数 $W(\omega)$ 的图像，对比图1 来看这样的响应函数能够很好地完成滤波。在以上代码中将 M 提高到了 800，如果 M=240 则 滤波效果并不很好。<code>所以在滤波之前一定要对比参考响应函数</code> $W(\omega)$</p><p>以上代码是低通滤波 (高通滤波同理)。此外还可以做带通滤波</p><ul><li>带通</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3000</span></span><br><span class="line">T = <span class="number">125</span></span><br><span class="line">M = <span class="number">800</span></span><br><span class="line">k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fft_x = fftfreq(N, T/N) </span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WL, wkL = lanczos(N=N, T=T, M=M, _f=[<span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">4</span>], _tp=<span class="string">&#x27;band&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用响应函数做傅里叶逆变换</span></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * WL</span><br><span class="line">yW = ifft(Y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">yw = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        yw[t] = yw[t] + wkL[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yW, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;5&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yw, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(omega, WL)</span><br><span class="line">ax[<span class="number">1</span>].set_xlim([-<span class="number">10</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vo9I.png" title="" alt="" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lanczos滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换与滤波</title>
      <link href="/2022/09/27/fourier/"/>
      <url>/2022/09/27/fourier/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-9">前言</h2><p>在读了王老师的那篇探讨行星波影响冬季风关系的文章后。我也想自己动手计算一下EP通量。论文的计算步骤里有一步是要将各变量进行傅里叶分解，保留1-3波。由于当时不了解傅里叶变换，这一步也就跳过去了。算出来的EP通量始终小了一个量级。我想也许就是因为没做滤波导致的？不管是不是这个原因，我还是决定学习一下傅里叶变换。目前没怎么翻书，看了两篇知乎文章，感觉大致就懂了。</p><p><a href="https://zhuanlan.zhihu.com/p/380004634"><font color=CornflowerBlue>傅里叶变换 (scipy.fft)</font></a></p><p><a href="https://www.zhihu.com/question/19714540/answer/1119070975"><font color=CornflowerBlue>如何理解傅里叶变换公式？</font></a></p><p><a href="https://www.zhihu.com/question/21314374/answer/542909849"><font color=CornflowerBlue>如何通俗地解释什么是离散傅里叶变换？</font></a></p><hr><h2 id="连续傅里叶变换">连续傅里叶变换</h2><p>傅里叶变换的基本思想就是</p><blockquote><p>任何连续信号(周期性或非周期性的)都可以由一组适当的正弦曲线组合而成</p></blockquote><p>假设时间为 $x$ ，每个时间点对应的信号振幅为 $y(x)$。傅里叶级数有如下公式：</p><p>$$<br>\begin{equation}<br>y(x) = \frac{ { {a_0} } } {2} + \sum\limits_{n = 1}^N { {a_n} } \cos (2\pi fnx) + {b_n}\sin (2\pi fnx)<br>\end{equation}<br>$$</p><p>这里规定了离散的频率 $2\pi fn$ 。因为这样的形式组成了一组正交基，满足以下等式</p><p>$$<br>\begin{equation}<br>\int_{ {\rm{ - } }\frac{T}{2} }^{\frac{T}{2} } {\cos (mx)\cos (nx)dx}  = 0 (m \ne n)<br>\end{equation}<br>$$</p><p>这里在-T/2,T/2之间积分是假定变换的对象 $y(x)$ 是周期函数，即在一个周期内积分为0(上式cos换成sin也成立)。而对于非周期函数，同样可以使用上式，因为非周期函数就是令 $T \to \infty $ 。</p><p>基于正交特性，便可以求出 $a_n$ 和 $b_n$</p><p>$$<br>\begin{align}<br>{a_n} = \frac{2}{T}\int_{ {x_0} }^{ {x_0} + T} {y(x)\cos (2\pi fnx)dx} \\<br>{b_n} = \frac{2}{T}\int_{ {x_0} }^{ {x_0} + T} {y(x)\sin (2\pi fnx)dx}<br>\end{align}<br>$$</p><p>$x_0$ 是任意值，因为我们只需要在一个周期 $T$ 内积分就可以。</p><hr><h2 id="离散傅里叶变换">离散傅里叶变换</h2><p>通常我们需要处理的信号并非严格周期更不是连续的，例如逐年气温序列。假设序列的长度是 $N$ ，我们只需要将积分符号换成求和符号，将 $T$ 换成 $N$，从 $n=0$ 求和到 $n=N$ 即可。我们利用欧拉公式 $ e^{ix} = \cos x + i\sin x $ 重写 $a_n, b_n$ 的表达式</p><p>$$<br>\begin{align}<br>y(x) &amp;= \frac{ { {a_0} } }{2} + \sum\limits_{n = 1}^N { {a_n}\cos (2\pi fnx) + {b_n}\sin (2fnx) } \\<br>&amp;= \sum\limits_{ - N}^N { {c_n} } \cdot (\cos (2\pi fnx) + i\sin (2\pi fnx)) \\<br>&amp;= \sum\limits_{ - N}^N { {c_n} } \cdot {e^{i2\pi fnx} }<br>\end{align}<br>$$</p><blockquote><p>这是复频域傅里叶级数，也是快速傅里叶变换计算的原理。通过复频域表示时，会出现虚数单位，而这个是我们在三角级数表现方式中不曾出现的，而最后负频域表示方式要能够化成和三角级数的相等的表达形式，所以必须想办法消掉虚数单位。所以我们就想到共轭复数 $e^{-ix}=cosx-isinx$ 。有了共轭复数，我们可以通过两个互为共轭的复数加法将虚数消掉。将频域$1-N$求和转化为复频域$-N—N$求和。</p></blockquote><p>$c_n$可用待定系数的方式求解，即设</p><p>$$<br>\begin{align}<br>{c_n} = \left \lbrace  \begin{array} {l}<br>p + iq{\kern 1pt} {\kern 1pt} {\kern 1pt} (n &gt; 0)\\<br>p - iq{\kern 1pt} {\kern 1pt} {\kern 1pt} (n &lt; 0)<br>\end{array} \right.<br>\end{align}<br>$$</p><p>可求得 $c_n$ 与 $a_n , b_n$ 的关系</p><p>$$<br>\begin{align}<br>{c_n} = \left \lbrace \begin{array} {l}<br>\frac{1}{2}({a_n} - i{b_n}){\kern 1pt} {\kern 1pt} {\kern 1pt} (n &gt; 0)\\<br>\frac{1}{2}{a_0}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (n = 0)\\<br>\frac{1}{2}({a_n} + i{b_n}){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (n &lt; 0)<br>\end{array} \right.<br>\end{align}<br>$$</p><p>将公式(3)(4)中的 $T$ 换为 $N$ (非周期函数假定周期无穷大，而信号的长度为 $N$ 。$x$ 换为 $n$ (第n个信号点)。$n$ 换为 $k$ ($N$ 个采样内振动 $k$ 个周期，相当于波数)。积分号换为求和号，则 $a_n , b_n$ 的离散形式为</p><p>$$<br>\begin{align}<br>{a_k} = \frac{2}{N}\sum\limits_{n = 0}^{N - 1} {y(n)\cos (\frac{ {2\pi k} }{N}n)} \\<br>{b_k} = \frac{2}{N}\sum\limits_{n = 0}^{N - 1} {y(n)\sin (\frac{ {2\pi k} }{N}n)}<br>\end{align}<br>$$</p><p>代入公式 (9) 得 $c_n$ 的离散形式</p><p>$$<br>\begin{align}<br>c(k) &amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} {y(n)} (\cos (\frac{ {2\pi k} }{N}n) - i\sin (\frac{ {2\pi k} }{N}n))\\<br>&amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} {y(n)}  \cdot {e^{ - i\frac{ {2\pi k} }{N}n} }<br>\end{align}<br>$$</p><p>这里<code>可能</code>只考虑 $n&gt;0$ 的情况，因为不存在 $y(-n)$ 的值。此外，在<code>Scipy.fft.fft</code> 中计算的 $c(k)$ 没有常数 $\frac{1}{N}$ 。而将 $\frac{1}{N}$ 移到傅里叶逆变换中。 <code>Scipy.fft.fft</code> 给出的计算公式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面没乘 1/n</span></span><br><span class="line">c[k] = np.<span class="built_in">sum</span>(x * np.exp(-<span class="number">2j</span> * np.pi * k * np.arange(n)/n))</span><br></pre></td></tr></table></figure><p> </p><ul><li><p><strong>如何理解 $k,N,f$ 的关系？</strong></p><p>$N$ 在公式中是信号采样点的个数，数据的长度。在假定周期无限大的情况下，<strong>整个数据的长度 $N$ 就是整个原信号周期 $T$</strong> 。在公式 (12)的 $cos(\frac{2\pi k}{N}n)$ 中每个 $k$ 代表一个波，而 $n$ 的作用是对这个波进行采样 (相当于x轴坐标)。公式 (13) 中每个波 $e^{ - i\frac{ {2\pi k} }{N}n}$ 与原信号进行内积(对应位置相乘并求和) 。由内积的特性，如果波与原数据越接近，则内积结果越大 (例如5x5&gt;4x6)。<strong>傅里叶变化公式 (13) 的另一种理解就是找到各个 $k$ 对应的波与原数据的内积，内积越大说明该波贡献也越大，$c_n$ 就越大</strong>。</p><p>我们说 $N$ 是原信号的周期，然而傅里叶变化找出的<strong>各个波的周期并不是 $N$ 而是 $\frac{N}{k}$  ($2\pi /(\frac{2\pi k}{N})$)</strong>。想象一下，如果原数据的采样点有 $N=40$ 。在这个范围内，一个波产生了 5 个完整波形，那么这个波的周期就是 $40/5=8$ , 即 $k=5$ 。5个完整波形意味着波数就是5，那么 <strong>$k$ 就是波数</strong>。 公式(1) - (4) 中的 $f$ 为原信号的频率，$N$ 的倒数。<strong>而傅里叶变化的各个小波的频率为 $\frac{k}{N}$ 。</strong></p></li></ul><hr><p> </p><h2 id="傅里叶逆变换">傅里叶逆变换</h2><p>仔细观察可以发现公式 (7) 的自变量是时间 $x$ 。因此显示的是信号的时域特征。而公式 (13) 的自变量是波数 $k$ 或者说频率 $\frac{k}{N}$ ，因此它显示的是信号的频域特征。我们用公式 (13) 将信号 $y(x) $ 转到频域上，就是傅里叶变换。用公式 (7) 把信号 $c_n$ 转回时域上就是傅里叶逆变换。公式 (7) 写得并不是与 公式 (13) 很对应，因此我们重写一下公式 (7) 和 (13)</p><p>$$<br>\begin{align}<br>c(k) &amp;= \sum\limits_{n = 0}^{N - 1} {y(n) \cdot {e^{ - i\frac{ {2\pi k} }{N}n} } } \\<br>y(n) &amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} { {c_k} \cdot {e^{i\frac{ {2\pi k} }{N}n} } }<br>\end{align}<br>$$</p><p>公式 (14) 和 (15) 分别就是傅里叶变换和傅里叶逆变换。这里为了与<code>Scipy.fft.fft</code> 的算法一致，将本该在公式 (14) 中的 $\frac{1}{N}$ 放在了公式 (15) 中。</p><hr><h2 id="Scipy-fft">Scipy.fft</h2><h3 id="fft-傅里叶变换">fft 傅里叶变换</h3><p>Python 科学计算库 <code>Scipy</code> 提供了方便快捷的傅里叶变换函数。使用这个函数需要注意一些细节。</p><p>首先我们人造一组信号用于测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是由两个角频率为 10 和 15 的信号叠加的。注意是“角频率”</span></span><br><span class="line"><span class="comment"># 其频率分别为10/(2π)=1.59 和 15/(2π)=2.39</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> np.cos(<span class="number">10</span>*n) + np.cos(<span class="number">15</span>*n)</span><br></pre></td></tr></table></figure><p>我们将时间0~7划分为1000份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据长度</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间长度，单位暂定为秒</span></span><br><span class="line">T = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成采样点和信号</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,T,N)</span><br><span class="line">y = f(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行傅里叶变换</span></span><br><span class="line">fft_y = fft(y)  </span><br></pre></td></tr></table></figure><p>生成的 <code>fft_y</code> 即为公式 (14) 中的 $c_k$。在公式 (14) 中 $k=0,1,2,3···N-1$。 想象一下，$k$ 表征波数，如果 $k&gt;\frac{N}{2}$ ，那么意味着这个波每个周期占了不到两个采样点，而波至少需要两个采样点才能确定一个周期波形 (<code>Nyquist</code> 频率概念)。所以 <code>Scipy</code> 采用一种 $-k$ 的方式计算。已知原信号周期为 $N$ ，$k=0,1,2,3···\frac{N}{2}$ 都没什么问题，而考虑周期性的话 $ c(\frac{N}{2}+1 )= c((\frac{N}{2}+1)-N)=c(-\frac{N}{2}+1)$ , 这样 $k$ 被转到了负数上，而由于周期性，计算得到的数值不会改变。例如当 $N=8$ 时，$k=[0, 1, 2, 3, 4, 5, 6, 7]$ 变为 $k=[0, 1, 2, 3, -4, -3, -2, -1]$</p><p>下面对比一下使用 <code>fft</code> 和不使用它的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 scipy.fft.fft 函数计算</span></span><br><span class="line">fft_y=fft(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 k， 但实际上生成的是 k/T</span></span><br><span class="line">fft_x = fftfreq(N,T/N) </span><br><span class="line"></span><br><span class="line"><span class="comment"># [0, 1, 2, 3, -4, -3, -2, -1] 排序调整为</span></span><br><span class="line"><span class="comment"># [-4, -3, -2, -1, 0, 1, 2, 3]</span></span><br><span class="line">fftshift_x = fftshift(fft_x)</span><br><span class="line">fftshift_y = fftshift(fft_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用公式计算</span></span><br><span class="line">k = np.arange(<span class="number">0</span>,N)</span><br><span class="line">yy = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    yy.append(np.<span class="built_in">sum</span>(f(x) * np.exp(-<span class="number">2j</span> * np.pi * k[i] * np.arange(N)/N)))</span><br><span class="line">yy = np.array(yy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax[<span class="number">0</span>].plot(fftshift_x, <span class="built_in">abs</span>(fftshift_y))</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&#x27;函数计算&#x27;</span>,fontfamily=<span class="string">&#x27;SimSun&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].plot(k/T, <span class="built_in">abs</span>(yy))</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&#x27;公式计算&#x27;</span>,fontfamily=<span class="string">&#x27;SimSun&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2EDQf.jpg" title="" alt="" data-align="center"><p>可以看到两种方法计算出的峰值是一样的，只是在x轴是有所不同。图像给出的x轴对应的就是各个波分量的频率。这样看来还是左图更为合理一些，因为 <code>Nyquist</code> 频率的概念存在，波的频率不应该超过 $\frac{N}{2}/T=1000/2/7≈71$</p><ul><li><p>注意事项</p><p>第5行中生成的 <code>fft_x</code> 并不是$k$ 而是 $\frac{k}{T}=\frac{k}{7}$ 也就是真正的这个波分量的频率。我们在公式 (14) 中看到的波频率不应该是 $\frac{k}{N}=\frac{k}{1000}$ 吗？因为在编程过程中 $N$ 只是数据的长度，它不具有单位。在公式 (14) 中 $N$ 也是数据的长度，但它实际上是 $\scriptstyle N=N \times d=N \times 1$ 。$d$ 是采样频率，比如我们有1981-2020年的逐日数据，那么$N=40 \times 365,d=1day$。或者 $d=\frac{1}{30}month$ 。因此 <code>fft_x</code> 代表的频率其实是 $\frac{k} {T}=\frac{k} {N \times d}=\frac{k} {1000 \times 7/1000}$</p><p>不论是哪种方法傅里叶变换总是要输出两个量 $a_n$ 和 $b_n$ 。在复频域中则对应实部和虚部 (注意实部与 $a_n$ 可以相差0.5或$N$ 等常数倍数)。第21行和23行使用的是 <code>abs</code> 表示对复数取模，即根号下实部的平方加虚部的平方。我认为这种处理是比较合理的，因为实部和虚部同样重要，应该综合考虑其分量的振幅。如果不取模直接用 <code>matplotlib</code> ，则只会画出实部。</p></li></ul><h3 id="ifft-傅里叶逆变换与滤波">ifft 傅里叶逆变换与滤波</h3><p>从频域图像中可以看出，频率主要有两个峰值 (四个峰值，其中两个是周期性导致的，看一半即可)。用 <code>np.argsort()</code> 获取排序索引找到峰值对应的频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index[0]与index[1]对应两个相等的最高峰值，相等指的是模相等。其实际数值互为共轭</span></span><br><span class="line"><span class="comment"># 即实部相等，虚部相反。index[2],index[3] 为两个次高的峰值</span></span><br><span class="line">index = np.argsort(<span class="built_in">abs</span>(fftshift_y))[::-<span class="number">1</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到峰值对应的频率</span></span><br><span class="line"><span class="built_in">print</span>(fftshift_x[index])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: array([-1.57142857,  1.57142857, -2.42857143,  2.42857143])</span></span><br></pre></td></tr></table></figure><p>可以计算一下我们一开始是用角频率为10和15的两个信号叠加的。频率等于角频率除以 2π 所以10/(2π) = 1.59和15/(2π) = 2.39 。这与程序输出结果一致。我们准确的找出了信号中的两个主频率。</p><p>利用这一点，我们就可以实现滤波。例如我想去除掉 $cos(15\pi x)$ 这个波。那么我只需要将图像中的那个次高峰变为0即可。因为次高峰对应的频率2.39，也就是角频率15。那么我们只需要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftshift_y[index[[<span class="number">2</span>,<span class="number">3</span>]]] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>好了，现在频域上我们已经去掉了角频率为15的波，现在需要把频域信号转回时域上。也就是傅里叶逆变换。基本公式也就是公式 (15)。我们将处理好的 $c_n$ 代入公式 (15) 计算出 $y(x)$ 也就完成了逆变换。</p><p>在 <code>Scipy.fft.ifft</code> 可以帮助我们快速实现这一点。需要注意的是 <code>ifft</code> 的输入量只能是 <code>fft</code> 和 <code>fftfreq</code> 的直接输出量，不能是用 <code>fftshift</code> 调整顺序之后的量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 傅里叶逆变换</span></span><br><span class="line">ifft_y = ifft(fft_y)</span><br><span class="line"></span><br><span class="line">fig2, ax2 = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax2[<span class="number">0</span>].plot(x, ifft_y, label=<span class="string">&#x27;ifft&#x27;</span>)</span><br><span class="line">ax2[<span class="number">0</span>].plot(x, np.cos(<span class="number">10</span>*n), label=<span class="string">&#x27;cos(10x)&#x27;</span>)</span><br><span class="line">ax2[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对滤波后的信号再做一次傅里叶变换，检测滤波效果</span></span><br><span class="line">ax2[<span class="number">1</span>].plot(fft_x, fft(ifft_y), label=<span class="string">&#x27;ifft again&#x27;</span>)</span><br><span class="line">ax2[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Ery8.jpg" title="" alt="" data-align="center"><p>可以看到第一张图，滤波后的曲线与 $cos(10x)$ 的曲线比较接近，几乎没有受到 $cos(15x)$ 的影响，但并不是完全重合。对滤波后的时域信号再做一次傅里叶变换，可以看到峰值只剩一个主峰。但在0附近仍存在一个小峰没有去除掉。这个信号的来源不是很清楚，与离散傅里叶变换的误差有关？</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作</title>
      <link href="/2022/07/11/linux/"/>
      <url>/2022/07/11/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>记录Linux相关操作命令和学习过程、心得。学习网站：蓝桥云课程</p><hr><h2 id="基本操作">基本操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 file 的文件，touch是一个命令</span></span><br><span class="line"><span class="built_in">touch</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入一个目录，cd是一个命令</span></span><br><span class="line"><span class="built_in">cd</span> /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前所在目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前目录下文件名</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment"># 显示隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> *.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命令帮助</span></span><br><span class="line">man</span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h2 id="用户及文件权限管理">用户及文件权限管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新用户</span></span><br><span class="line">sudo adduser xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出当前用户</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看用户所在组</span></span><br><span class="line"><span class="built_in">groups</span> xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把用户加入sudo中</span></span><br><span class="line">sudo usermod -G sudo lilei</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure><h3 id="查看文件权限">查看文件权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用较长格式列出文件</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vx4s.png" title="" alt="" data-align="center"><img src="https://s1.ax1x.com/2023/03/30/pp2Zp3q.png" title="" alt="" data-align="center"><img src="https://s1.ax1x.com/2023/03/30/pp2Z9g0.png" title="" alt="" data-align="center"><p>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；</p><p>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 <code>exe</code> 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</strong>，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</p><ul><li>变更文件所有者</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要切换到 xiao 用户执行以下操作</span></span><br><span class="line">sudo <span class="built_in">chown</span> xiao(用户名) iphone11(文件名)</span><br></pre></td></tr></table></figure><ul><li>更改文件权限</li></ul><p>每个文件有三组固定的权限，分别对应<code>拥有者，所属用户组，其他用户</code>，<strong>记住这个顺序是固定的</strong>。文件的读写执行对应字母 <code>rwx</code>，以二进制表示就是 <code>111</code>，用十进制表示就是 <code>7</code>，对进制转换不熟悉的同学可以看看 <a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a>。例如我们刚刚新建的文件 iphone11 的权限是 <code>rw-rw-rw-</code>，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。</p><p>如果我要将文件 iphone11 的权限改为只有我自己可以用那么就可以用这个方法更改它的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> 600 iphone11</span><br><span class="line"><span class="built_in">ls</span> -alh iphone11</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZmCR.png" title="" alt="" data-align="center"><hr><h2 id="Linux-目录结构及文件基本操作">Linux 目录结构及文件基本操作</h2><h3 id="文件目录">文件目录</h3><blockquote><p>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。</p></blockquote><p>FHS 定义了两层规范，第一层是， <code>/</code> 下面的各个目录应该要放什么文件数据，例如 <code>/etc</code> 应该放置设置文件，<code>/bin</code> 与 <code>/sbin</code> 则应该放置可执行文件等等。</p><p>第二层则是针对 <code>/usr</code> 及 <code>/var</code> 这两个目录的子目录来定义。例如 <code>/var/log</code> 放置系统日志文件，<code>/usr/share</code> 放置共享数据等等。</p><img src="https://img-blog.csdnimg.cn/img_convert/b88605383677285c7c0d0e76157ffd9f.png" title="" alt="" data-align="center"><blockquote><p><code>~</code> 目录位于 <code>/</code> 目录之下。例如进入<code>/</code> 之后，再进入 <code>home</code> ，再进入用户，也就进入了 <code>~</code> 目录。</p><p><code>/</code> 目录下除了存放 <code>home</code> 以外还存放了一些系统文件夹，例如 <code>etc</code>, <code>bin</code>, <code>lib</code> 等等。</p><p><code>~</code> 目录下则存放了 <code>Desktop</code> , <code>~</code> 更像是我们熟悉的 Windows。</p><p>在使用绝对路径时，路径的起点是 <code>/</code> 目录。例如使用绝对路径进入<code>~</code> 时：</p><p>cd /home/xiao</p><p>home 前要加 ‘/’</p></blockquote><h3 id="文件基本操作">文件基本操作</h3><ul><li><p>创建空白文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>若当前目录存在一个 test 文件夹，则 touch 命令，则会更改该文件夹的时间戳而不是新建文件。</p></blockquote></li></ul><p> </p><ul><li><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mydir</span><br></pre></td></tr></table></figure></li><li><p>同时创建父目录(多级目录)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p father/son/grandson</span><br></pre></td></tr></table></figure></li><li><p>复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">test</span> father/son/grandson</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>要成功复制<strong>目录</strong>需要加上 <code>-r</code> 或者 <code>-R</code> 参数，表示递归复制，就是说有点“株连九族”的意思。</p></blockquote><p> </p><ul><li><p>复制整个文件夹和其内文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r father family</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>若 <code>family</code> 文件夹不存在，则生成 <code>father</code> 副本，并重命名为 <code>family</code>。若<code>family</code>存在，则在<code>family</code>下得到 <code>father</code> 副本。</p></blockquote><p> </p><ul><li><p>删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若文件为只读文件，-f 参数忽视只读权限之间删除</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -r family</span><br><span class="line"><span class="built_in">rm</span> -rf family</span><br></pre></td></tr></table></figure></li><li><p>移动文件、重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment"># mv 还有重命名的作用</span></span><br><span class="line"><span class="built_in">mv</span> file1_oldname file1_newname</span><br></pre></td></tr></table></figure></li><li><p>查看文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line"><span class="built_in">cat</span> -n passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更专业的行号打印</span></span><br><span class="line"><span class="built_in">nl</span> -b a file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查看</span></span><br><span class="line">more file1</span><br><span class="line">less file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件头几行或尾几行</span></span><br><span class="line"><span class="built_in">head</span> -n 5 file1 <span class="comment"># 头5行</span></span><br><span class="line"><span class="built_in">tail</span> -n 5 file1 <span class="comment"># 尾5行</span></span><br></pre></td></tr></table></figure></li><li><p>查看文件类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找文件">查找文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /etc/(文件目录) -name file.sh(文件名，有后缀则加后缀)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前文件夹下以.c 为后缀的文件</span></span><br><span class="line">find . -name <span class="string">&quot;*.c&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>如开头加 sudo 表示使用管理员权限。可解决一些权限不足的问题。</p><p><code>-name</code> 不能乱丢</p><p>此外还有 <code>locate</code>, <code>which</code>, <code>whereis</code> 等查找命令，不细说了</p></blockquote><h2 id="文件压缩与解压">文件压缩与解压</h2><ul><li><p>zip 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip -r -q -o dir.zip(要生成的压缩文件命) /home/Desktop(要压缩的文件或文件夹)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把多个文件压缩在一起</span></span><br><span class="line">zip dir.zip file1 file2 file3</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code>表示递归打包子目录内容。不加<code>-r</code> 则无法把文件夹内其他东西压缩在一起</p><p><code>-p</code> 表示安静模式，不向屏幕输出信息</p><p><code>-o</code> 表示输出文件</p><p><code>zip /dir1/dir2/name.zip file1</code>  用这种方式将文件压缩到指定文件夹</p></blockquote></li></ul><p> </p><ul><li><p>查看文件大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h file1</span><br></pre></td></tr></table></figure><blockquote><p><code>-h</code>表示人类可读的形式</p></blockquote></li></ul><p> </p><ul><li><p>zip 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip dir.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用安静模式，将文件解压到指定目录</span></span><br><span class="line">unzip -q file1.zip -d dir_zip</span><br></pre></td></tr></table></figure><blockquote><p>若上述指定目录 <code>dir_zip</code> 不存在，将会自动创建</p></blockquote></li></ul><p> </p><ul><li><p>仅查看压缩包内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l file1.zip</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p><p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p><p><code>unzip -O GBK 中文压缩文件.zip</code></p></blockquote></li></ul><p> </p><ul><li><p>tar 压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -P -<span class="built_in">cd</span> file1.tar /home/Desktop</span><br></pre></td></tr></table></figure><blockquote><p><code>tar</code> 命令压缩可直接将整个文件夹内容压缩进去。不需要像 <code>zip</code> 命令那样添加 <code>-r</code> 进行递归</p><p><code>-P</code> 保留绝对路径符</p><p><code>-c</code> 表示创建一个 tar 包文件</p><p><code>-f</code> 用于指定创建的文件名，<strong>注意文件名必须紧跟在 <code>-f</code> 参数之后</strong>，比如不能写成 <code>tar -fc shiyanlou.tar</code>，可以写成 <code>tar -f shiyanlou.tar -c ~</code>。你还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p></blockquote></li></ul><p> </p><ul><li><p>tar 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf fil1.tar -C tardir</span><br></pre></td></tr></table></figure><blockquote><p>解压目录 <code>tardir</code> 必须存在。目前还没找到解压到不存在的目录的方法。</p></blockquote></li></ul><p> </p><ul><li><p>仅查看压缩包内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf file1.tar</span><br></pre></td></tr></table></figure></li><li><p>总结</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip：</span></span><br><span class="line">zip something.zip something <span class="comment"># 打包</span></span><br><span class="line">unzip something.zip <span class="comment"># 解包</span></span><br><span class="line"><span class="comment"># 指定路径：-d 参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tar：</span></span><br><span class="line">tar -cf something.tar something <span class="comment"># 打包</span></span><br><span class="line">tar -xf something.tar <span class="comment"># 解包</span></span><br><span class="line"><span class="comment"># 指定路径：-C 参数</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="运行程序">运行程序</h2><p><strong>后台</strong>运行脚本 <code>CMAhgt.py</code> 把结果(包括报错信息) 输出到 <code>CMAhgt.out</code> 里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python CMAhgt.py &gt; CMAhgt.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="查看内存、储存">查看内存、储存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前内存（运行内存）</span></span><br><span class="line">free -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前目录下所有文件的大小（包括文件夹）</span></span><br><span class="line">du -sh *</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统磁盘储存剩余量</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="查找文件-2">查找文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&#x27;libnetcdf.so.19*&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="slurm调度系统">slurm调度系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看任务信息</span></span><br><span class="line">sacct --format=JobID,JobName,Start,End,Elapsed,AllocCPUS,State,Partition</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行中的任务</span></span><br><span class="line">squeue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地图及地图文件使用技巧</title>
      <link href="/2022/07/08/mapshape/"/>
      <url>/2022/07/08/mapshape/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-12">前言</h2><p>记录一下使用地图及地图文件的小技巧吧</p><hr><h2 id="地图的合并">地图的合并</h2><p>bou2_4p.shp 由各个省份的polygon组成。 如何将江苏省和山东省的polygon合并组成一个polygon呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> shapely</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">china = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取江苏和山东的 polygon</span></span><br><span class="line">province = china.loc[china.NAME.isin([<span class="string">&#x27;江苏省&#x27;</span>,<span class="string">&#x27;山东省&#x27;</span>]), <span class="string">&#x27;geometry&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并polygon</span></span><br><span class="line">polygon_combine = shapely.ops.unary_union(province)</span><br></pre></td></tr></table></figure><hr><p> </p><h2 id="Proplot极地投影画出直线段">Proplot极地投影画出直线段</h2><p>今天作图的时候想在地图上取一个剖面，于是想现在图上画出剖面线段。这件事本来在等经纬度投影下是一件很容易的事情，然而我的地图是北极投影，做出来的效果并不是想象中的样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;npaeqd&#x27;</span>, proj_kw=&#123;<span class="string">&#x27;lon_0&#x27;</span>:<span class="number">160</span>&#125;)</span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.plot([<span class="number">90</span>,<span class="number">210</span>],[<span class="number">80</span>,<span class="number">30</span>], marker=<span class="string">&#x27;o&#x27;</span>, transform=<span class="string">&#x27;npaeqd&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ZlDO.png" alt="请添加图片描述" data-align="center"><p>如上所示，我想在<code>(90E,80N)</code>和<code>(210E, 30N)</code>之间画一个线段，然而并不能实现。这并不是 <code>Proplot</code>的问题，问题在于极地投影下经纬度并不 <code>（-180~180，-90-90）</code> 的范围。我们需要将等经纬度投影下的<code>(90E,80N)</code>和<code>(210E, 30N)</code> 转换到极地投影下的经纬度坐标。如何实现呢？ 其实在 <a href="https://664787022.github.io/2022/06/22/geomask/"><font color=CornflowerBlue>利用 geopandas 地图白化 | XHW’s Blog (664787022.github.io) </font></a> 这篇博文里讲了类似的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将等经纬度投影的经纬度转为极地投影下的坐标</span></span><br><span class="line">pp = ccrs.NorthPolarStereo()</span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),</span><br><span class="line">                 np.array([<span class="number">90</span>,<span class="number">210</span>]), np.array([<span class="number">80</span>,<span class="number">30</span>]))[:,<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;npaeqd&#x27;</span>, proj_kw=&#123;<span class="string">&#x27;lon_0&#x27;</span>:<span class="number">160</span>&#125;)</span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.plot(path_clip.vertices[:,<span class="number">0</span>],path_clip.vertices[:,<span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">        transform=<span class="string">&#x27;npaeqd&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Z8Ve.png" title="" alt="在这里插入图片描述" data-align="center"><p>如果不使用<code> Proplot</code> 而直接用 <code>Cartopy</code> ，情况会更简单一点。因为在 <code>Cartopy下</code> 可以使用 <code>ccrs.Geodetic()</code>  而 <code>Proplot</code> 似乎没有把 <code>ccrs.Geodetic()</code> 加入进自己的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=ccrs.NorthPolarStereo(central_longitude=<span class="number">160</span>))</span><br><span class="line"></span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.coastlines() </span><br><span class="line"><span class="comment"># 注意这里使用的是ccrs.Geodetic()，使用ccrs.NorthPolarStereo是没用的</span></span><br><span class="line">ax.plot([<span class="number">90</span>,<span class="number">210</span>],[<span class="number">80</span>,<span class="number">30</span>], marker=<span class="string">&#x27;o&#x27;</span>, transform=ccrs.Geodetic())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZGUH.png" title="" alt="在这里插入图片描述" data-align="center"><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> geopandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用geopandas地图白化</title>
      <link href="/2022/06/22/geomask/"/>
      <url>/2022/06/22/geomask/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-10">前言</h2><p>偶然间看到摸鱼咯大佬在和鲸社区发的帖子 <a href="https://www.heywhale.com/mw/project/621450308da0860017bdfb1a"><font color=CornflowerBlue>geopandas白化</font></a>，利用了<code>geopandas</code>对等值线进行白化。以往我是用气象家园中的maskout.py函数进行白化的。但使用maskout.py需要结合meteoinfo对地图文件进行查看，相对来说还是比较麻烦的。在这里就记录一下使用geopandas的方法。</p><p>以下用的数据存放在网盘中</p><p><a href="https://pan.baidu.com/s/1ExMNF1-yv0OsVg8CH4fbxA"><font color=CornflowerBlue>百度网盘：j4d3</font></a></p><hr><h2 id="代码示例">代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = xr.open_dataset(<span class="string">&#x27;D:/data_english/era5/slp.sst.pre.1979-2020mon.global.nc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 海平面气压距平</span></span><br><span class="line">slp = data[<span class="string">&#x27;msl&#x27;</span>][:,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>))</span><br><span class="line">lon, lat = np.meshgrid(slp.longitude, slp.latitude)</span><br><span class="line"></span><br><span class="line">gb = slp.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">slpa = gb - clim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随便取一年</span></span><br><span class="line">slpa = slpa[<span class="number">0</span>,...]</span><br></pre></td></tr></table></figure><h3 id="未白化的状况">未白化的状况</h3><p>只看中国周围吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;cyl&#x27;</span>,                        <span class="comment"># 等经纬度投影</span></span><br><span class="line">                        lonlim=(<span class="number">70</span>, <span class="number">140</span>), latlim=(<span class="number">10</span>, <span class="number">60</span>)) <span class="comment"># 设置extent</span></span><br><span class="line"></span><br><span class="line">kw = &#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;RdBu&#x27;</span>,        <span class="comment"># 设置cmap</span></span><br><span class="line">      <span class="string">&#x27;extend&#x27;</span>:<span class="string">&#x27;both&#x27;</span>,      <span class="comment"># 设置extend</span></span><br><span class="line">      <span class="string">&#x27;symmetric&#x27;</span>:<span class="literal">True</span>&#125;     <span class="comment"># 保证 0 在 colorbar中间</span></span><br><span class="line"></span><br><span class="line">fill = ax[<span class="number">0</span>].contourf(lon, lat, slpa, **kw, vmin=-<span class="number">900</span>) <span class="comment"># 等值线填色</span></span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>,                 <span class="comment"># 经纬度标签</span></span><br><span class="line">          coast=<span class="literal">True</span>,                  <span class="comment"># 海岸线</span></span><br><span class="line">          gridlabelsize=<span class="string">&#x27;xx-small&#x27;</span>)    <span class="comment"># 经纬度标签字体大小</span></span><br><span class="line"></span><br><span class="line">fig.colorbar(fill, label=<span class="string">&#x27;&#x27;</span>,                 <span class="comment"># 取掉colorbar的label</span></span><br><span class="line">                   ticklabelsize=<span class="string">&#x27;xx-small&#x27;</span>, <span class="comment"># colorbar tick字体大小</span></span><br><span class="line">                   width=<span class="number">0.1</span>)                <span class="comment"># colorbar宽度</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2E7mF.png" alt="" data-align="center" width="473"><hr><h3 id="geopandas-读取-shp">geopandas 读取 shp</h3><p><code>下面利用bou2_4p.shp对中国区域进行白化。先看一下geopandas读取shp文件的结果。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    AREA    PERIMETER    BOU2_4M_    BOU2_4M_ID    ADCODE93    ADCODE99    NAME    geometry</span><br><span class="line">0    54.447    68.489    2    23    230000    230000    黑龙江省    POLYGON ((121.48844 53.33265, 121.49954 53.336...</span><br><span class="line">1    129.113    129.933    3    15    150000    150000    内蒙古自治区    POLYGON ((121.48844 53.33265, 121.49738 53.321...</span><br><span class="line">2    175.591    84.905    4    65    650000    650000    新疆维吾尔自治区    POLYGON ((96.38329 42.72696, 96.35991 42.70969...</span><br><span class="line">3    21.315    41.186    5    22    220000    220000    吉林省    POLYGON ((123.17104 46.24668, 123.21857 46.269...</span><br><span class="line">4    15.603    38.379    6    21    210000    210000    辽宁省    POLYGON ((123.69019 43.37677, 123.70496 43.381...</span><br><span class="line">...    ...    ...    ...    ...    ...    ...    ...    ...</span><br><span class="line">920    0.000    0.037    922    3110    810000    810000    香港特别行政区    POLYGON ((114.24527 22.18337, 114.24348 22.184...</span><br><span class="line">921    0.000    0.018    923    3109    810000    810000    香港特别行政区    POLYGON ((114.28620 22.18478, 114.28435 22.185...</span><br><span class="line">922    0.000    0.014    924    3112    810000    810000    香港特别行政区    POLYGON ((114.30350 22.18492, 114.30413 22.186...</span><br><span class="line">923    0.000    0.079    925    3114    810000    810000    香港特别行政区    POLYGON ((114.25628 22.16027, 114.25436 22.163...</span><br><span class="line">924    0.000    0.011    926    3115    810000    810000    香港特别行政区    POLYGON ((114.29893 22.17812, 114.30064 22.178...</span><br></pre></td></tr></table></figure><hr><h3 id="关键白化操作">关键白化操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">china = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成裁剪路径 – 关键操作1</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(china))</span><br><span class="line"><span class="comment"># 将裁剪路径应用到图层 – 关键操作2</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ERFs.png" alt="" data-align="center" width="458"><p><font size=5 color="blue"> 可直接添加图窗画区域边缘 </font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制多边形边缘线</span></span><br><span class="line"><span class="comment"># bou1_4l包括国界线和南海九段线</span></span><br><span class="line">shp2 = gpd.read_file(<span class="string">&#x27;bou1_4l.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">ax.add_geometries(shp2[<span class="string">&#x27;geometry&#x27;</span>].tolist(), crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;none&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EbTJ.png" alt="" data-align="center" width="436"><p><font size=5 color="blue"> 合并添加多个shp </font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可添加多个shp</span></span><br><span class="line"><span class="comment"># bou2_4p包括国界和省界</span></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">shp2 = gpd.read_file(<span class="string">&#x27;bou1_4l.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line"></span><br><span class="line">com = shp2[<span class="string">&#x27;geometry&#x27;</span>].append(shp[<span class="string">&#x27;geometry&#x27;</span>]) <span class="comment"># 合并两个shp</span></span><br><span class="line"><span class="comment"># 或者 com = shp2[&#x27;geometry&#x27;].tolist() + shp[&#x27;geometry&#x27;].tolist()</span></span><br><span class="line"></span><br><span class="line">ax.add_geometries(com, crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;none&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EvSx.png" alt="" data-align="center" width="434"><hr><h3 id="风矢量的白化">风矢量的白化</h3><p>quiver生成的对象与contourf生成的对象不同，<code>它不包含collection属性</code>。所以白化操作略有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取资料</span></span><br><span class="line">data2 = xr.open_dataset(<span class="string">&#x27;GH.UV.500_850hPa.1979-2020.nc&#x27;</span>)</span><br><span class="line">u = data2[<span class="string">&#x27;u&#x27;</span>][:,<span class="number">0</span>,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="number">70</span>,<span class="number">140</span>,<span class="number">4</span>))</span><br><span class="line">v = data2[<span class="string">&#x27;v&#x27;</span>][:,<span class="number">0</span>,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="number">70</span>,<span class="number">140</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取距平</span></span><br><span class="line">gb = u.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">ua = gb - clim</span><br><span class="line">ua = ua[<span class="number">0</span>,...]</span><br><span class="line"></span><br><span class="line">gb = v.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">va = gb - clim</span><br><span class="line">va = va[<span class="number">0</span>,...]</span><br><span class="line"></span><br><span class="line">lon2, lat2 = np.meshgrid(u.longitude,v.latitude)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d=<span class="number">1</span></span><br><span class="line">tt = ax.quiver(lon2[::d,::d],lat2[::d,::d],ua[::d,::d],va[::d,::d])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剪切白化</span></span><br><span class="line">tt.set_clip_path(path_clip, transform=ax.transData)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VSOO.png" alt="" data-align="center" width="476"><mark class="hl-label red">对于quiver，数据范围最好保证在extent范围内。如果使用-180~180的数据，而extent只设定在70-120，那么画出来的矢量箭头会非常小，需要手动调整scale。一般来说需要进一步调整降低箭头密集度，并调整scale</mark> <hr><h3 id="contour-和-clabel的白化">contour 和 clabel的白化</h3><p><code>contour的白化方法与contourf白化方法相同。contour生成对象后，提取collection循环切片即可。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon <span class="keyword">as</span> ShapelyPolygon</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point <span class="keyword">as</span> ShapelyPoint</span><br><span class="line"></span><br><span class="line">data = xr.open_dataset(<span class="string">&#x27;D:/data_english/era5/slp.sst.pre.1979-2020mon.global.nc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%% </span></span><br><span class="line"></span><br><span class="line">slp = data[<span class="string">&#x27;msl&#x27;</span>][:,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>))</span><br><span class="line">lon, lat = np.meshgrid(slp.longitude, slp.latitude)</span><br><span class="line"></span><br><span class="line">gb = slp.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">slpa = gb - clim</span><br><span class="line">slpa = slpa[<span class="number">0</span>,...]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建等值线和labels</span></span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;cyl&#x27;</span>,lonlim=(<span class="number">70</span>, <span class="number">140</span>), latlim=(<span class="number">10</span>, <span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">kw = &#123; <span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;RdBu_r&#x27;</span>,<span class="string">&#x27;extend&#x27;</span>:<span class="string">&#x27;both&#x27;</span>, <span class="string">&#x27;symmetric&#x27;</span>:<span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line">fill = ax[<span class="number">0</span>].contourf(lon, lat, slpa, **kw, vmin=-<span class="number">900</span>,values=<span class="number">20</span>)</span><br><span class="line">con = ax[<span class="number">0</span>].contour(lon, lat, slpa, levels=fill.levels,</span><br><span class="line">                    color=<span class="string">&#x27;black&#x27;</span>,linewidth=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">cb = ax[<span class="number">0</span>].clabel(con,levels=fill.levels)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>, gridlabelsize=<span class="string">&#x27;xx-small&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.colorbar(fill, label=<span class="string">&#x27;&#x27;</span>, ticklabelsize=<span class="string">&#x27;xx-small&#x27;</span>, width=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VktA.png" alt="" data-align="center" width="380"><p>下面对<code>等值线白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shp = gpd.read_file(<span class="string">&#x27;D:/anaconda_spyder_filesave/mission/mission9/0619/shpfile/bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">ee = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成裁剪路径 – 关键操作1</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(ee))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将裁剪路径应用到图层 – 关键操作2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对填色图白化</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对等值线白化</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> con.collections]</span><br><span class="line"></span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VGpq.png" alt="" data-align="center" width="352"><p>可以看到labels还是到处乱飞，下面需要对labels白化。然而labels对象是Text组成的列表，操作过程以上等值线白化又有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clabel白化</span></span><br><span class="line"><span class="comment"># cb = ax[0].clabel(con,levels=fill.levels)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> text_object <span class="keyword">in</span> cb:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path_clip.contains_point(text_object.get_position()):</span><br><span class="line">        text_object.set_visible(<span class="literal">False</span>)  </span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VYcV.png" alt="" data-align="center" width="397"><p><code>path_clip.contains_point</code> 判断点是否在路径所包围的区域内</p><hr><h3 id="非等经纬度投影白化">非等经纬度投影白化</h3><p><code>以上白化操作ax的投影皆为ccrs.PlateCarree()</code>, <code>数据投影也为ccrs.PlateCarree()</code>。因此无论是画图还是白化都不需要额外的操作来转化点的坐标。</p><p>需要注意的是，在创建ax时，<code>projection参数是对ax进行投影设置</code>。即若projection=ccrs.PlateCarree()，则我们最后看到的图就是等经纬度投影的图。若projection=ccrs.LambertConformal()，则我们最后看到的图就是兰伯特投影的样子。</p><p>然而<code>在contourf的transform和ax.set_extent()中设置的crs的意义不同，它们要求我们告诉程序，为什么所输入的数据是取自怎样的投影</code>。一般来说，我们的数据都是格点数据，lon:-180~180, lat:-90~90。即我们的数据一般是等经纬度的，<code>所以transform和crs都设置为ccrs.PlateCarree()就可以了(不随projection的变化而变化)</code>。</p><p>详情可以看这里  <a href="https://scitools.org.uk/cartopy/docs/latest/tutorials/understanding_transform.html?highlight=transform"><font color=CornflowerBlue>transform和projection的意义</font></a></p><p>此外，通常我们的shp文件提取出的点也是等经纬度的lon:-180~180, lat:-90~90。<code>而当projection=ccrs.LambertConformal()时就无法直接用以上程序直接进行白化</code>，因为坐标不对应。这个时候<code>需要先将路径Path转化到相应的projection上</code>。</p><p>注意即使我们的projection使用的是ccrs.PlateCarree()，但设置了中心经度例如projection=ccrs.PlateCarree(central_longitude=120)。也需要对路径点进行坐标转化。<code>路径点坐标系必须与 projection 完全一致</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非等经纬度投影白化</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(ee))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的操作会丢失codes信息，需要提前保存副本</span></span><br><span class="line">codes = path_clip.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设在创建ax时设置了兰伯特投影和中心经度、中心纬度</span></span><br><span class="line"><span class="comment"># fig, ax = pplt.subplots(proj=&#x27;lcc&#x27;,lonlim=(70, 140), </span></span><br><span class="line"><span class="comment">#                       latlim=(10, 60),proj_kw=&#123;&#x27;lon_0&#x27;:100,&#x27;lat_0&#x27;:30&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须与projection一致</span></span><br><span class="line">pp = ccrs.LambertConformal(central_longitude=<span class="number">100</span>, central_latitude=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步将处于ccrs.PlateCarree()里的路径点转化到 pp 投影上</span></span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),path_clip.vertices[:,<span class="number">0</span>], path_clip.vertices[:,<span class="number">1</span>])[:,<span class="number">0</span>:<span class="number">2</span>],codes=codes)</span><br></pre></td></tr></table></figure><div class="note success simple"><p>codes似乎标记了多边形个体，每个多边形用有一个数字存在codes中。如果不添加codes参数，例如大陆和海南岛之间会有路径穿过。</p><p>摸鱼咯大佬的帖子中使用的是ccrs.Geodetic()而不是ccrs.PlateCarree()来转化路径点，我不清楚有什么区别。我觉得ccrs.PlateCarree()更合理一些。</p></div><p>由此，我们得到了一个<code>新的path_clip</code>，后面的白化过程就与之前的内容完全一致了。如果我们不是用等经纬度投影创建坐标轴，就<code>需要将路径点的坐标转化到相应的projection上</code>。</p><hr><h3 id="南海小图">南海小图</h3><p>有时候在画中国地图时需要对地图右下角添加一个小图来显示南海地区。这个小图可以和主图完全相同，只需要调整<code>extent</code>即可。然而，在白化之后会出现如下图的情况。</p><img src="https://s1.ax1x.com/2023/03/30/pp2VaBF.png" title="" alt="" data-align="center"><p>小图范围内虽然白化成功，但是小图之外的图像并没有去除掉。原因在于<code>ax.set_extent()</code>和<code>collection.set_clip()</code>这两个命令相互覆盖了。导致只有一个命令生效。解决的方法就是找到<code>extent</code>与<code>path_clip</code>的交集。思路来源于：<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NzY4MzgxNw==&amp;mid=2247488767&amp;idx=1&amp;sn=5df006905b3e16d7cc4a100988393b03&amp;chksm=cf87fb79f8f0726f51ce8bb5c6bde9f8bcf5535bb4ca8db502083c0f9cee26c1a0e90d23bf90&amp;mpshare=1&amp;scene=23&amp;srcid=06234bAPPyrWvy7gJ1FgEOLf&amp;sharer_sharetime=1661769196302&amp;sharer_shareid=327e1b5af213919a0371744eb74c4650#rd"><font color=CornflowerBlue>链接</font></a> 。我对其代码进行了精简。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> geometry <span class="keyword">as</span> geo</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path,path_to_geos</span><br><span class="line"></span><br><span class="line"><span class="comment"># proplot添加内嵌坐标轴</span></span><br><span class="line">iax = ax.inset([<span class="number">140</span>-<span class="number">11</span>*<span class="number">0.8</span>,<span class="number">10</span>,<span class="number">11</span>*<span class="number">0.8</span>,<span class="number">24</span>*<span class="number">0.8</span>],transform=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填色图</span></span><br><span class="line">fill2 = iax.contourf(lon, lat, o3, extend=<span class="string">&#x27;both&#x27;</span>, robust=<span class="literal">True</span>)</span><br><span class="line">iax.add_geometries(shp[<span class="string">&#x27;geometry&#x27;</span>], crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;None&#x27;</span>, )</span><br><span class="line">iax.add_geometries(shp2[<span class="string">&#x27;geometry&#x27;</span>], crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;None&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">iax.<span class="built_in">format</span>(lonlim=(<span class="number">109</span>,<span class="number">120</span>), latlim=(<span class="number">0</span>,<span class="number">24</span>))</span><br><span class="line"></span><br><span class="line">extent = [<span class="number">109</span>,<span class="number">120</span>,<span class="number">0</span>,<span class="number">24</span>]</span><br><span class="line">extentPolygon = geo.Polygon([</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">2</span>]),</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">3</span>]),</span><br><span class="line">    (extent[<span class="number">1</span>], extent[<span class="number">3</span>]),</span><br><span class="line">    (extent[<span class="number">1</span>], extent[<span class="number">2</span>]),</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">2</span>]),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键步骤*************</span></span><br><span class="line">polygon_clip = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> path_to_geos(path_clip): <span class="comment"># 将 path 转 polygon</span></span><br><span class="line">    polygon_clip.append(extentPolygon.intersection(p)) <span class="comment"># 将交集填入列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新将交集 polygon 转为 path</span></span><br><span class="line">path_clip2 = Path.make_compound_path(*geos_to_path(polygon_clip))</span><br><span class="line">[collection.set_clip_path(path_clip2, transform=iax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill2.collections]</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vd74.png" title="" alt="" data-align="center"><hr><h2 id="总结-2">总结</h2><p>写了这么多，再回去看看觉得好乱。那就简单做个总结吧。</p><p><code>文件读取</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;./shpfile/china.shp&#x27;</span>)</span><br><span class="line">china = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br></pre></td></tr></table></figure><p><code>剪切路径</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(china))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 ax 不是等经纬度投影需要加上以下代码，以兰伯特投影为例</span></span><br><span class="line">codes = path_clip.codes</span><br><span class="line">pp = ccrs.LambertConformal(central_longitude=<span class="number">100</span>, central_latitude=<span class="number">30</span>)</span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),path_clip.vertices[:,<span class="number">0</span>], path_clip.vertices[:,<span class="number">1</span>])[:,<span class="number">0</span>:<span class="number">2</span>],codes=codes)</span><br></pre></td></tr></table></figure><p><code>等值线和填色图白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fill：填色图对象</span></span><br><span class="line"><span class="comment"># con：等值线对象</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> con.collections]</span><br></pre></td></tr></table></figure><p><code>风矢量白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tt：quiver对象</span></span><br><span class="line">tt.set_clip_path(path_clip, transform=ax.transData)</span><br></pre></td></tr></table></figure><p><code>clabel 白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cb：clabel对象</span></span><br><span class="line"><span class="keyword">for</span> text_object <span class="keyword">in</span> cb:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path_clip.contains_point(text_object.get_position()):</span><br><span class="line">        text_object.set_visible(<span class="literal">False</span>) </span><br></pre></td></tr></table></figure><p><code>polygon取交集白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># extentPolygon 与 path_clip 取交集</span></span><br><span class="line">polygon_clip = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> path_to_geos(path_clip): <span class="comment"># 将 path 转 polygon</span></span><br><span class="line">    polygon_clip.append(extentPolygon.intersection(p)) <span class="comment"># 将交集填入列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新将交集 polygon 转为 path</span></span><br><span class="line">path_clip2 = Path.make_compound_path(*geos_to_path(polygon_clip))</span><br><span class="line">[collection.set_clip_path(path_clip2, transform=iax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill2.collections]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白化 </tag>
            
            <tag> proplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proplot相关说明及示例</title>
      <link href="/2022/05/25/proplot/"/>
      <url>/2022/05/25/proplot/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-13">前言</h2><p>今天发现一个python模块包: <mark class="hl-label red">Proplot</mark> 。</p><p><a href="https://proplot.readthedocs.io/en/stable/"><font color=CornflowerBlue>ProPlot 文档</font></a></p><p><a href="https://github.com/lukelbd/proplot"><font color=CornflowerBlue>Proplot_github</font></a></p><p>它整合封装了matplotlib，cartopy，basemap。将画图命令精简整合，图窗和轴的排列更加智能整齐，可以说解决了我的很多痛点。但proplot的文档中给出的例子太少，我打算自己做一些例子，帮助自己学会proplot。</p><hr><h2 id="fig和ax的创建">fig和ax的创建</h2><h3 id="fig，ax参数列表">fig，ax参数列表</h3><hr><mark class="hl-label red">Fig-Subplots</mark> <p>nrows: int； 子图行数</p><p>ncols: int；子图列数</p><p>space/wspace/hspace: float, str, None, turple；子图间距</p><p>refwidth: float; 子图宽度</p><p>refheight: float；子图高度</p><p>refaspect: float; 长宽比，默认1</p><p>figsize: tuple; 图窗大小</p><p>figwidth: float, str; 图窗宽度</p><p>figheight: float, str; 图窗高度</p><p>bottom/right/left/top: float, str, None; 图窗边界宽度</p><p>grid/xgrid/ygrid：bool; 网格线, 默认‘True’</p><mark class="hl-label green">Label-Ticks</mark> <p>abc: str; 子图编号</p><p>abcloc: str; label位置</p><p>abc[size][color][weight]</p><p>title: str; 标题</p><p>titleloc：str； 标题位置</p><p>title[size][color][weight]</p><mark class="hl-label blue">Axis-sharing</mark> <p>share/sharex/sharey: bool; 是否共享ticklabels，默认‘True’</p><p>span/spanx/spany: bool; 是否共享xlabel/ylabel，默认‘True’</p><hr><p>与matplotlib相似，proplot支同时创建fig和ax，或者先创建fig，再逐步添加ax</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplt <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots()</span><br></pre></td></tr></table></figure><p>需要注意的是，subplots生成的是多个ax, 通过索引axs[0]访问单个ax。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = pplt.figure()</span><br><span class="line">axs = fig.add_subplots()  <span class="comment"># add several subplots</span></span><br><span class="line">ax = fig.add_subplot()  <span class="comment"># add a single subplot</span></span><br><span class="line"><span class="comment"># axs = fig.subplots()  # shorthand</span></span><br><span class="line"><span class="comment"># ax = fig.subplot()  # shorthand</span></span><br></pre></td></tr></table></figure><p>ax继承了matplotlib中ax的方法和属性（大致看了一下，应该是全部都继承了）。fig也是一样。</p><p>因此proplot几乎可以和matplotlib混用，加入投影参数后也继承了cartopy的方法和属性，同样可以实现混用。不同的是，proplot中ax对象分为三种：Cartesian，AxesGeoAxes，PolarAxes。与matplotlib和cartopy中的名称叫法不同。</p><h3 id="子图间隔、宽度、高度">子图间隔、宽度、高度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots(nrows=<span class="number">4</span>, <span class="comment"># 行数</span></span><br><span class="line">                         ncols=<span class="number">4</span>, <span class="comment"># 列数</span></span><br><span class="line">                         wspace=(<span class="string">&#x27;5em&#x27;</span>,<span class="number">3</span>,<span class="literal">None</span>),</span><br><span class="line">                         hspace=(<span class="literal">None</span>,<span class="number">2</span>,<span class="string">&#x27;4em&#x27;</span>),<span class="comment"># 子图之间的间距</span></span><br><span class="line">                         refwidth=<span class="number">3</span>, <span class="comment"># 子图宽度</span></span><br><span class="line">                         refheight=<span class="number">2</span>) <span class="comment"># 子图高度</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ZsaQ.png" alt="" data-align="inline" width="351"><div class="note success simple"><p>space可分为wspace,和hspace，分别控制水平和垂直间隔。同样距离可加单位。</p><p>wspace和hspace可以为单一值，也可为元组形式。为元组时，对子图间两两间距进行设置。</p><p>refwidth提供相对长度和绝对长度，例如refwidth=‘2cm’即宽度2cm。</p></div><h4 id="share参数">share参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots(nrows=<span class="number">2</span>, <span class="comment"># 行数</span></span><br><span class="line">                         ncols=<span class="number">2</span>, <span class="comment"># 列数</span></span><br><span class="line">                        share=<span class="literal">False</span>) <span class="comment"># 取消共享ticklabels</span></span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZcPs.png" title="" alt="" width="341"><div class="note success simple"><p>share参数默认为True，即几个子图共享x，yticklabels。ticklabels只在图下和图左出现。</p><p>share=False取消共享，每个子图都画ticklabels。可分为sharex、sharey</p></div><h4 id="子图划分和图窗边距">子图划分和图窗边距</h4><p>subplots接受一个多维数组或列表，用于划分子图分布。0表示此处不画子图，1表示第一个子图，2表示第二个子图…。根据传入的grid决定子图分布，而不用传入ncols和nrows</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">grid = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line">        [<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>]]</span><br><span class="line">fig, axs = pplt.subplots(grid,</span><br><span class="line">                         bottom=<span class="string">&#x27;5em&#x27;</span>, <span class="comment"># 底边距</span></span><br><span class="line">                         right=<span class="string">&#x27;5em&#x27;</span>) <span class="comment"># 右边距</span></span><br></pre></td></tr></table></figure><img title="" src="[![pp2eKij.md.png](https://s1.ax1x.com/2023/03/30/pp2eKij.md.png)](https://imgse.com/i/pp2eKij)" alt="" width="453"><h3 id="子图编号和标题">子图编号和标题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig = pplt.figure(space=<span class="number">0</span>, refwidth=<span class="string">&#x27;10em&#x27;</span>)</span><br><span class="line">axs = fig.subplots(nrows=<span class="number">3</span>, ncols=<span class="number">3</span>)</span><br><span class="line">axs.<span class="built_in">format</span>(</span><br><span class="line">    abc=<span class="string">&#x27;A.&#x27;</span>, abcloc=<span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">    xticks=<span class="string">&#x27;null&#x27;</span>, yticks=<span class="string">&#x27;null&#x27;</span>, facecolor=<span class="string">&#x27;gray5&#x27;</span>,</span><br><span class="line">    xlabel=<span class="string">&#x27;x axis&#x27;</span>, ylabel=<span class="string">&#x27;y axis&#x27;</span>,</span><br><span class="line">    suptitle=<span class="string">&#x27;A-b-c label offsetting, borders, and boxes&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">axs[:<span class="number">3</span>].<span class="built_in">format</span>(abcloc=<span class="string">&#x27;l&#x27;</span>, titleloc=<span class="string">&#x27;l&#x27;</span>, title=<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">axs[-<span class="number">3</span>:].<span class="built_in">format</span>(abcbbox=<span class="literal">True</span>)  <span class="comment"># also disables abcborder</span></span><br><span class="line"><span class="comment"># axs[:-3].format(abcborder=True)  # this is already the default</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2eYeU.png" alt="" width="319"><h2 id="笛卡尔坐标系">笛卡尔坐标系</h2><h3 id="ticks-and-ticklabels">ticks and ticklabels</h3><p>xlocater/xticks: (1) 直接输入int, 触发<strong>MultipleLocator</strong>，每隔int设置一个tick。</p><p>例xlocater=30</p><p>(2) 直接输入list，触发<strong>FixedLocator</strong>，ticks根据list中的值确定。</p><p>例xlocator=[0, 0.3, 0.8, 1.6, 4.4, 8, 8.8]</p><p>(3) 线性<strong>LinearLocator</strong></p><p>例xlocator=(‘linear’, 21)，根据xlim线性等分，设置21个ticks</p><p>(4) 对数<strong>LogLocator</strong></p><p>例xlocator=‘log’，对数坐标</p><p>(5)最多刻度数<strong>MaxNLocator</strong></p><p>例xlocator=(‘maxn’, 11)</p><p>(6) 无刻度<strong>NullLocator</strong></p><p>例xlocator=‘null’，没有ticks</p><div class="note success simple"><p>图像示例参见官方文档</p><p>ylocater/yticks同理。matplotlib中的Func自定义坐标轴趋势没有测试。即使不能在proplot中实现，将ax单独拎出来可以通过matplotlib实现。</p><p>还有xminorlocator，yminorlocator参数</p><p>此外还有xlim，ylim参数设置上下限。例xlim=(0, 10)</p></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相关命令以及本地文件备份</title>
      <link href="/2022/05/22/test/"/>
      <url>/2022/05/22/test/</url>
      
        <content type="html"><![CDATA[<p>今天为了整博客的图库差点把博客源文件整没了。恢复以后，尝试了很久在github上备份本地博客文件。参考了以下文章：<br><a href="https://blog.csdn.net/weixin_44861399/article/details/104936907">博客备份与换设备</a></p><p>在这里顺便写点hexo相关命令，防止以后忘记了。</p><h5 id="清除和再生成-大概是这个意思吧">清除和再生成 (大概是这个意思吧)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><h5 id="部署至github">部署至github</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h5 id="生成静态地址-本地">生成静态地址(本地)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h5 id="新建文章">新建文章</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h5 id="将静态文件推送到master分支">将静态文件推送到master分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h5 id="将相关更改推送到hexo分支">将相关更改推送到hexo分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;发表文章test&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章！！！O(∩_∩)O哈哈~</title>
      <link href="/2022/05/19/firstblogxhw/"/>
      <url>/2022/05/19/firstblogxhw/</url>
      
        <content type="html"><![CDATA[<h1>第一篇文章！！！</h1><p>这是第一篇文章，测试一下效果</p><p>本博客计划写一些<font color=blue><strong>气象</strong></font>方面的学习经验。如<font color=blue><em><strong>气象编程、学习笔记、文献回顾总结</strong></em></font>。</p><p>另外还有<font color=green><strong>英语学习</strong>。<em>如口语句式、学术论文写作笔记</em></font>。</p><p>最后可能有一些<font color=red><strong>日记性质的文章</strong></font>，记录自己五年读博生涯。</p><p>下面测试一下<mark style="background-color：yellow">markdown</mark></p><h3 id="1-首先是代码块">1. 首先是代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%% 去趋势1979-2020,春、秋季位势高度</span></span><br><span class="line">temp = data2.sel(time=<span class="built_in">slice</span>(<span class="string">&#x27;1979&#x27;</span>,<span class="string">&#x27;2020&#x27;</span>))</span><br><span class="line">hgt500Spring1979_2020Detrend = temp.sel(time=temp[<span class="string">&#x27;time.season&#x27;</span>]==<span class="string">&#x27;MAM&#x27;</span>).mean(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">hgt500Autumn1979_2020Detrend = temp.sel(time=temp[<span class="string">&#x27;time.season&#x27;</span>]==<span class="string">&#x27;SON&#x27;</span>).mean(<span class="string">&#x27;time&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-然后是图片">2. 然后是图片</h3><p><img src="https://s1.ax1x.com/2023/03/30/pp2EaFA.jpg#pic_center" alt="惠"></p><h3 id="3-试一下公式">3. 试一下公式</h3><p>$y={x^2}$<br>$y = {x^2} + 2x - { {\rm{T} }_0} + {\mu ^4}\sqrt { { {\rm{v} }^2} + {b^2} }$</p><p>update test哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/17/hello-world/"/>
      <url>/2022/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
