<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lorenz 能量循环框架推导</title>
      <link href="/2023/04/17/Lorenz-energy/"/>
      <url>/2023/04/17/Lorenz-energy/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>Lorenz大气能量循环框架推导。</p><p>参考文献：</p><ol><li><p>Lorenz, E. N. Available Potential Energy and the Maintenance of the General Circulation. <em>Tellus</em> <strong>7</strong>, 157–167 (1955).</p></li><li><p>大气动力学，刘式适、刘式达，第一版和第二版</p></li><li><p>动力气象学，吕美仲，第一版</p></li></ol><h1>有效位能的定义</h1><p>有效位能是大气全位能与最小全位能之差。</p><p>全位能是位能 $P$ 与内能 $I$ 之和，垂直积分结果为</p><p>$$<br>\begin{align}<br>P + I &amp;= \int_0^{ + \infty } {\rho (gz + {c_v}T)} dz\\<br>&amp;= \int_0^{ + \infty } { - \frac{ {\partial p} }{ {\partial z} }z} dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\(静力平衡)<br>&amp;=  - \int_{ {p_s} }^0 z dp + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;=  - \int_{ {p_s} }^0 z dp + \int_0^{ + \infty } {\rho {c_v}T} dz,\\(分部积分)<br>&amp;=  - [pz]_{ {p_s} }^0 + \int_0^{ + \infty } p dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho RT} dz + \int_0^{ + \infty } {\rho {c_v}T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho (R + {c_v})T} dz\\<br>&amp;= \int_0^{ + \infty } {\rho {c_p}T} dz\\<br>&amp;= \frac{ { {c_p} } }{g}\int_0^{ {p_0} } T dp<br>\end{align}<br>$$</p><p>其中 $ p_s $ 是地面气压，由于 $ T=\theta(\frac{p_{0} }{p})^{-\frac{R}{c_p} } $ 代入公式 (9)</p><p>$$<br>\begin{align}<br>P + I &amp;= \frac{ { {c_p} } }{g}{\int_0^{ {p_s} } {\theta (\frac{ { {p_0} } }{p})} ^{ - \frac{R}{ { {c_p} } } } }dp\\<br>&amp; = \frac{ { {c_p} } }{g}(1 + \frac{R}{ { {c_p} } }){p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } {\theta d{p^{1 + \frac{R}{ { {c_p} } } } } } \\ （分部积分）<br>&amp;= \frac{ { {c_p} } }{g}(1 + \frac{R}{ { {c_p} } }){p_0}^{ - \frac{R}{ { {c_p} } } }([\theta {p^{1 + \frac{R}{ { {c_p} } } } }]_0^{ {p_s} } - \int_0^{ {p_s} } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta } )\\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta }<br>\end{align}<br>$$</p><p>由于定义地表以下$\theta=0$,对$p$的积分范围$\int_0^{ {p_s} }$相当于对$\theta$的积分范围$\int_{+\infty}^{ {0} }$</p><p>那么有效位能可以用大气全位能与大气参考状态的全位能之差来表示</p><p>$$<br>\begin{align}<br>\ A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { {p^{1 + \frac{R}{ { {c_p} } } } }d\theta  - } \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta }<br>\end{align}<br>$$</p><p>$\bar p$  表示等熵参考面上气压的平均值。全球平均（水平平均）有效位能为</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta }<br>\end{align}<br>$$</p><p>取 $p=\bar p + p\prime$</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { {p^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {(\overline {\bar p + p’{)^{1 + \frac{R}{ { {c_p} } } } } - { {\bar p}^{1 + \frac{R}{ { {c_p} } } } } } d\theta } \\<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }({ {(1 + \frac{ {p’} }{ {\bar p} })}^{1 + \frac{R}{ { {c_p} } } } } - 1)d\theta } \\(\frac{\bar p}{p\prime}=0处泰勒展开)<br>&amp;= \frac{ { {c_p} } }{g}{(1 + \frac{R}{ { {c_p} } })^{ - 1} }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } {\overline { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }(1 + \frac{ {(1 + \frac{R}{ { {c_p} } }){ {(1 + 0)}^{\frac{R}{ { {c_p} } } } } } }{ {1!} }(\frac{ {p’} }{ {\bar p} } - 0) + } } \\<br>&amp;\overline { + \frac{ {(1 + \frac{R}{ { {c_p} } })\frac{R}{ { {c_p} } }{ {(1 + 0)}^{\frac{R}{ { {c_p} } } - 1} } } }{ {2!} }{ {(\frac{ {p’} }{ {\bar p} } - 0)}^2} + … - 1)} d\theta \\(保留到2阶，1阶平均为0)<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }{ {(\overline {\frac{ {p’} }{ {\bar p} } } )}^2}d\theta }<br>\end{align}<br>$$</p><p>即</p><p>$$<br>\begin{align}<br>\bar A &amp;=\frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }{ {(\overline {\frac{ {p’} }{ {\bar p} } } )}^2}d\theta }<br>\end{align}<br>$$</p><h2 id="P坐标系下有效位能">P坐标系下有效位能</h2><p>定义 $\bar \theta$, $\theta’$ , $\bar T$, $T’$ 分别是等压面上的均值和偏差。对于等熵面上的气压，近似有 $ p=\bar p(\bar {\theta} ( p ) ) $ 。由此</p><p>$$<br>\begin{align}<br>p’ &amp;= p - \bar p\\<br>&amp;= \bar p(\bar \theta ) - \bar p(\theta )\\<br>&amp;= \bar p(\theta  - \theta ‘) - \bar p(\theta )\\(\bar p(\theta-\theta\prime)在\theta处泰勒展开)<br>&amp;= \bar p(\theta ) + \frac{ {\bar p(\theta )’} }{ {1!} }(\theta  - \theta ’ - \theta ) - \bar p(\theta )\\<br>&amp;=  - \theta '\frac{ {\partial \bar p} }{ {\partial \theta } }<br>\end{align}<br>$$</p><p>公式 (28) 代入 $\overline{(\frac{p’}{\bar p})^2}$ ，并设 $\bar p(\theta)$ 和 $\bar \theta§$ 互为反函数 ($\frac{\partial \bar p }{\theta}=(\frac{\partial \bar \theta }{p})^{-1}$, 动力气象P145)</p><p>$$<br>\begin{align}<br>\overline { { {(\frac{ {p’} }{ {\bar p} })}^2} }  &amp;= \frac{1}{ { { {\bar p}^2} } }\overline { { {(\theta '\frac{ {\partial \bar p} }{ {\partial \theta } })}^2} } \\<br>&amp;= \frac{1}{ { { {\bar p}^2} } }\overline { { {(\theta ')}^2}{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} } }<br>\end{align}<br>$$</p><p>将公式 (30) 代入公式 (23) ，(认为 $d\theta≈\frac{\partial \bar \theta}{\partial p}dp$, 动力气象P145) 得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }\frac{1}{ { { {\bar p}^2} } }\overline { { {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }{ {(\theta ')}^2} } d\theta } \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_{ {p_s} }^0 { { {\bar p}^{\frac{R}{ { {c_p} } } - 1} }{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }\overline { { {(\theta ')}^2} } \frac{ {\partial \bar \theta } }{ {\partial p} }dp} \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } { { {\bar \theta }^2}{ {\bar p}^{\frac{R}{ { {c_p} } } - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } { {( - \frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 1} }dp}<br>\end{align}<br>$$</p><h3 id="位温对气压的偏微分">位温对气压的偏微分</h3><p>由于 $\theta=T(\frac{p_{0} }{p})^{\frac{R}{c_p} }$ 取对数</p><p>$$<br>\begin{align}<br>\ln \theta  = \ln T + \frac{R}{ { {c_p} } }\ln {p_0} - \frac{R}{ { {c_p} } }\ln p<br>\end{align}<br>$$</p><p>对 $p$ 求偏导</p><p>$$<br>\begin{align}<br>\frac{1}{\theta }\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{1}{T}\frac{ {\partial T} }{ {\partial p} } - \frac{R}{ { {c_p}p} }\\<br>\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{\theta }{T}\frac{ {\partial T} }{ {\partial p} } - \frac{R}{ { {c_p} } }\frac{\theta }{p}<br>\end{align}<br>$$</p><p>又</p><p>$$<br>\begin{align}<br>\frac{ {\partial T} }{ {\partial p} } &amp;= \frac{ {\partial T} }{ {\partial z} }\frac{ {\partial z} }{ {\partial p} }\\<br>&amp;=  - \gamma ( - \frac{1}{ {\rho g} })\\<br>&amp;= \gamma \frac{1}{ {\rho g} }<br>\end{align}<br>$$</p><p>其中 $\gamma = -\frac{\partial T}{\partial z}$ 是温度递减率。将公式 (39) 代入公式 (36)</p><p>$$<br>\begin{align}<br>\frac{ {\partial \theta } }{ {\partial p} } &amp;= \frac{\theta }{T}\gamma \frac{1}{ {\rho g} } - \frac{ {gR} }{ {g{c_p} } }\frac{\theta }{p}\\<br>&amp;= \frac{\theta }{ {T\rho g} }\gamma  - \frac{R}{g}\frac{\theta }{p}{\gamma _d}\\<br>&amp;= (\frac{\theta }{ {T\rho g} }\gamma  - \frac{R}{g}\frac{\theta }{p}{\gamma _d})\frac{ {\frac{g}{ { {c_p} } } } }{ { {\gamma _d} } }\\<br>&amp;= \frac{ {\frac{\theta }{p}\frac{R}{ { {c_p} } }(\frac{ {p\gamma } }{ {T\rho R} } - {\gamma _d})} }{ { {\gamma _d} } }\\(状态方程)<br>&amp;=  - \theta {p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \gamma ){\gamma _d}^{ - 1}<br>\end{align}<br>$$</p><p>其中 $\gamma_d = \frac{g}{c_p}$ 是干绝热减温率。做等压面平均得</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar \theta } }{ {\partial p} }= - \bar \theta {\bar p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1}<br>\end{align}<br>$$</p><p>将公式 (45) 代入公式 (33)得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ + \infty } { { {\bar p}^{1 + \frac{R}{ { {c_p} } } } }\frac{1}{ { { {\bar p}^2} } }\overline { { {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }{ {(\theta ')}^2} } d\theta } \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_{ {p_s} }^0 { { {\bar p}^{\frac{R}{ { {c_p} } } - 1} }{ {(\frac{ {\partial \bar \theta } }{ {\partial p} })}^{ - 2} }\overline { { {(\theta ')}^2} } \frac{ {\partial \bar \theta } }{ {\partial p} }dp} \\<br>&amp;= \frac{1}{2}\frac{ { {c_p} } }{g}\frac{R}{ { {c_p} } }{p_0}^{ - \frac{R}{ { {c_p} } } }\int_0^{ {p_s} } { { {\bar \theta }^2}{ {\bar p}^{\frac{R}{ { {c_p} } } - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } \frac{ {\bar p{\gamma _d} } }{ {\bar \theta \frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma )} }dp} \\<br>&amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {\theta '} }{ {\bar \theta } })}^2} } dp}<br>\end{align}<br>$$</p><p>将 $\theta=\bar \theta+\theta’$ 和 $T=\bar T+T’$ 代入公式 (34) 得</p><p>$$<br>\begin{align}<br>\ln (\bar \theta  + \theta ‘) &amp;= \ln (\bar T + T’) + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p)\\<br>\ln \bar \theta (1 + \frac{ {\theta ‘} }{ {\bar \theta } }) &amp;= \ln \bar T(1 + \frac{ {T’} }{ {\bar T} }) + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p),(T’,\theta ’ \ll \bar T,\bar \theta )\\<br>\ln \bar \theta  &amp;= \ln \bar T + \frac{R}{ { {c_p} } }(\ln {p_0} - \ln p)<br>\end{align}<br>$$</p><p>公式 (51) 减公式 (52)得 （大气动力学P128）:</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\ln (1 + \frac{ {\theta ‘} }{ {\bar \theta } }) &amp;= \ln (1 + \frac{ {T’} }{ {\bar T} }),(\frac{ {T’} }{ {\bar T} },\frac{ {\theta '} }{ {\bar \theta } } \ll 1)\\<br>\Rightarrow \frac{ {\theta ‘} }{ {\bar \theta } } &amp;= \frac{ {T’} }{ {\bar T} }<br>\end{align}<br>$$</p><p>将公式 (54) 代入公式 (49) 得</p><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {T’} }{ {\bar T} })}^2} } dp}<br>\end{align}<br>$$</p><h2 id="有效位能倾向">有效位能倾向</h2><p>由熵形式热力学方程 (大气动力学P10)：</p><p>$$<br>\begin{align}<br>{c_p}T\frac{ {d\ln \theta } }{ {dt} } &amp;= Q\\<br>\frac{ {d\ln (\bar \theta  + \theta ‘)} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d\ln \bar \theta (1 + \frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d\ln \bar \theta } }{ {dt} } + \frac{ {d\ln (1 + \frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \omega \frac{ {\partial \ln \bar \theta } }{ {\partial p} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>其中 $Q=\bar Q + Q’$ 是单位质量空气在单位时间内从外界得到的能量，包括分子热传导、辐射、相变等方式。 $\bar Q，Q’$ 分别是 $Q$ 在等压面上的均值和偏差。另外 $\frac{\theta’}{\bar \theta}\ll 1$， $\bar \theta$ 只于垂直坐标有关。$ T’ \ll \bar T$</p><p>由公式 (40)-(44)知，公式 (60) 可进一步变化为</p><p>$$<br>\begin{align}<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \frac{\omega }{ {\bar \theta } }\frac{ {\partial \bar \theta } }{ {\partial p} } &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } + \frac{\omega }{ {\bar \theta } }( - \bar \theta {p^{ - 1} }\frac{R}{ { {c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1}) &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }\\<br>\frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } - \omega \frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>对公式 (60) 两边同乘 $\bar T (\gamma_d-\bar \gamma)^{-1}\frac{\theta’}{\bar \theta}$</p><p>$$<br>\begin{align}<br>\bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } } \cdot \frac{ {d(\frac{ {\theta ‘} }{ {\bar \theta } })} }{ {dt} } - \bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } } \cdot \omega \frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p}\bar T} } \cdot \bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } }\\<br>\frac{1}{2}\bar T{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {d{ {(\frac{ {\theta ‘} }{ {\bar \theta } })}^2} } }{ {dt} } - \bar T\frac{ {\theta ‘} }{ {\bar \theta } }\omega \frac{R}{ {p{c_p} } }{\gamma _d}^{ - 1} &amp;= \frac{ {\bar Q + Q’} }{ { {c_p} } }{({\gamma _d} - \bar \gamma )^{ - 1} }\frac{ {\theta ‘} }{ {\bar \theta } }\\<br>\frac{ {dA} }{ {dt} } - \int_0^{ps} {\bar T\frac{ {T’} }{ {\bar T} }\omega \frac{R}{ {p{c_p} } }\frac{ { {c_p} } }{g} } dp &amp;= \int_0^{ps} {\frac{ {\bar Q + Q’} }{ { {c_p} } }{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\frac{ {T’} }{ {\bar T} } } dp\\<br>\frac{ {dA} }{ {dt} } = \int_0^{ps} {T’\omega \frac{R}{ {pg} } } dp + \int_0^{ps} {\frac{ {(\bar Q + Q’)T’} }{ { {c_p}\bar T} }{ {({\gamma _d} - \bar \gamma )}^{ - 1} } } dp\\<br>\frac{ {\partial \bar A} }{ {\partial t} } = \int_0^{ps} {\overline {T\omega } \frac{R}{ {pg} } } dp + \int_0^{ps} {\frac{ {\overline {Q’T’} } }{ { {c_p}\bar T} }{ {({\gamma _d} - \bar \gamma )}^{ - 1} } } dp\\<br>\frac{ {\partial \bar A} }{ {\partial t} } = \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><blockquote><p>在公式 (65) 到 (66) 的步骤中，等号左边 $\bar T$ 是与垂直坐标有关的，因此严格得来说不能直接放入微分号内凑出 $A$。</p><p>在公式 (67) 到 (68) 的步骤中，等号左边的平流项先转为通量与散度的和的形式，通量在全球积分中为0，散度通过连续方程消去。<code>在等号右边第一项</code> $T’\omega$ <code>本应在水平平均中消去，Lorenz的文章中最终形式是</code> $\overline{T\omega}$ 。<code>不知如何处理</code></p></blockquote><p>因此全球积分的有效位能随时间倾向为</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial \bar A} }{ {\partial t} } &amp;= \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\(状态方程)<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= \int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><p>公式 (72) 就是Lorenz 文章中的有效位能倾向方程。公式 (71) 到公式 (72)有点难理解，但可以反过来推导：</p><p>$$<br>\begin{align}<br>\int_0^{ps} {\overline {V \cdot \nabla z} } dp &amp;= \int_0^{ps} {\overline {\nabla Vz} }  - \overline {z\nabla V} dp\\<br>&amp;=  - \int_0^{ps} {\overline {z\nabla V} } dp\\(连续方程)<br>&amp;= \int_0^{ps} {\overline {z\frac{ {\partial \omega } }{ {\partial p} } } } dp\\<br>&amp;= \int_0^{ps} {\overline z } d\omega \\<br>&amp;= [\overline {z\omega } ]_0^{ps} - \int_0^{ps} {\overline \omega  } dz\\(静力平衡)<br>&amp;=  - \int_0^{ps} {\overline {\omega \frac{1}{ { - \rho g} } } } dp\\<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp<br>\end{align}<br>$$</p><h2 id="纬向平均与扰动有效位能">纬向平均与扰动有效位能</h2><p>将物理量分解为纬向平均 (用 $[m]$ 表示) 与纬向偏差 (用 $m^*$ 表示)</p><p>$$<br>\begin{align}<br>u &amp;= [u] + u^* \\<br>v &amp;= [v] + v^* \\<br>\omega  &amp;= [\omega ] + \omega ^* \\<br>\theta '&amp;= [\theta '] + \theta '^* \\<br>T '&amp;= [T '] + T '^* \\<br>Q '&amp;= [Q '] + Q '^*<br>\end{align}<br>$$</p><p>热力学量 $\theta$ 在前文已经分解为 $\bar \theta + \theta’$ 。其中 $\bar \theta$ 表示水平平均。将公式 (84) 代入公式 (55) (不做水平积分平均)</p><p>$$<br>\begin{align}<br>A=\frac{1}{2}\int_0^{ps} {\bar T{ { ( {\gamma_d} - \bar \gamma ) }^{ - 1} }\frac{ { { {[T’]}^2} + 2[T’]{ {T’}^* } + { { ( { {T’}^* } ) }^2} } }{ { { {\bar T}^2} } } } dp<br>\end{align}<br>$$</p><p>对方程纬向平均</p><p>$$<br>\begin{align}<br>[A] &amp;= \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\frac{ {[{ {T’}^2}] + [{ {({ {T’}^* })}^2}]} }{ { { {\bar T}^2} } } } dp \\<br>&amp;= \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {(\frac{ {[T’]} }{ {\bar T} })}^2} } dp + \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }[{ {(\frac{ { { {T’}^* } } }{ {\bar T} })}^2}]} dp \\<br>&amp;= { { A}_m} + { { A}_p}<br>\end{align}<br>$$</p><p>即<code>有效位能沿纬圈的平均值</code> $[A]$ 可以分解为<code>基本气流的有效位能</code>也称平均有效位能 $A_m$ 与 <code>空气扰动的有效位能</code>也称扰动有效位能 $ A_p$ 。</p><blockquote><p>学术研究中似乎并不是将<code>有效位能纬圈的平均值</code> 进行分解，而是分解<code>有效位能</code>。如果公式 (85) 到 (86) 不进行纬圈平均。那么<code>有效位能</code> 同样可以分解为 <code>平均有效位能</code> 和 <code>扰动有效位能</code>，但会多出一项 $[T’]T’^*$ 。所以学术研究中一般是将这一项忽略掉？</p></blockquote><h2 id="纬向平均与扰动有效位能倾向">纬向平均与扰动有效位能倾向</h2><p>将公式 (80)-(85) 代入公式 (63)</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial t} } + ([u] + {u^* })\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial x} } + ([v] + {v^* })\frac{ {\partial (\frac{ {[\theta '] + { {\theta '}^* } } }{ {\bar \theta } })} }{ {\partial y} } +… \\<br>…+ ([\omega ] + {\omega ^* })\frac{ {\partial (\frac{ {[\theta ‘] + { {\theta ‘}^* } } }{ {\bar \theta } })} }{ {\partial p} } - ([\omega ] + {\omega ^* })\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’] + { {Q’}^* } } }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>利用连续方程将 $\frac{\partial}{\partial x}$ $\frac{\partial}{\partial y}$, $\frac{\partial}{\partial p}$ 项写为通量减散度的形式，利用连续方程消去散度项, 并对方程纬向平均</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial t} } + \frac{ {\partial ([v]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial y} } + \frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial p} } + \frac{ {\partial ([{\omega ^* }\frac{ { { {\theta ‘}^* } } }{ {\bar \theta } }])} }{ {\partial p} } - [\omega ]\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’]} }{ { {c_p}\bar T} }<br>\end{align}<br>$$</p><p>方程两边同乘 $\frac{\bar T}{\gamma_d-\gamma} \frac{[\theta’]}{\bar \theta}$ 。</p><p>$$<br>\begin{align}<br>\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial (\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial t} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([v]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial y} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([\omega ]\frac{ {[\theta ']} }{ {\bar \theta } })} }{ {\partial p} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{\omega ^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial p} } + …\\<br>… - \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ {\bar \theta } }[\omega ]\frac{R}{ {p{c_p} } }({\gamma _d} - \bar \gamma ){\gamma _d}^{ - 1} = \frac{ {\bar Q + [Q’]} }{ { {c_p}\bar T} }\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }<br>\end{align}<br>$$</p><p>整理且代入公式 (54) $\frac{ {\theta ‘} }{ {\bar \theta } } = \frac{ {T’} }{ {\bar T} }$</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial t} } + \frac{ {\partial ([v]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial y} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ {\bar \theta } }\frac{ {\partial ([{v^* }\frac{ { { {\theta '}^* } } }{ {\bar \theta } }])} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial p} } + \frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ {\bar \theta } }\frac{ {\partial ([{\omega ^* }\frac{ { { {\theta ‘}^* } } }{ {\bar \theta } }])} }{ {\partial p} } + …\\<br>… - [T’][\omega ]\frac{R}{ {pg} } = \frac{ {(\bar Q + [Q’])[\theta ']} }{ { {c_p}\bar \theta} }\frac{1}{ { {\gamma _d} - \gamma } }<br>\end{align}<br>$$</p><p>将上式第三项和第五项写为通量减散度的形式, 且代入公式 (54) $\frac{ {\theta ‘} }{ {\bar \theta } } = \frac{ {T’} }{ {\bar T} }$</p><p>$$<br>\begin{align}<br>\frac{ {\partial (\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial t} } + \frac{ {\partial ([v]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial y} } + \frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } }[{v^* }{ {\theta '}^* }])} }{ {\partial y} } - [{v^* }{ {\theta '}^* }]\frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } })} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\omega ]\frac{1}{2}\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }{ {(\frac{ {[\theta ']} }{ {\bar \theta } })}^2})} }{ {\partial p} } + \frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ']} }{ { { {\bar \theta }^2} } }[{\omega ^* }{ {\theta ‘}^* }])} }{ {\partial p} } - [{\omega ^* }{ {\theta ‘}^* }]\frac{ {\partial (\frac{ {\bar T} }{ { {\gamma _d} - \gamma } }\frac{ {[\theta ‘]} }{ { { {\bar \theta }^2} } })} }{ {\partial p} } + …\\<br>… - [T’][\omega ]\frac{R}{ {pg} } = \frac{ {(\bar Q + [Q’])[T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \gamma } }<br>\end{align}<br>$$</p><p>$\int_0^{ps}{dp}$ 垂直积分且水平积分(平均)得</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp - \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp = \int_0^{ps} {\overline {\frac{ {[Q’][T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \bar \gamma } } } } dp\\<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } = \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp + \int_0^{ps} {\overline {\frac{ {[Q’][T’]} }{ { {c_p}\bar T} }\frac{1}{ { {\gamma _d} - \bar \gamma } } } } dp<br>\end{align}<br>$$</p><blockquote><p>上式的 $[T’][\omega]$ 在Lorenz的文章中写为 $[T][\omega]$。也不知道是哪里出了问题，还是用了什么近似。</p></blockquote><p>将公式 (80)-(85) 代入公式 (70) （不做水平积分)</p><p>$$<br>\begin{align}<br>\frac{ {\partial A} }{ {\partial t} } = \int_0^{ps} {\frac{R}{ {gp} } } ([T] + {T^* })([\omega ] + {\omega ^* })dp + …\\<br>… + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’] + { {Q’}^* })([T’] + { {T’}^* })}dp<br>\end{align}<br>$$</p><p>纬向平均结合公式 (89) 得</p><p>$$<br>\begin{align}<br>\frac{ {\partial [A]} }{ {\partial t} } &amp;= \int_0^{ps} {\frac{R}{ {gp} } } ([T][\omega ] + [{T^* }{\omega ^* }])dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’][T’] + [{ {Q’}^* }{ {T’}^* }])} dp\\<br>\frac{ {\partial {A_m} } }{ {\partial t} } + \frac{ {\partial {A_p} } }{ {\partial t} } &amp;= \int_0^{ps} {\frac{R}{ {gp} } } ([T][\omega ] + [{T^* }{\omega ^* }])dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }([Q’][T’] + [{ {Q’}^* }{ {T’}^* }])} dp<br>\end{align}<br>$$</p><p>用公式 (108) 减公式 (104) (公式104做了全球平均，即使不做全球平均，相减后再平均也能消去通量项)</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_p} } }{ {\partial t} } =  - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \overline \gamma  ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \overline \gamma  ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[{ {Q’}^* }{ {T’}^* }]} } dp<br>\end{align}<br>$$</p><h2 id="有效位能小节">有效位能小节</h2><ul><li>有效位能表达式（同公式55）</li></ul><p>$$<br>\begin{align}<br>\bar A &amp;= \frac{1}{2}\int_0^{ {p_s} } {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }\overline { { {(\frac{ {T’} }{ {\bar T} })}^2} } dp}<br>\end{align}<br>$$</p><ul><li>有效位能时间倾向（同公式70-72）</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial \bar A} }{ {\partial t} } &amp;= \frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp\\<br>&amp;= \int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }\overline {Q’T’} } dp<br>\end{align}<br>$$</p><ul><li>纬向平均有效位能和扰动有效位能（同公式88）</li></ul><p>$$<br>\begin{align}<br>{ { A}_m} = \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {(\frac{ {[T’]} }{ {\bar T} })}^2} } dp\\<br>{ { A}_p} = \frac{1}{2}\int_0^{ps} {\bar T{ {({\gamma _d} - \bar \gamma )}^{ - 1} }[{ {(\frac{ { { {T’}^* } } }{ {\bar T} })}^2}]} dp<br>\end{align}<br>$$</p><ul><li>纬向平均有效位能和扰动有效位能时间倾向 （同公式104、109）</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar A}_m} } }{ {\partial t} } = \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[Q’][T’]} } dp\\<br>\frac{ {\partial { {\bar A}_p} } }{ {\partial t} } =  - \int_0^{ps} {\overline {\frac{ {\bar T[{v^* }{ {\theta '}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta '])} }{ {\partial y} } } } dp - \int_0^{ps} {\overline {\frac{ {\bar T[{\omega ^* }{ {\theta ‘}^* }]} }{ {({\gamma _d} - \bar \gamma ){ {\bar \theta }^2} } }\frac{ {\partial ([\theta ‘])} }{ {\partial p} } } } dp + …\\<br>… + \int_0^{ps} {\overline {\frac{R}{ {pg} }[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline { {\gamma _d}{ {({\gamma _d} - \bar \gamma )}^{ - 1} }{ {\bar T}^{ - 1} }[{ {Q’}^* }{ {T’}^* }]} } dp<br>\end{align}<br>$$</p><blockquote><p>上式与大气动力学P469等价</p></blockquote><hr><h1>动能的定义</h1><p>在某个气压层上单位质量空气的动能是</p><p>$$<br>\begin{align}<br>K = \frac{1}{2}({u^2} + {v^2}) = \frac{1}{2}{\vec V^2}<br>\end{align}<br>$$</p><p>对于单位面积上整层大气的动能为</p><p>$$<br>\begin{align}<br>K &amp;= \int_0^{ + \infty } {\frac{1}{2}\rho { {\vec V}^2} } dz\\<br>&amp;= \int_{ps}^0 {\frac{1}{2}\rho { {\vec V}^2} } ( - \frac{1}{ {\rho g} })dp\\<br>&amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {\vec V}^2} } dp<br>\end{align}<br>$$</p><p>对于全球积分(平均)的动能为 $\bar K= \frac{1}{2}{g^{ - 1} }\int_0^{ps} \overline { { {\vec V}^2} } dp$</p><h2 id="动能时间倾向">动能时间倾向</h2><p>对于二维动量方程</p><p>$$<br>\begin{align}<br>\frac{ {d\vec V} }{ {dt} } + \omega \frac{ {\partial \vec V} }{ {\partial p} } =  - f\vec k \times \vec V - \nabla \Phi  + \vec F<br>\end{align}<br>$$</p><p>其中 $\frac{d}{dt}=\frac{\partial}{\partial t}+u\frac{\partial}{\partial x}+v\frac{\partial}{\partial y}$ ，$f$ 是科氏参数，$\vec F$ 是水平摩擦力，$\phi$ 是位势</p><p>对公式 (125) 两边同乘 $\frac{1}{g}\vec V$ , 结合连续方程有</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{1}{g}\vec V\frac{ {d\vec V} }{ {dt} } + \frac{1}{g}\vec V\omega \frac{ {\partial \vec V} }{ {\partial p} } = \frac{1}{g}\vec V \cdot ( - f\vec k \times \vec V) - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{1}{g}\vec V\frac{ {\partial \vec V} }{ {\partial t} } + \frac{1}{g}\vec Vu\frac{ {\partial \vec V} }{ {\partial x} } + \frac{1}{g}\vec Vv\frac{ {\partial \vec V} }{ {\partial y} } + \frac{1}{g}\vec V\omega \frac{ {\partial \vec V} }{ {\partial p} } &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + u\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial x} } + v\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial y} } + \omega \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial p} } &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } - \frac{1}{ {2g} }{ {\vec V}^2}(\frac{ {\partial u} }{ {\partial x} } + \frac{ {\partial v} }{ {\partial y} } + \frac{ {\partial \omega } }{ {\partial p} }) &amp;=  - \frac{1}{g}\vec V \cdot \nabla \Phi  + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } &amp;=  - \frac{1}{g}\nabla (\vec V\Phi ) + \frac{1}{g}\Phi \nabla  \cdot \vec V + \frac{1}{g}\vec V \cdot \vec F\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}u} }{ {\partial x} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}v} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {\vec V}^2}\omega } }{ {\partial p} } &amp;=  - \frac{1}{g}\nabla (\vec V\Phi ) - \frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } + \frac{1}{g}\vec V \cdot \vec F<br>\end{align}<br>$$</p><p>对公式 (131)做全球积分</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \int_0^{ps} {\frac{1}{g}\nabla (\vec V\Phi )} dp - \int_0^{ps} {\frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \int_0^{ps} {\frac{1}{g}\Phi \frac{ {\partial \omega } }{ {\partial p} } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - \frac{1}{g}\int_0^{ps} {\frac{ {\partial \omega \Phi } }{ {\partial p} }dp + \frac{1}{g}\int_0^{ps} {\omega \frac{ {\partial \Phi } }{ {\partial p} } } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;= \frac{1}{g}\int_0^{ps} {\omega \frac{1}{ { - \rho } } } dp + \int_0^{ps} {\frac{1}{g}\vec V \cdot \vec F} dp\\<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><blockquote><p>在公式 (69) 中将 $T’$ 换为了 $T$ 。如果不换的话就不能与动能倾向公式 (136) 相对应，有点难理解。公式 (69) 的推导过程可能还存在一些问题</p></blockquote><p>即动能时间倾向为 (类比公式 (70)-(79))</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><h2 id="纬向平均与扰动动能定义">纬向平均与扰动动能定义</h2><p>将公式 (80) 和 (81) 代入公式 (124)，并纬向平均</p><p>$$<br>\begin{align}<br>K &amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} + 2[\vec V] \cdot { {\vec V}^* } + { {\vec V}^* }^2} dp\\<br>(纬向平均)[K] &amp;= \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} } dp + \frac{1}{2}{g^{ - 1} }\int_0^{ps} {[{ {\vec V}^* }^2]} dp\\<br>&amp;= {K_m} + {K_p}<br>\end{align}<br>$$</p><p>即<code>动能沿纬圈的平均值</code> $[K]$ 可以分解为<code>基本气流的动能</code>也称平均动能 $K_m$ 与 <code>空气扰动的动能</code>也称扰动动能  $K_p$ 。其中</p><p>$[\vec V]^2=[u]^2+[v]^2 $，$[\vec V^* ]^2=[{u^{* } }^2+{v^* }^2]$</p><h2 id="纬向平均与扰动动能倾向">纬向平均与扰动动能倾向</h2><p>将公式 (125) 写为通量减散度的形式，并代入连续方程化简</p><p>$$<br>\begin{align}<br>\frac{ {\partial \vec V} }{ {\partial t} } + \frac{ {\partial \vec Vu} }{ {\partial x} } + \frac{ {\partial \vec Vv} }{ {\partial y} } + \frac{ {\partial \vec V\omega } }{ {\partial p} } - \vec V \cdot (\frac{ {\partial u} }{ {\partial x} } + \frac{ {\partial v} }{ {\partial y} } + \frac{ {\partial \omega } }{ {\partial p} }) =  - f\vec k \times \vec V - \nabla \Phi  + \vec F\\<br>\frac{ {\partial \vec V} }{ {\partial t} } + \frac{ {\partial \vec Vu} }{ {\partial x} } + \frac{ {\partial \vec Vv} }{ {\partial y} } + \frac{ {\partial \vec V\omega } }{ {\partial p} } =  - f\vec k \times \vec V - \nabla \Phi  + \vec F<br>\end{align}<br>$$</p><p>将公式 (80)-(82) 以及 $\Phi=[\Phi]+\Phi^* $，$\vec F=[\vec F]+\vec F^* $  代入公式 (144)</p><div style="page-break-after: always;"></div><p>$$<br>\begin{align}<br>\frac{ {\partial [\vec V] + { {\vec V}^* } } }{ {\partial t} } + \frac{ {\partial ([\vec V] + { {\vec V}^* })([u] + {u^* })} }{ {\partial x} } + \frac{ {\partial ([\vec V] + { {\vec V}^* })([v] + {v^* })} }{ {\partial y} } + …\\<br>… + \frac{ {\partial ([\vec V] + { {\vec V}^* })([\omega ] + {\omega ^* })} }{ {\partial p} } =  - f\vec k \times ([\vec V] + { {\vec V}^* }) - \nabla ([\Phi ] + {\Phi ^* }) + [\vec F] + { {\vec F}^* }<br>\end{align}<br>$$</p><p>纬向平均得</p><p>$$<br>\begin{align}<br>\frac{ {\partial [\vec V]} }{ {\partial t} } + \frac{ {\partial [\vec V][v]} }{ {\partial y} } + \frac{ {\partial [\vec V][\omega ]} }{ {\partial p} } + …\\<br>… + \frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } =  - f\vec k \times [\vec V] - \nabla [\Phi ] + [\vec F]<br>\end{align}<br>$$</p><p>方程两边同乘 $\frac{1}{g}[\vec V]$</p><p>$$<br>\begin{align}<br>\frac{1}{g}[\vec V]\frac{ {\partial [\vec V]} }{ {\partial t} } +  + \frac{1}{g}[\vec V]\frac{ {\partial [\vec V][v]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [\vec V][\omega ]} }{ {\partial p} } + …\\<br>… + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } = \frac{1}{g}[\vec V]( - f\vec k \times [\vec V]) + …\\<br>… - \frac{1}{g}[\vec V] \cdot \nabla [\Phi ] + \frac{1}{g}[\vec V][\vec F]\\<br>\frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2} } }{ {\partial t} } + \frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2}[v]} }{ {\partial y} } + \frac{ {\partial \frac{1}{ {2g} }{ {[\vec V]}^2}[\omega ]} }{ {\partial p} } + …\\<br>… + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } + \frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } =  - \frac{1}{g}[\vec V] \cdot \nabla [\Phi ] + \frac{1}{g}[\vec V][\vec F]<br>\end{align}<br>$$</p><p>公式 (152) 中 $[\vec V]$ 放进了 $\frac{\partial}{\partial x}$，$\frac{\partial}{\partial y}$ 内部。结合连续方程，这步是正确的。</p><p>对公式 (152)-(153) 全球积分</p><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K_m} }{ {\partial t} } + \int_0^{ps} {\overline {\frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{v^* }]} }{ {\partial y} } } } dp + \int_0^{ps} {\overline {\frac{1}{g}[\vec V]\frac{ {\partial [{ {\vec V}^* }{\omega ^* }]} }{ {\partial p} } } } dp =  - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial \bar K_m} }{ {\partial t} } - \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp =  - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial \bar K_m} }{ {\partial t} } = \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + \frac{1}{g}\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \frac{1}{g}\int_0^{ps} {\overline {[\vec V] \cdot \nabla [\Phi ]} } dp + \frac{1}{g}\int_0^{ps} {\overline {[\vec V][\vec F]} } dp<br>\end{align}<br>$$</p><blockquote><p>公式 (154) 的平流部分写成了通量减散度形式，结合连续方程得到公式 (155)</p></blockquote><p>公式 (156) 右边第三项参考 公式 (132)-(136) 过程进行化简，得到纬向平均动能时间倾向方程</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } = {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[\omega ][\alpha ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>= {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp<br>\end{align}<br>$$</p><p>对于公式 (138) 做水平平均之前，用 $T=[T]+T^* $，$\vec F=[\vec F]+\vec F^* $ ，$\vec V=[\vec V]+\vec V^* $，$\omega=[\omega]+\omega^* $ 代入 (之后再水平平均仍能消去通量项), 结合公式 (142)</p><p>$$<br>\begin{align}<br>\frac{ {\partial K} }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T] + {T^* })([\omega ] + {\omega ^* })} dp + {g^{ - 1} }\int_0^{ps} {([\vec V] + { {\vec V}^* })([\vec F] + { {\vec F}^* })} dp\\(纬向平均)<br>\frac{ {\partial [K]} }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T][\omega ] + [{T^* }{\omega ^* }])} dp + {g^{ - 1} }\int_0^{ps} {([\vec V][\vec F] + [{ {\vec V}^* }{ {\vec F}^* }])} dp\\<br>\frac{ {\partial {K_m} } }{ {\partial t} } + \frac{ {\partial {K_p} } }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }([T][\omega ] + [{T^* }{\omega ^* }])} dp + {g^{ - 1} }\int_0^{ps} {([\vec V][\vec F] + [{ {\vec V}^* }{ {\vec F}^* }])} dp\\(水平平均)<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } + \frac{ {\partial { {\bar K}_p} } }{ {\partial t} } =  - \frac{R}{g}\int_0^{ps} { {p^{ - 1} }(\overline {[T][\omega ]}  + \overline {[{T^* }{\omega ^* }]} )} dp + {g^{ - 1} }\int_0^{ps} {(\overline {[\vec V][\vec F]}  + \overline {[{ {\vec V}^* }{ {\vec F}^* }]} )} dp<br>\end{align}<br>$$</p><p>用公式 (162) 减公式 (156)得扰动动能时间倾向方程</p><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_p} } }{ {\partial t} } =  - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{ {\vec F}^* }]} } dp<br>\end{align}<br>$$</p><h2 id="动能小节">动能小节</h2><ul><li>动能表达式 (同公式124)</li></ul><p>$$<br>\begin{align}<br>\bar K = \frac{1}{2}{g^{ - 1} }\int_0^{ps} \overline { { {\vec V}^2} } dp<br>\end{align}<br>$$</p><ul><li>有效位能时间倾向 (同公式137-139)</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial \bar K} }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {\omega \alpha } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\frac{R}{g}\int_0^{ps} { {p^{ - 1} }\overline {T\omega } } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp\\<br>&amp;= -\int_0^{ps} {\overline {V \cdot \nabla z} } dp + {g^{ - 1} }\int_0^{ps} {\overline {\vec V \cdot \vec F} } dp<br>\end{align}<br>$$</p><ul><li>纬向平均动能和扰动动能 (同公式141-142)</li></ul><p>$$<br>\begin{align}<br>{K_m} = \frac{1}{2}{g^{ - 1} }\int_0^{ps} { { {[\vec V]}^2} } dp\\<br>{K_p} = \frac{1}{2}{g^{ - 1} }\int_0^{ps} {[{ {\vec V}^* }^2]} dp<br>\end{align}<br>$$</p><ul><li>纬向平均动能和扰动动能时间倾向 (公式158、163)</li></ul><p>$$<br>\begin{align}<br>\frac{ {\partial { {\bar K}_m} } }{ {\partial t} } &amp;= {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[T][\omega ]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[\vec V][\vec F]} } dp\\<br>\frac{ {\partial { {\bar K}_p} } }{ {\partial t} } &amp;=  - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{v^* }]\frac{ {\partial [\vec V]} }{ {\partial y} } } } dp - {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{\omega ^* }]\frac{ {\partial [\vec V]} }{ {\partial p} } } } dp - \int_0^{ps} {\frac{R}{ {pg} }\overline {[{T^* }{\omega ^* }]} } dp + {g^{ - 1} }\int_0^{ps} {\overline {[{ {\vec V}^* }{ {\vec F}^* }]} } dp<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 大气数学理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学推导 </tag>
            
            <tag> 大气理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seasonalCycle</title>
      <link href="/2023/04/03/seasonalCycle/"/>
      <url>/2023/04/03/seasonalCycle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cartopy 调用&quot;天地图&quot;底图</title>
      <link href="/2023/03/16/cartopyAPI/"/>
      <url>/2023/03/16/cartopyAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-2">前言</h2><p>科研绘图上地图底图一般是白色的，加上海岸线也就成底图。这种做法的好处是如果我们需要向底图上添加等值线、填色图等附有彩色信息的图案或线条，这种信息在白底下更突出。作为可以绘图，这种白底也最简单、严肃。</p><p>但是如果我们要画出某个台风的移动路径，偌大的白图上就横躺这几根线条略显单调。这时如果能丰富底图，整张图的效果会有很大提升。</p><p>使用这种底图需要调用其他网站的地图接口，让图像叠加在<code>Cartopy</code>的坐标轴内。</p><h2 id="Cartopy无网络底图">Cartopy无网络底图</h2><p><code>Cartopy</code>内置了一种底图 <code>ax.stock_img()</code>，不需要利用网络接口。缺点就是分辨率很差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.gridliner <span class="keyword">import</span> LONGITUDE_FORMATTER, LATITUDE_FORMATTER</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lon = np.array([<span class="number">126.4</span>, <span class="number">126.1</span>, <span class="number">125.9</span>, <span class="number">125.6</span>, <span class="number">125.2</span>, <span class="number">124.8</span>, <span class="number">124.5</span>, <span class="number">124.1</span>, <span class="number">123.7</span>,</span><br><span class="line">       <span class="number">123.4</span>, <span class="number">123.3</span>, <span class="number">123.5</span>, <span class="number">123.5</span>, <span class="number">123.5</span>, <span class="number">123.4</span>, <span class="number">123.</span> , <span class="number">122.6</span>, <span class="number">122.1</span>,</span><br><span class="line">       <span class="number">121.5</span>, <span class="number">121.2</span>, <span class="number">120.6</span>, <span class="number">119.8</span>, <span class="number">119.8</span>, <span class="number">120.1</span>, <span class="number">120.5</span>, <span class="number">120.8</span>, <span class="number">121.3</span>,</span><br><span class="line">       <span class="number">122.6</span>, <span class="number">123.7</span>, <span class="number">125.5</span>, <span class="number">126.3</span>, <span class="number">127.6</span>, <span class="number">130.1</span>, <span class="number">131.3</span>, <span class="number">132.3</span>, <span class="number">133.3</span>,</span><br><span class="line">       <span class="number">134.6</span>, <span class="number">136.2</span>, <span class="number">137.6</span>, <span class="number">139.4</span>])</span><br><span class="line"></span><br><span class="line">lat = np.array([<span class="number">20.1</span>, <span class="number">20.2</span>, <span class="number">20.1</span>, <span class="number">19.8</span>, <span class="number">19.3</span>, <span class="number">18.7</span>, <span class="number">18.5</span>, <span class="number">18.3</span>, <span class="number">18.1</span>, <span class="number">18.</span> , <span class="number">18.1</span>,</span><br><span class="line">       <span class="number">18.6</span>, <span class="number">19.3</span>, <span class="number">20.3</span>, <span class="number">21.2</span>, <span class="number">22.4</span>, <span class="number">23.2</span>, <span class="number">24.1</span>, <span class="number">24.7</span>, <span class="number">25.2</span>, <span class="number">26.1</span>, <span class="number">26.8</span>,</span><br><span class="line">       <span class="number">27.3</span>, <span class="number">28.1</span>, <span class="number">29.4</span>, <span class="number">31.4</span>, <span class="number">33.</span> , <span class="number">33.8</span>, <span class="number">35.2</span>, <span class="number">37.6</span>, <span class="number">38.4</span>, <span class="number">39.1</span>, <span class="number">40.1</span>,</span><br><span class="line">       <span class="number">41.</span> , <span class="number">42.</span> , <span class="number">42.7</span>, <span class="number">43.3</span>, <span class="number">44.1</span>, <span class="number">44.6</span>, <span class="number">45.</span> ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#%% 定义绘图函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMap</span>(<span class="params">proj=ccrs.PlateCarree(<span class="params"></span>), extent=[<span class="number">100</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">60</span>]</span>):</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">    proj = ccrs.PlateCarree()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>, projection=proj)</span><br><span class="line">    ax.set_extent(extent, crs=ccrs.PlateCarree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加刻度</span></span><br><span class="line">    lon_lat = ax.gridlines(draw_labels=<span class="literal">True</span>, linewidth=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.2</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">    lon_lat.xlabels_top = <span class="literal">False</span></span><br><span class="line">    lon_lat.ylabels_right = <span class="literal">False</span> </span><br><span class="line">    lon_lat.xformatter = LONGITUDE_FORMATTER </span><br><span class="line">    lon_lat.yformatter = LATITUDE_FORMATTER</span><br><span class="line">    <span class="keyword">return</span> fig, ax </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig1, ax1 = getMap()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加底图</span></span><br><span class="line">ax1.stock_img()</span><br><span class="line">ax1.plot(lon, lat, <span class="string">&#x27;.-r&#x27;</span>,transform=ccrs.PlateCarree())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Aoad.png" title="" alt="" data-align="center"><h2 id="Cartopy-连接国外API">Cartopy 连接国外API</h2><p>暂时连不上，以后再码</p><p><a href="https://scitools.org.uk/cartopy/docs/latest/gallery/web_services/index.html">Web services — cartopy 0.21.0 documentation</a></p><h2 id="Cartopy-理解国内”天地图“网站API">Cartopy 理解国内”天地图“网站API</h2><h3 id="第一步：修改Cartopy文件">第一步：修改Cartopy文件</h3><p>安装好Cartopy后，修改以下文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda3\envs\你的虚拟环境名称\Lib\site-packages\cartopy\io\img_tiles.py</span><br></pre></td></tr></table></figure><p>如果用的是base环境，路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda3\Lib\site-packages\cartopy\io\img_tiles.py</span><br></pre></td></tr></table></figure><p>在<code>imh_tiles.py</code>文件末尾添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 天地图矢量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_vec</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=vec_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 天地图遥感</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_img</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=img_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 天地图地形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDT_ter</span>(<span class="title class_ inherited__">GoogleWTS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_image_url</span>(<span class="params">self, tile</span>):</span><br><span class="line">        x, y, z = tile</span><br><span class="line">        key = <span class="string">&#x27;f51d7378813e172b83c8edc7ddedb1c9&#x27;</span></span><br><span class="line">        url = <span class="string">&#x27;http://t0.tianditu.gov.cn/DataServer?T=ter_w&amp;x=%s&amp;y=%s&amp;l=%s&amp;tk=%s&#x27;</span> % (x, y, z, key)</span><br><span class="line">        <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><h3 id="第二部：申请“天地图”密钥">第二部：申请“天地图”密钥</h3><p>在网站 <a href="http://lbs.tianditu.gov.cn/server/MapService.html">天地图API</a> 注册登陆账号。申请密钥：</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2Avqg.png" alt="" data-align="center" width="358"><p>点击“创建新应用”，内容随便填写</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EFzV.png" alt="" data-align="center" width="440"><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EEsU.png" alt="" data-align="center" width="337"><p>然后就得到密钥了：</p><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EeZ4.png" alt="" data-align="center" width="477"><p>如果不想申请密钥，可以用我以前的密钥，就是<code>imh_tiles.py</code>中已经填好的，key = ‘f51d7378813e172b83c8edc7ddedb1c9’。但是这个申请的不知道什么时候可能会失效。</p><blockquote><p>个人申请的密钥一天调用上限是1万次。如果程序运行遇到网络问题、被禁止访问时，程序会不停地调用这个接口，很容易超过1万次。所以遇到报错要及时手动停止程序。</p></blockquote><h3 id="第三步：程序使用，绘图程序">第三步：程序使用，绘图程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cartopy.io.img_tiles <span class="keyword">as</span> cimgt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMap</span>(<span class="params">nrows=<span class="number">1</span>, ncols=<span class="number">1</span>, proj=ccrs.PlateCarree(<span class="params"></span>), extent=[<span class="number">100</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">60</span>]</span>):</span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(nrows, ncols, subplot_kw=<span class="built_in">dict</span>(projection=proj),figsize=(<span class="number">36</span>,<span class="number">12</span>))</span><br><span class="line">    <span class="keyword">for</span> axx <span class="keyword">in</span> ax:</span><br><span class="line">        axx.set_extent(extent, crs=ccrs.PlateCarree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加刻度</span></span><br><span class="line">        lon_lat = axx.gridlines(draw_labels=<span class="literal">True</span>, linewidth=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.2</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">        lon_lat.xlabels_top = <span class="literal">False</span></span><br><span class="line">        lon_lat.ylabels_right = <span class="literal">False</span> </span><br><span class="line">        lon_lat.xformatter = LONGITUDE_FORMATTER </span><br><span class="line">        lon_lat.yformatter = LATITUDE_FORMATTER</span><br><span class="line">    <span class="keyword">return</span> fig, ax </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig3, ax3 = getMap(nrows=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用天地图</span></span><br><span class="line">a = cimgt.TDT_vec() <span class="comment"># 矢量图</span></span><br><span class="line">b = cimgt.TDT_img() <span class="comment"># 影像图</span></span><br><span class="line">c = cimgt.TDT_ter() <span class="comment"># 地形图</span></span><br><span class="line"></span><br><span class="line">ax3[<span class="number">0</span>].add_image(a, <span class="number">4</span>) <span class="comment"># 数字4表示第四图层。1-9数字越高清晰度越好，但程序花费时间越多</span></span><br><span class="line">ax3[<span class="number">1</span>].add_image(b, <span class="number">4</span>)</span><br><span class="line">ax3[<span class="number">2</span>].add_image(c, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    ax3[i].plot(lon, lat, <span class="string">&#x27;.-r&#x27;</span>,transform=ccrs.PlateCarree())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2EmdJ.png" title="" alt="" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cartopy调用地图底图AIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lanczos 滤波</title>
      <link href="/2023/02/10/Lanczos/"/>
      <url>/2023/02/10/Lanczos/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在使用上一篇讲述的傅里叶滤波作出一些结果后，王老师建议我换一下其他滤波方法试一下。我注意到文献中使用 Lanczos 和 Butterworth 滤波方法较多，所以打算研究一下这类滤波方法。</p><p>本文参考的文献有：</p><p>《Data Analysis Methods in Physical Oceanography, Third Edition》</p><p>《lanczos filtering in one and two dimensions》</p><p>《气候变率诊断和预测方法》</p><hr><h2 id="Lanczos-滤波">Lanczos 滤波</h2><p>Lanczos滤波的本质是对时间长度为 $N$ 的原时间序列 $x(n)$ 的各个点进行加权，形成新的序列 $y(n)$。即</p><p>$$<br>\begin{equation}<br>{y_n} = \sum\limits_{k =  - M}^M { {w_k} x_{n - k} } {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} ,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} n = 0,1,…,N - 1<br>\end{equation}<br>$$</p><p>其中 $w_{k}$ 即是权重。$M$ 表征权重点的个数 ($2M+1$个)，它是根据需要自己定义的， $M$ <code>越大滤波的效果越好，但损失的数据越多</code>。</p><ul><li><p><strong>为什么会损失数据？</strong></p><p>公式 (1) 中 $n$ 最大是N-1, 最小是0。然而 $x$ 的小标为 $n-k$ 。当 $n=0, k=M$ 时，$ x_{n-k}=x_{-M} $ , 然而 $x$ 的索引不可能取到负数。因此 $n=0$ 这个点无法通过公式计算出新序列。同样的 $n=0,1,…M-1$ 和 $n=N-M,…,N-1$ 都无法通过公式计算得到新序列值。新序列会比原序列在左端少 $M$ 个，在右端少 $M$ 个，共少 $2M$ 个。(类似于5点滑动平均，左端和右端会各少2个点)。</p><p>以上损失数据的情况在NCL的函数 <code>filwgts_lanczos</code> 体现出来。 然而，在我自己进行编程计算的时候发现，如果把原序列看做周期为其自身长度的周期信号，即 $x_{0} = x_{N}, x_{-1}=x_{N-1}$ （傅里叶变换中也用了相似的思想）。这样计算就不会产生数据损失，在序列两端的滤波结果仍具有很好的准确性 (将在下面的程序试验中验证)。</p></li></ul><p>如果 $M=4, w_{k}=\frac{1}{2M+1}=\frac{1}{9}$, 那么公式 (1) 变为</p><p>$$<br>\begin{equation}<br>{y_n} = \frac{1}{9}\sum\limits_{k = - 4}^4 { {x_{n - k} } }<br>\end{equation}<br>$$</p><p>这就是九点滑动平均公式，它是一种低通滤波，过滤掉周期小于9年的信号。在这里权重被设为常数 $\frac{1}{9}$ 。一旦权重 $w_{k}$ 被确定下来，那么这个滤波也就完成了。因此Lanczos滤波就是要找到一个合适权重系数，至少要比九点滑动平均的权重系数要好。</p><h3 id="高通-低通滤波">高通/低通滤波</h3><p>这个权重系数就是</p><ul><li><p>低通</p><p>$$<br>\begin{align}<br>&amp;{w_k} = \frac{ { {\omega _c} } } { { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{w_0} = \frac{ { {\omega _c} } }{ { {\omega _N} } }<br>\end{align}<br>$$</p></li><li><p>高通</p><p>$$<br>\begin{align}<br>&amp;{w_k} = -\frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{w_0} = 1-\frac{ { {\omega _c} } }{ { {\omega _N} } }<br>\end{align}<br>$$</p><p>其中 ${\omega_c}$ 是 cutoff 频率 (角频率)。${\omega_N}$ 是 Nyquist 频率 (角频率)。</p></li></ul><blockquote><p>例如原序列是逐日的气温数据，时间步长是1天。做低通滤波，保留周期大于10天 ($f=\frac{1}{10}$) 的信号，那么</p><p>(1) 采样频率$sample=\frac{1}{1 day}=1$</p><p>(2) $\omega_{N}=0.5*sample *2\pi=\pi$  (Nyquist频率是构成序列的波的最大频率。想象至少三个点才能确定一个完整的波形，而三个点包含两个时间步长。也就是说一个波形对应的最小周期就是2个时间步长，那么频率是周期的倒数，一个波形对应的最大频率就是 $\omega_{N}$)</p><p>(3) $\omega_{c}=f*2\pi=\frac{1}{10day}*2\pi=\frac{\pi}{5}$    (角频率等于频率乘2$\pi$)<br>再例如原序列是逐小时的气温数据，时间步长是 1小时=$\frac{1}{24}$天。做高通滤波，保留周期小于30天 ($f=\frac{1}{30}$) 信号，那么</p><p>(1) 采样频率$sample=\frac{1}{1/24 day}=24$</p><p>(2) $\omega_{N}=0.5*sample *2\pi=24\pi $</p><p>(3) $\omega_{c}=f*2\pi=\frac{1}{30day}*2\pi=\frac{\pi}{15}$</p></blockquote><h3 id="带通滤波">带通滤波</h3><p>带通滤波的权重公式为</p><p>$$<br>\begin{align}<br>&amp;{w_k} = \frac{ { {\omega _2} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _2}/{\omega _N})} }{ {\pi k{\omega _2}/{\omega _N} } } - \frac{ { {\omega _1} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _1}/{\omega _N})} }{ {\pi k{\omega _1}/{\omega _N} } },{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k =  - M,…,0,…M\\<br>&amp;{\omega _2} &gt; {\omega _1}\\<br>&amp;{w_0}=\frac{\omega _2 - \omega _1}{\omega _y}<br>\end{align}<br>$$</p><p>其中 $\omega_{0}$ 是通过 $k→0$ 取极限得到。使用带通滤波将保留角频率在 [$\omega_{1}, \omega_{2}$] 之间的信号。</p><h3 id="响应函数">响应函数</h3><p>既然有了 $w_{k}$ 那么我们就可以通过公式 (1) 进行计算，得到滤波结果。那么为什么乘了这样的权重系数能达滤波的作用呢？</p><p>首先我们可以看一下滤波结果 $y_{n}$ 究竟是不是保留了我们想要的频率的信号。怎么看呢？就是用傅里叶变换把时域信号转换到频域上。即</p><p>$$<br>\begin{align}<br>Y(\omega ) = \sum\limits_{n =  - M}^M { {y_n}{e^{ - i\omega n\Delta t} } }<br>\end{align}<br>$$</p><p>该公式同 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中的公式 (14)。将公式 (1) 代入公式 (10)，得</p><p>$$<br>\begin{align}<br>Y(\omega ) &amp;= \sum\limits_{n =  - M}^M { {y_n}{e^{ - i\omega n\Delta t} } } \\<br>&amp;= \sum\limits_{k =  - M}^M { {w_k}{e^{ - i\omega k\Delta t} } } \sum\limits_{n =  - M}^M { {x_{n - k} }{e^{ - i\omega (n - k)\Delta t} } } \\<br>&amp;= W(\omega )X(\omega )<br>\end{align}<br>$$</p><p>可见 $y_{n}$ 的傅里叶变换等于 $w_{k}$ 和 $x_{n}$ 的傅里叶变换的乘积。也就是说<code>新信号的频谱等于原信号的频谱乘权重系数的频谱。</code> 如果 $W(\omega)$ 在 [$\omega_{1}, \omega_{2}$] 上等于0，在 [$\omega_{3}, \omega_{4}$] 等于1，那么与 $X(\omega)$ 相乘就会导致频谱在 [$\omega_{1}, \omega_{2}$] 上等于0，在 [$\omega_{3}, \omega_{4}$] 上保持不变。这就相当于 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中所做的滤波一样，这不过在这里使用特定的函数，而 <a href="https://664787022.github.io/2022/09/27/fourier/"><font color=CornflowerBlue>傅里叶变换与滤波</font></a> 中人为手动地通过赋值改变频谱。</p><p>事实上公式 (3)(5)(7) 的频谱 $W(\omega)$ 就是能取得这种效果, 它也被称为响应函数。为了克服滤波前后造成的相位偏移，通常认为 $W(\omega)$ 是偶函数，即 $W(\omega)=W(-\omega)$ 。因此 $W(\omega)$ 的计算公式也写为()</p><p>$$<br>\begin{align}<br>W(\omega ) = {w_0} + 2\sum\limits_{k = 1}^M { {w_k}\cos (\pi k\omega /{\omega _N})}<br>\end{align}<br>$$</p><p><code>《Data Analysis Methods in Physical Oceanography, Third Edition》里的公式 (6.41) 少了系数2 ？</code>下面通过举例来看看这个响应函数的曲线。</p><p>以低通滤波为例，条件如下：</p><blockquote><p>原序列是逐小时的气温数据，时间步长是 1小时=$\frac{1}{24}$天。原信号由周期1,3,5,7天四个余弦波叠加，数据长度为3000，也就是3000/24=125天。通过低通滤波得到周期大于6天的信号(也就是得到周期7天的波)。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组长度</span></span><br><span class="line">N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">sample = <span class="number">24</span> </span><br><span class="line">omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line">M = <span class="number">240</span> </span><br><span class="line">k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通权重公式</span></span><br><span class="line">wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">w0 = omega_c/omega_ny</span><br><span class="line">wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">term = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">    term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">Wk = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(fft_x, Wk)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vy1x.png" title="" alt="" data-align="center"><p>这就是低通滤波响应函数的图像。可以看到在高频部分 (f&gt;1/7), $W_{k}=0$ 这样通过公式 (13) 将导致新序列在高频部分的频率为0，经过傅里叶逆变换之后，新序列的高频信号就被滤掉了，而只保留了低频部分 (因为 f&lt;1/7的部分 $W_{k}=1$)。</p><p>可以看到 $W_k$ 由1到0的转变很迅速，几乎是垂直的，这就意味着这种响应函数滤波滤得很干净。<code>这与 M 的选取有关，M 越大滤波效果越好，但会造成更多的数据损失。</code> 下面代码展现 M 的选取对响应函数的影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getWk</span>(<span class="params">M</span>):</span><br><span class="line">    N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">    sample = <span class="number">24</span> </span><br><span class="line">    omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">    omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line"></span><br><span class="line">    k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 低通权重公式</span></span><br><span class="line">    wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">    w0 = omega_c/omega_ny</span><br><span class="line">    wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">    fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    Wk = w0 + <span class="number">2</span>*term</span><br><span class="line">    <span class="keyword">return</span> Wk</span><br><span class="line"></span><br><span class="line">Wlist = []</span><br><span class="line">label = []</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> [<span class="number">20</span>,<span class="number">80</span>,<span class="number">120</span>,<span class="number">240</span>]:</span><br><span class="line">    Wlist.append(getWk(M))</span><br><span class="line">    label.append(<span class="built_in">str</span>(M))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Wlist)):</span><br><span class="line">    ax.plot(fft_x, Wlist[i], label=label[i])</span><br><span class="line">ax.set_xlim([-<span class="number">1</span>,<span class="number">1</span>]) <span class="comment"># x 轴范围缩小到 [-1, 1]</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Frequency f&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Amplitude $W_&#123;k&#125;$&#x27;</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2VcjK.png" title="" alt="" data-align="center"><p>图中为 M=20,80,120,240 的情况下 $W_k$ 的曲线，是对 $f=[-1,1]$ 的局部放大。很明显 M 越大， $W_k$ 的最大值维持在1， 最小值维持在0，且0,1之间的转变迅速 (斜率大)。<code>因此在对不同数据进行滤波时，应该选取合适的 M， 看一下</code> $W_k$ <code>是否合理。从滤波效果来说，M 越大越好</code></p><p> </p><p>那么具体的滤波手段有两种，一种是通过公式 (1) 原信号直接乘权重系数。另一种是通过公式 (13) ，原信号先转为频域，乘响应函数，最后傅里叶逆变换转为时域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组长度</span></span><br><span class="line">N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">sample = <span class="number">24</span> </span><br><span class="line">omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line">M = <span class="number">240</span> </span><br><span class="line">k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通权重公式</span></span><br><span class="line">wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">w0 = omega_c/omega_ny</span><br><span class="line">wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">term = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">    term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">Wk = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">y2 = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        y2[t] = y2[t] + wk[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(fft_x, Wk)</span><br><span class="line"></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * Wk</span><br><span class="line">y = ifft(Y)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax[<span class="number">0</span>].plot(n, y, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n,  np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;7&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n,  y2, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2V2nO.png" title="" alt="" data-align="center"><p>蓝线是频谱相乘再傅里叶变换的结果，橙线是周期为7天的波，绿线是直接乘权重系数的结果。可以看出三根线都较为接近，说明滤波起到了很好的效果。<code>此外，蓝线并没有损失数据，而绿线损失了数据。</code> 因此可以通过傅里叶变换的方法避免数据的损失，从图中可以看出这种方法保留下的两端的数据仍具有较好的准确性。图中绿线在两端各损失了 $M=240$ 个点，共480个点。<code>从图中看出蓝线和绿线的最大值都小于1，也就是说滤波后振幅减弱了，这主要是因为 M 的值不够大。</code></p><h3 id="Lanczos-Window">Lanczos Window</h3><p>以上的滤波操作还不能被称为 Lanczos 滤波。Lanczos滤波需要对以上的权重函数再乘一个因子 $\sigma$ 。其公式为</p><p>$$<br>\begin{align}<br>\sigma (M,k) = \frac{ {\sin (\pi k/M)} }{ {\pi k/M} }<br>\end{align}<br>$$</p><p>于是公式 (3)(5)(7) 变成</p><p>$$<br>\begin{align}<br>&amp;低通{w_k} = \frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } }\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}\\<br>&amp;高通{w_k} = -\frac{ { {\omega _c} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _c}/{\omega _N})} }{ {\pi k{\omega _c}/{\omega _N} } }\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}\\<br>&amp;带通{w_k} = (\frac{ { {\omega _2} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _2}/{\omega _N})} }{ {\pi k{\omega _2}/{\omega _N} } } - \frac{ { {\omega _1} } }{ { {\omega _N} } }\frac{ {\sin (\pi k{\omega _1}/{\omega _N})} }{ {\pi k{\omega _1}/{\omega _N} } })\sigma(M,k){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}<br>\end{align}<br>$$</p><p>$\sigma$ 因子的作用是加快响应函数从在0,1之间的转变，并且减弱 Gibbs 现象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getWk</span>(<span class="params">M</span>):</span><br><span class="line">    N = <span class="number">3000</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 采样频率，步长是1小时=1/24天，所以频率是24</span></span><br><span class="line">    sample = <span class="number">24</span> </span><br><span class="line">    omega_c = <span class="number">1</span>/<span class="number">6</span> * <span class="number">2</span>*np.pi <span class="comment"># cutoff 角频率</span></span><br><span class="line">    omega_ny = <span class="number">0.5</span>*sample * <span class="number">2</span>*np.pi <span class="comment"># Nyquist角频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取权重点个数为 2M+1</span></span><br><span class="line"></span><br><span class="line">    k = np.arange(-M, M+<span class="number">1</span>) <span class="comment"># 波数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 低通权重公式</span></span><br><span class="line">    wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">    w0 = omega_c/omega_ny</span><br><span class="line">    wk[k==<span class="number">0</span>] = w0 <span class="comment"># k==0的地方要重新赋值</span></span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>] <span class="comment"># 考虑对称性，只取k为正数</span></span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line">    fft_x = fftfreq(N, <span class="number">125</span>/N) <span class="comment"># 计算频率</span></span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi <span class="comment"># 转为角频率</span></span><br><span class="line"></span><br><span class="line">    sigma = np.sin(np.pi * k_plus / M) / (np.pi * k_plus / M)</span><br><span class="line"></span><br><span class="line">    wk_plus = wk_plus * sigma</span><br><span class="line">    <span class="comment"># 通过离散傅里叶变换计算权重系数的频率Wk(响应函数)</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    Wk = w0 + <span class="number">2</span>*term</span><br><span class="line">    <span class="keyword">return</span> Wk</span><br><span class="line"></span><br><span class="line">Wlist = []</span><br><span class="line">label = []</span><br><span class="line"><span class="keyword">for</span> M <span class="keyword">in</span> [<span class="number">20</span>,<span class="number">80</span>,<span class="number">120</span>,<span class="number">240</span>]:</span><br><span class="line">    Wlist.append(getWk(M))</span><br><span class="line">    label.append(<span class="built_in">str</span>(M))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Wlist)):</span><br><span class="line">    ax.plot(fft_x, Wlist[i], label=label[i])</span><br><span class="line">ax.set_xlim([-<span class="number">1</span>,<span class="number">1</span>]) <span class="comment"># x 轴范围缩小到 [-1, 1]</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Frequency f&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Amplitude $W_&#123;k&#125;$&#x27;</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2VWHe.png" title="" alt="" data-align="center"><p>Gibbs 现象就是在0,1,转换出曲线强烈振荡的现象，与前天相比较。加入了 $\sigma$ 因子很好地减弱了 Gibbs 现象。</p><hr><h2 id="总结">总结</h2><p>下面把Lanczos代码做一下汇总总结</p><p>首先定义一个生成响应函数 $W(\omega)$ 和 权重系数 $w_k$ 的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lanczos</span>(<span class="params">N, sample, M, _f, _tp</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    N : int</span></span><br><span class="line"><span class="string">        数据长度.</span></span><br><span class="line"><span class="string">    sample : float</span></span><br><span class="line"><span class="string">        采样频率.</span></span><br><span class="line"><span class="string">    M : int</span></span><br><span class="line"><span class="string">        权重点数，总权重数为2M+1个.</span></span><br><span class="line"><span class="string">    _f : float or list</span></span><br><span class="line"><span class="string">        cutoff频率。低通和高通为一个数，带通为列表，长度为2，由小到大.</span></span><br><span class="line"><span class="string">    _tp : TYPE</span></span><br><span class="line"><span class="string">        滤波类型。 低通:&#x27;low&#x27; ; 高通: &#x27;high&#x27; ; 带通: &#x27;band&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    W : array</span></span><br><span class="line"><span class="string">        响应函数.</span></span><br><span class="line"><span class="string">    wk : array</span></span><br><span class="line"><span class="string">        权重系数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>   </span><br><span class="line">    <span class="comment"># cutoff频率</span></span><br><span class="line">    <span class="keyword">if</span> (_tp==<span class="string">&#x27;low&#x27;</span>)| (_tp==<span class="string">&#x27;high&#x27;</span>):</span><br><span class="line">        omega_c = _f * (<span class="number">2</span> * np.pi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;band&#x27;</span>:</span><br><span class="line">        omega1 = _f[<span class="number">0</span>] * <span class="number">2</span> * np.pi</span><br><span class="line">        omega2 = _f[<span class="number">1</span>] * <span class="number">2</span> * np.</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Nyquist频率</span></span><br><span class="line">    omega_ny = sample*<span class="number">0.5</span> * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line">    k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算权重系数</span></span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;low&#x27;</span>:</span><br><span class="line">        wk = omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">        w0 = omega_c/omega_ny</span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;high&#x27;</span>:</span><br><span class="line">        wk = -omega_c/omega_ny * np.sin(np.pi * k * omega_c/omega_ny) / (np.pi * k * omega_c/omega_ny)</span><br><span class="line">        w0 = <span class="number">1</span> - omega_c/omega_ny</span><br><span class="line">    <span class="keyword">if</span> _tp==<span class="string">&#x27;band&#x27;</span>:</span><br><span class="line">        wk = omega2/omega_ny * np.sin(np.pi * k * omega2 / omega_ny) / (np.pi * k * omega2/omega_ny) - \</span><br><span class="line">        omega1/omega_ny * np.sin(np.pi * k * omega1 / omega_ny) / (np.pi * k * omega1/omega_ny)</span><br><span class="line">        w0 = (omega2 - omega1)/omega_ny</span><br><span class="line"></span><br><span class="line">    wk[k==<span class="number">0</span>] = w0</span><br><span class="line">    k_plus = k[k&gt;=<span class="number">1</span>]</span><br><span class="line">    wk_plus = wk[k&gt;=<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fft_x=fftfreq(N,T/N) </span><br><span class="line">    omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算sigma因子</span></span><br><span class="line">    sigma = np.sin(np.pi * k / M) / (np.pi * k / M)</span><br><span class="line">    sigma_plus = np.sin(np.pi * k_plus / M) / (np.pi * k_plus / M)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 系数乘sigma因子</span></span><br><span class="line">    wk = wk * sigma </span><br><span class="line">    wk_plus = wk_plus * sigma_plus</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算响应函数</span></span><br><span class="line">    term = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_plus.shape[<span class="number">0</span>]):</span><br><span class="line">        term = term + wk_plus[i] * np.cos(np.pi * k_plus[i] * omega / omega_ny)</span><br><span class="line"></span><br><span class="line">    W = w0 + <span class="number">2</span>*term</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W, wk</span><br></pre></td></tr></table></figure><p>然后可以分别利用响应函数 $W(\omega)$ 和权重系数 $w_k$ 进行滤波</p><ul><li>低通 (高通)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft </span><br><span class="line"></span><br><span class="line">N = <span class="number">3000</span></span><br><span class="line">T = <span class="number">125</span></span><br><span class="line">M = <span class="number">800</span></span><br><span class="line">k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fft_x = fftfreq(N, T/N) </span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WL, wkL = lanczos(N=N, T=T, M=M, _f=<span class="number">1</span>/<span class="number">6</span>, _tp=<span class="string">&#x27;low&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用响应函数做傅里叶逆变换</span></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * WL</span><br><span class="line">yW = ifft(Y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">yw = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        yw[t] = yw[t] + wkL[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yW, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;7&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yw, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(omega, WL)</span><br><span class="line">ax[<span class="number">1</span>].set_xlim([-<span class="number">10</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2V54A.png" title="" alt="" data-align="center"><p>图2 是响应函数 $W(\omega)$ 的图像，对比图1 来看这样的响应函数能够很好地完成滤波。在以上代码中将 M 提高到了 800，如果 M=240 则 滤波效果并不很好。<code>所以在滤波之前一定要对比参考响应函数</code> $W(\omega)$</p><p>以上代码是低通滤波 (高通滤波同理)。此外还可以做带通滤波</p><ul><li>带通</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3000</span></span><br><span class="line">T = <span class="number">125</span></span><br><span class="line">M = <span class="number">800</span></span><br><span class="line">k = np.arange(-M,M+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fft_x = fftfreq(N, T/N) </span><br><span class="line">omega = fft_x * <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原序列 </span></span><br><span class="line">n = np.arange(<span class="number">0</span>, <span class="number">125</span>, <span class="number">1</span>/<span class="number">24</span>) </span><br><span class="line">x = np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">1</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">3</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n) + np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">7</span> * n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WL, wkL = lanczos(N=N, T=T, M=M, _f=[<span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">4</span>], _tp=<span class="string">&#x27;band&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用响应函数做傅里叶逆变换</span></span><br><span class="line">X = fft(x)  </span><br><span class="line">Y = X * WL</span><br><span class="line">yW = ifft(Y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接乘权重系数</span></span><br><span class="line">yw = np.zeros((N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(M, N-M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k.shape[<span class="number">0</span>]):</span><br><span class="line">        yw[t] = yw[t] + wkL[j] * x[t-k[j]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yW, label=<span class="string">&#x27;$W_&#123;\omega&#125;X(\omega)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, np.cos(<span class="number">2</span>*np.pi * <span class="number">1</span>/<span class="number">5</span> * n), label=<span class="string">&#x27;$cos(2\pi*\\frac&#123;1&#125;&#123;5&#125;)$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(n, yw, label=<span class="string">&#x27;$w_&#123;k&#125;x_&#123;n-k&#125;$&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line">ax[<span class="number">1</span>].plot(omega, WL)</span><br><span class="line">ax[<span class="number">1</span>].set_xlim([-<span class="number">10</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vo9I.png" title="" alt="" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lanczos滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换与滤波</title>
      <link href="/2022/09/27/fourier/"/>
      <url>/2022/09/27/fourier/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-3">前言</h2><p>在读了王老师的那篇探讨行星波影响冬季风关系的文章后。我也想自己动手计算一下EP通量。论文的计算步骤里有一步是要将各变量进行傅里叶分解，保留1-3波。由于当时不了解傅里叶变换，这一步也就跳过去了。算出来的EP通量始终小了一个量级。我想也许就是因为没做滤波导致的？不管是不是这个原因，我还是决定学习一下傅里叶变换。目前没怎么翻书，看了两篇知乎文章，感觉大致就懂了。</p><p><a href="https://zhuanlan.zhihu.com/p/380004634"><font color=CornflowerBlue>傅里叶变换 (scipy.fft)</font></a></p><p><a href="https://www.zhihu.com/question/19714540/answer/1119070975"><font color=CornflowerBlue>如何理解傅里叶变换公式？</font></a></p><p><a href="https://www.zhihu.com/question/21314374/answer/542909849"><font color=CornflowerBlue>如何通俗地解释什么是离散傅里叶变换？</font></a></p><hr><h2 id="连续傅里叶变换">连续傅里叶变换</h2><p>傅里叶变换的基本思想就是</p><blockquote><p>任何连续信号(周期性或非周期性的)都可以由一组适当的正弦曲线组合而成</p></blockquote><p>假设时间为 $x$ ，每个时间点对应的信号振幅为 $y(x)$。傅里叶级数有如下公式：</p><p>$$<br>\begin{equation}<br>y(x) = \frac{ { {a_0} } } {2} + \sum\limits_{n = 1}^N { {a_n} } \cos (2\pi fnx) + {b_n}\sin (2\pi fnx)<br>\end{equation}<br>$$</p><p>这里规定了离散的频率 $2\pi fn$ 。因为这样的形式组成了一组正交基，满足以下等式</p><p>$$<br>\begin{equation}<br>\int_{ {\rm{ - } }\frac{T}{2} }^{\frac{T}{2} } {\cos (mx)\cos (nx)dx}  = 0 (m \ne n)<br>\end{equation}<br>$$</p><p>这里在-T/2,T/2之间积分是假定变换的对象 $y(x)$ 是周期函数，即在一个周期内积分为0(上式cos换成sin也成立)。而对于非周期函数，同样可以使用上式，因为非周期函数就是令 $T \to \infty $ 。</p><p>基于正交特性，便可以求出 $a_n$ 和 $b_n$</p><p>$$<br>\begin{align}<br>{a_n} = \frac{2}{T}\int_{ {x_0} }^{ {x_0} + T} {y(x)\cos (2\pi fnx)dx} \\<br>{b_n} = \frac{2}{T}\int_{ {x_0} }^{ {x_0} + T} {y(x)\sin (2\pi fnx)dx}<br>\end{align}<br>$$</p><p>$x_0$ 是任意值，因为我们只需要在一个周期 $T$ 内积分就可以。</p><hr><h2 id="离散傅里叶变换">离散傅里叶变换</h2><p>通常我们需要处理的信号并非严格周期更不是连续的，例如逐年气温序列。假设序列的长度是 $N$ ，我们只需要将积分符号换成求和符号，将 $T$ 换成 $N$，从 $n=0$ 求和到 $n=N$ 即可。我们利用欧拉公式 $ e^{ix} = \cos x + i\sin x $ 重写 $a_n, b_n$ 的表达式</p><p>$$<br>\begin{align}<br>y(x) &amp;= \frac{ { {a_0} } }{2} + \sum\limits_{n = 1}^N { {a_n}\cos (2\pi fnx) + {b_n}\sin (2fnx) } \\<br>&amp;= \sum\limits_{ - N}^N { {c_n} } \cdot (\cos (2\pi fnx) + i\sin (2\pi fnx)) \\<br>&amp;= \sum\limits_{ - N}^N { {c_n} } \cdot {e^{i2\pi fnx} }<br>\end{align}<br>$$</p><blockquote><p>这是复频域傅里叶级数，也是快速傅里叶变换计算的原理。通过复频域表示时，会出现虚数单位，而这个是我们在三角级数表现方式中不曾出现的，而最后负频域表示方式要能够化成和三角级数的相等的表达形式，所以必须想办法消掉虚数单位。所以我们就想到共轭复数 $e^{-ix}=cosx-isinx$ 。有了共轭复数，我们可以通过两个互为共轭的复数加法将虚数消掉。将频域$1-N$求和转化为复频域$-N—N$求和。</p></blockquote><p>$c_n$可用待定系数的方式求解，即设</p><p>$$<br>\begin{align}<br>{c_n} = \left \lbrace  \begin{array} {l}<br>p + iq{\kern 1pt} {\kern 1pt} {\kern 1pt} (n &gt; 0)\\<br>p - iq{\kern 1pt} {\kern 1pt} {\kern 1pt} (n &lt; 0)<br>\end{array} \right.<br>\end{align}<br>$$</p><p>可求得 $c_n$ 与 $a_n , b_n$ 的关系</p><p>$$<br>\begin{align}<br>{c_n} = \left \lbrace \begin{array} {l}<br>\frac{1}{2}({a_n} - i{b_n}){\kern 1pt} {\kern 1pt} {\kern 1pt} (n &gt; 0)\\<br>\frac{1}{2}{a_0}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (n = 0)\\<br>\frac{1}{2}({a_n} + i{b_n}){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (n &lt; 0)<br>\end{array} \right.<br>\end{align}<br>$$</p><p>将公式(3)(4)中的 $T$ 换为 $N$ (非周期函数假定周期无穷大，而信号的长度为 $N$ 。$x$ 换为 $n$ (第n个信号点)。$n$ 换为 $k$ ($N$ 个采样内振动 $k$ 个周期，相当于波数)。积分号换为求和号，则 $a_n , b_n$ 的离散形式为</p><p>$$<br>\begin{align}<br>{a_k} = \frac{2}{N}\sum\limits_{n = 0}^{N - 1} {y(n)\cos (\frac{ {2\pi k} }{N}n)} \\<br>{b_k} = \frac{2}{N}\sum\limits_{n = 0}^{N - 1} {y(n)\sin (\frac{ {2\pi k} }{N}n)}<br>\end{align}<br>$$</p><p>代入公式 (9) 得 $c_n$ 的离散形式</p><p>$$<br>\begin{align}<br>c(k) &amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} {y(n)} (\cos (\frac{ {2\pi k} }{N}n) - i\sin (\frac{ {2\pi k} }{N}n))\\<br>&amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} {y(n)}  \cdot {e^{ - i\frac{ {2\pi k} }{N}n} }<br>\end{align}<br>$$</p><p>这里<code>可能</code>只考虑 $n&gt;0$ 的情况，因为不存在 $y(-n)$ 的值。此外，在<code>Scipy.fft.fft</code> 中计算的 $c(k)$ 没有常数 $\frac{1}{N}$ 。而将 $\frac{1}{N}$ 移到傅里叶逆变换中。 <code>Scipy.fft.fft</code> 给出的计算公式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面没乘 1/n</span></span><br><span class="line">c[k] = np.<span class="built_in">sum</span>(x * np.exp(-<span class="number">2j</span> * np.pi * k * np.arange(n)/n))</span><br></pre></td></tr></table></figure><p> </p><ul><li><p><strong>如何理解 $k,N,f$ 的关系？</strong></p><p>$N$ 在公式中是信号采样点的个数，数据的长度。在假定周期无限大的情况下，<strong>整个数据的长度 $N$ 就是整个原信号周期 $T$</strong> 。在公式 (12)的 $cos(\frac{2\pi k}{N}n)$ 中每个 $k$ 代表一个波，而 $n$ 的作用是对这个波进行采样 (相当于x轴坐标)。公式 (13) 中每个波 $e^{ - i\frac{ {2\pi k} }{N}n}$ 与原信号进行内积(对应位置相乘并求和) 。由内积的特性，如果波与原数据越接近，则内积结果越大 (例如5x5&gt;4x6)。<strong>傅里叶变化公式 (13) 的另一种理解就是找到各个 $k$ 对应的波与原数据的内积，内积越大说明该波贡献也越大，$c_n$ 就越大</strong>。</p><p>我们说 $N$ 是原信号的周期，然而傅里叶变化找出的<strong>各个波的周期并不是 $N$ 而是 $\frac{N}{k}$  ($2\pi /(\frac{2\pi k}{N})$)</strong>。想象一下，如果原数据的采样点有 $N=40$ 。在这个范围内，一个波产生了 5 个完整波形，那么这个波的周期就是 $40/5=8$ , 即 $k=5$ 。5个完整波形意味着波数就是5，那么 <strong>$k$ 就是波数</strong>。 公式(1) - (4) 中的 $f$ 为原信号的频率，$N$ 的倒数。<strong>而傅里叶变化的各个小波的频率为 $\frac{k}{N}$ 。</strong></p></li></ul><hr><p> </p><h2 id="傅里叶逆变换">傅里叶逆变换</h2><p>仔细观察可以发现公式 (7) 的自变量是时间 $x$ 。因此显示的是信号的时域特征。而公式 (13) 的自变量是波数 $k$ 或者说频率 $\frac{k}{N}$ ，因此它显示的是信号的频域特征。我们用公式 (13) 将信号 $y(x) $ 转到频域上，就是傅里叶变换。用公式 (7) 把信号 $c_n$ 转回时域上就是傅里叶逆变换。公式 (7) 写得并不是与 公式 (13) 很对应，因此我们重写一下公式 (7) 和 (13)</p><p>$$<br>\begin{align}<br>c(k) &amp;= \sum\limits_{n = 0}^{N - 1} {y(n) \cdot {e^{ - i\frac{ {2\pi k} }{N}n} } } \\<br>y(n) &amp;= \frac{1}{N}\sum\limits_{n = 0}^{N - 1} { {c_k} \cdot {e^{i\frac{ {2\pi k} }{N}n} } }<br>\end{align}<br>$$</p><p>公式 (14) 和 (15) 分别就是傅里叶变换和傅里叶逆变换。这里为了与<code>Scipy.fft.fft</code> 的算法一致，将本该在公式 (14) 中的 $\frac{1}{N}$ 放在了公式 (15) 中。</p><hr><h2 id="Scipy-fft">Scipy.fft</h2><h3 id="fft-傅里叶变换">fft 傅里叶变换</h3><p>Python 科学计算库 <code>Scipy</code> 提供了方便快捷的傅里叶变换函数。使用这个函数需要注意一些细节。</p><p>首先我们人造一组信号用于测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是由两个角频率为 10 和 15 的信号叠加的。注意是“角频率”</span></span><br><span class="line"><span class="comment"># 其频率分别为10/(2π)=1.59 和 15/(2π)=2.39</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> np.cos(<span class="number">10</span>*n) + np.cos(<span class="number">15</span>*n)</span><br></pre></td></tr></table></figure><p>我们将时间0~7划分为1000份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq,fftshift, ifft</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据长度</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间长度，单位暂定为秒</span></span><br><span class="line">T = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成采样点和信号</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,T,N)</span><br><span class="line">y = f(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行傅里叶变换</span></span><br><span class="line">fft_y = fft(y)  </span><br></pre></td></tr></table></figure><p>生成的 <code>fft_y</code> 即为公式 (14) 中的 $c_k$。在公式 (14) 中 $k=0,1,2,3···N-1$。 想象一下，$k$ 表征波数，如果 $k&gt;\frac{N}{2}$ ，那么意味着这个波每个周期占了不到两个采样点，而波至少需要两个采样点才能确定一个周期波形 (<code>Nyquist</code> 频率概念)。所以 <code>Scipy</code> 采用一种 $-k$ 的方式计算。已知原信号周期为 $N$ ，$k=0,1,2,3···\frac{N}{2}$ 都没什么问题，而考虑周期性的话 $ c(\frac{N}{2}+1 )= c((\frac{N}{2}+1)-N)=c(-\frac{N}{2}+1)$ , 这样 $k$ 被转到了负数上，而由于周期性，计算得到的数值不会改变。例如当 $N=8$ 时，$k=[0, 1, 2, 3, 4, 5, 6, 7]$ 变为 $k=[0, 1, 2, 3, -4, -3, -2, -1]$</p><p>下面对比一下使用 <code>fft</code> 和不使用它的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 scipy.fft.fft 函数计算</span></span><br><span class="line">fft_y=fft(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 k， 但实际上生成的是 k/T</span></span><br><span class="line">fft_x = fftfreq(N,T/N) </span><br><span class="line"></span><br><span class="line"><span class="comment"># [0, 1, 2, 3, -4, -3, -2, -1] 排序调整为</span></span><br><span class="line"><span class="comment"># [-4, -3, -2, -1, 0, 1, 2, 3]</span></span><br><span class="line">fftshift_x = fftshift(fft_x)</span><br><span class="line">fftshift_y = fftshift(fft_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用公式计算</span></span><br><span class="line">k = np.arange(<span class="number">0</span>,N)</span><br><span class="line">yy = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    yy.append(np.<span class="built_in">sum</span>(f(x) * np.exp(-<span class="number">2j</span> * np.pi * k[i] * np.arange(N)/N)))</span><br><span class="line">yy = np.array(yy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax[<span class="number">0</span>].plot(fftshift_x, <span class="built_in">abs</span>(fftshift_y))</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&#x27;函数计算&#x27;</span>,fontfamily=<span class="string">&#x27;SimSun&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].plot(k/T, <span class="built_in">abs</span>(yy))</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&#x27;公式计算&#x27;</span>,fontfamily=<span class="string">&#x27;SimSun&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2EDQf.jpg" title="" alt="" data-align="center"><p>可以看到两种方法计算出的峰值是一样的，只是在x轴是有所不同。图像给出的x轴对应的就是各个波分量的频率。这样看来还是左图更为合理一些，因为 <code>Nyquist</code> 频率的概念存在，波的频率不应该超过 $\frac{N}{2}/T=1000/2/7≈71$</p><ul><li><p>注意事项</p><p>第5行中生成的 <code>fft_x</code> 并不是$k$ 而是 $\frac{k}{T}=\frac{k}{7}$ 也就是真正的这个波分量的频率。我们在公式 (14) 中看到的波频率不应该是 $\frac{k}{N}=\frac{k}{1000}$ 吗？因为在编程过程中 $N$ 只是数据的长度，它不具有单位。在公式 (14) 中 $N$ 也是数据的长度，但它实际上是 $\scriptstyle N=N \times d=N \times 1$ 。$d$ 是采样频率，比如我们有1981-2020年的逐日数据，那么$N=40 \times 365,d=1day$。或者 $d=\frac{1}{30}month$ 。因此 <code>fft_x</code> 代表的频率其实是 $\frac{k} {T}=\frac{k} {N \times d}=\frac{k} {1000 \times 7/1000}$</p><p>不论是哪种方法傅里叶变换总是要输出两个量 $a_n$ 和 $b_n$ 。在复频域中则对应实部和虚部 (注意实部与 $a_n$ 可以相差0.5或$N$ 等常数倍数)。第21行和23行使用的是 <code>abs</code> 表示对复数取模，即根号下实部的平方加虚部的平方。我认为这种处理是比较合理的，因为实部和虚部同样重要，应该综合考虑其分量的振幅。如果不取模直接用 <code>matplotlib</code> ，则只会画出实部。</p></li></ul><h3 id="ifft-傅里叶逆变换与滤波">ifft 傅里叶逆变换与滤波</h3><p>从频域图像中可以看出，频率主要有两个峰值 (四个峰值，其中两个是周期性导致的，看一半即可)。用 <code>np.argsort()</code> 获取排序索引找到峰值对应的频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index[0]与index[1]对应两个相等的最高峰值，相等指的是模相等。其实际数值互为共轭</span></span><br><span class="line"><span class="comment"># 即实部相等，虚部相反。index[2],index[3] 为两个次高的峰值</span></span><br><span class="line">index = np.argsort(<span class="built_in">abs</span>(fftshift_y))[::-<span class="number">1</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到峰值对应的频率</span></span><br><span class="line"><span class="built_in">print</span>(fftshift_x[index])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: array([-1.57142857,  1.57142857, -2.42857143,  2.42857143])</span></span><br></pre></td></tr></table></figure><p>可以计算一下我们一开始是用角频率为10和15的两个信号叠加的。频率等于角频率除以 2π 所以10/(2π) = 1.59和15/(2π) = 2.39 。这与程序输出结果一致。我们准确的找出了信号中的两个主频率。</p><p>利用这一点，我们就可以实现滤波。例如我想去除掉 $cos(15\pi x)$ 这个波。那么我只需要将图像中的那个次高峰变为0即可。因为次高峰对应的频率2.39，也就是角频率15。那么我们只需要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftshift_y[index[[<span class="number">2</span>,<span class="number">3</span>]]] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>好了，现在频域上我们已经去掉了角频率为15的波，现在需要把频域信号转回时域上。也就是傅里叶逆变换。基本公式也就是公式 (15)。我们将处理好的 $c_n$ 代入公式 (15) 计算出 $y(x)$ 也就完成了逆变换。</p><p>在 <code>Scipy.fft.ifft</code> 可以帮助我们快速实现这一点。需要注意的是 <code>ifft</code> 的输入量只能是 <code>fft</code> 和 <code>fftfreq</code> 的直接输出量，不能是用 <code>fftshift</code> 调整顺序之后的量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 傅里叶逆变换</span></span><br><span class="line">ifft_y = ifft(fft_y)</span><br><span class="line"></span><br><span class="line">fig2, ax2 = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">ax2[<span class="number">0</span>].plot(x, ifft_y, label=<span class="string">&#x27;ifft&#x27;</span>)</span><br><span class="line">ax2[<span class="number">0</span>].plot(x, np.cos(<span class="number">10</span>*n), label=<span class="string">&#x27;cos(10x)&#x27;</span>)</span><br><span class="line">ax2[<span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对滤波后的信号再做一次傅里叶变换，检测滤波效果</span></span><br><span class="line">ax2[<span class="number">1</span>].plot(fft_x, fft(ifft_y), label=<span class="string">&#x27;ifft again&#x27;</span>)</span><br><span class="line">ax2[<span class="number">1</span>].legend()</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Ery8.jpg" title="" alt="" data-align="center"><p>可以看到第一张图，滤波后的曲线与 $cos(10x)$ 的曲线比较接近，几乎没有受到 $cos(15x)$ 的影响，但并不是完全重合。对滤波后的时域信号再做一次傅里叶变换，可以看到峰值只剩一个主峰。但在0附近仍存在一个小峰没有去除掉。这个信号的来源不是很清楚，与离散傅里叶变换的误差有关？</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作</title>
      <link href="/2022/07/11/linux/"/>
      <url>/2022/07/11/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-5">前言</h2><p>记录Linux相关操作命令和学习过程、心得。学习网站：蓝桥云课程</p><hr><h2 id="基本操作">基本操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 file 的文件，touch是一个命令</span></span><br><span class="line"><span class="built_in">touch</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入一个目录，cd是一个命令</span></span><br><span class="line"><span class="built_in">cd</span> /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前所在目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前目录下文件名</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment"># 显示隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> *.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命令帮助</span></span><br><span class="line">man</span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h2 id="用户及文件权限管理">用户及文件权限管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新用户</span></span><br><span class="line">sudo adduser xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出当前用户</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看用户所在组</span></span><br><span class="line"><span class="built_in">groups</span> xiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把用户加入sudo中</span></span><br><span class="line">sudo usermod -G sudo lilei</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure><h3 id="查看文件权限">查看文件权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用较长格式列出文件</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vx4s.png" title="" alt="" data-align="center"><img src="https://s1.ax1x.com/2023/03/30/pp2Zp3q.png" title="" alt="" data-align="center"><img src="https://s1.ax1x.com/2023/03/30/pp2Z9g0.png" title="" alt="" data-align="center"><p>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；</p><p>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 <code>exe</code> 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</strong>，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</p><ul><li>变更文件所有者</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要切换到 xiao 用户执行以下操作</span></span><br><span class="line">sudo <span class="built_in">chown</span> xiao(用户名) iphone11(文件名)</span><br></pre></td></tr></table></figure><ul><li>更改文件权限</li></ul><p>每个文件有三组固定的权限，分别对应<code>拥有者，所属用户组，其他用户</code>，<strong>记住这个顺序是固定的</strong>。文件的读写执行对应字母 <code>rwx</code>，以二进制表示就是 <code>111</code>，用十进制表示就是 <code>7</code>，对进制转换不熟悉的同学可以看看 <a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a>。例如我们刚刚新建的文件 iphone11 的权限是 <code>rw-rw-rw-</code>，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。</p><p>如果我要将文件 iphone11 的权限改为只有我自己可以用那么就可以用这个方法更改它的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> 600 iphone11</span><br><span class="line"><span class="built_in">ls</span> -alh iphone11</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZmCR.png" title="" alt="" data-align="center"><hr><h2 id="Linux-目录结构及文件基本操作">Linux 目录结构及文件基本操作</h2><h3 id="文件目录">文件目录</h3><blockquote><p>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。</p></blockquote><p>FHS 定义了两层规范，第一层是， <code>/</code> 下面的各个目录应该要放什么文件数据，例如 <code>/etc</code> 应该放置设置文件，<code>/bin</code> 与 <code>/sbin</code> 则应该放置可执行文件等等。</p><p>第二层则是针对 <code>/usr</code> 及 <code>/var</code> 这两个目录的子目录来定义。例如 <code>/var/log</code> 放置系统日志文件，<code>/usr/share</code> 放置共享数据等等。</p><img src="https://img-blog.csdnimg.cn/img_convert/b88605383677285c7c0d0e76157ffd9f.png" title="" alt="" data-align="center"><blockquote><p><code>~</code> 目录位于 <code>/</code> 目录之下。例如进入<code>/</code> 之后，再进入 <code>home</code> ，再进入用户，也就进入了 <code>~</code> 目录。</p><p><code>/</code> 目录下除了存放 <code>home</code> 以外还存放了一些系统文件夹，例如 <code>etc</code>, <code>bin</code>, <code>lib</code> 等等。</p><p><code>~</code> 目录下则存放了 <code>Desktop</code> , <code>~</code> 更像是我们熟悉的 Windows。</p><p>在使用绝对路径时，路径的起点是 <code>/</code> 目录。例如使用绝对路径进入<code>~</code> 时：</p><p>cd /home/xiao</p><p>home 前要加 ‘/’</p></blockquote><h3 id="文件基本操作">文件基本操作</h3><ul><li><p>创建空白文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>若当前目录存在一个 test 文件夹，则 touch 命令，则会更改该文件夹的时间戳而不是新建文件。</p></blockquote></li></ul><p> </p><ul><li><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mydir</span><br></pre></td></tr></table></figure></li><li><p>同时创建父目录(多级目录)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p father/son/grandson</span><br></pre></td></tr></table></figure></li><li><p>复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">test</span> father/son/grandson</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>要成功复制<strong>目录</strong>需要加上 <code>-r</code> 或者 <code>-R</code> 参数，表示递归复制，就是说有点“株连九族”的意思。</p></blockquote><p> </p><ul><li><p>复制整个文件夹和其内文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r father family</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>若 <code>family</code> 文件夹不存在，则生成 <code>father</code> 副本，并重命名为 <code>family</code>。若<code>family</code>存在，则在<code>family</code>下得到 <code>father</code> 副本。</p></blockquote><p> </p><ul><li><p>删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若文件为只读文件，-f 参数忽视只读权限之间删除</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -r family</span><br><span class="line"><span class="built_in">rm</span> -rf family</span><br></pre></td></tr></table></figure></li><li><p>移动文件、重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment"># mv 还有重命名的作用</span></span><br><span class="line"><span class="built_in">mv</span> file1_oldname file1_newname</span><br></pre></td></tr></table></figure></li><li><p>查看文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行号</span></span><br><span class="line"><span class="built_in">cat</span> -n passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更专业的行号打印</span></span><br><span class="line"><span class="built_in">nl</span> -b a file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查看</span></span><br><span class="line">more file1</span><br><span class="line">less file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件头几行或尾几行</span></span><br><span class="line"><span class="built_in">head</span> -n 5 file1 <span class="comment"># 头5行</span></span><br><span class="line"><span class="built_in">tail</span> -n 5 file1 <span class="comment"># 尾5行</span></span><br></pre></td></tr></table></figure></li><li><p>查看文件类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找文件">查找文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /etc/(文件目录) -name file.sh(文件名，有后缀则加后缀)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前文件夹下以.c 为后缀的文件</span></span><br><span class="line">find . -name <span class="string">&quot;*.c&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>如开头加 sudo 表示使用管理员权限。可解决一些权限不足的问题。</p><p><code>-name</code> 不能乱丢</p><p>此外还有 <code>locate</code>, <code>which</code>, <code>whereis</code> 等查找命令，不细说了</p></blockquote><hr><h2 id="文件压缩与解压">文件压缩与解压</h2><ul><li><p>zip 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip -r -q -o dir.zip(要生成的压缩文件命) /home/Desktop(要压缩的文件或文件夹)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把多个文件压缩在一起</span></span><br><span class="line">zip dir.zip file1 file2 file3</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code>表示递归打包子目录内容。不加<code>-r</code> 则无法把文件夹内其他东西压缩在一起</p><p><code>-p</code> 表示安静模式，不向屏幕输出信息</p><p><code>-o</code> 表示输出文件</p><p><code>zip /dir1/dir2/name.zip file1</code>  用这种方式将文件压缩到指定文件夹</p></blockquote></li></ul><p> </p><ul><li><p>查看文件大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h file1</span><br></pre></td></tr></table></figure><blockquote><p><code>-h</code>表示人类可读的形式</p></blockquote></li></ul><p> </p><ul><li><p>zip 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip dir.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用安静模式，将文件解压到指定目录</span></span><br><span class="line">unzip -q file1.zip -d dir_zip</span><br></pre></td></tr></table></figure><blockquote><p>若上述指定目录 <code>dir_zip</code> 不存在，将会自动创建</p></blockquote></li></ul><p> </p><ul><li><p>仅查看压缩包内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l file1.zip</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p><p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p><p><code>unzip -O GBK 中文压缩文件.zip</code></p></blockquote></li></ul><p> </p><ul><li><p>tar 压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -P -<span class="built_in">cd</span> file1.tar /home/Desktop</span><br></pre></td></tr></table></figure><blockquote><p><code>tar</code> 命令压缩可直接将整个文件夹内容压缩进去。不需要像 <code>zip</code> 命令那样添加 <code>-r</code> 进行递归</p><p><code>-P</code> 保留绝对路径符</p><p><code>-c</code> 表示创建一个 tar 包文件</p><p><code>-f</code> 用于指定创建的文件名，<strong>注意文件名必须紧跟在 <code>-f</code> 参数之后</strong>，比如不能写成 <code>tar -fc shiyanlou.tar</code>，可以写成 <code>tar -f shiyanlou.tar -c ~</code>。你还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p></blockquote></li></ul><p> </p><ul><li><p>tar 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf fil1.tar -C tardir</span><br></pre></td></tr></table></figure><blockquote><p>解压目录 <code>tardir</code> 必须存在。目前还没找到解压到不存在的目录的方法。</p></blockquote></li></ul><p> </p><ul><li><p>仅查看压缩包内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf file1.tar</span><br></pre></td></tr></table></figure></li><li><p>总结</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip：</span></span><br><span class="line">zip something.zip something <span class="comment"># 打包</span></span><br><span class="line">unzip something.zip <span class="comment"># 解包</span></span><br><span class="line"><span class="comment"># 指定路径：-d 参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tar：</span></span><br><span class="line">tar -cf something.tar something <span class="comment"># 打包</span></span><br><span class="line">tar -xf something.tar <span class="comment"># 解包</span></span><br><span class="line"><span class="comment"># 指定路径：-C 参数</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地图及地图文件使用技巧</title>
      <link href="/2022/07/08/mapshape/"/>
      <url>/2022/07/08/mapshape/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-7">前言</h2><p>记录一下使用地图及地图文件的小技巧吧</p><hr><h2 id="地图的合并">地图的合并</h2><p>bou2_4p.shp 由各个省份的polygon组成。 如何将江苏省和山东省的polygon合并组成一个polygon呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> shapely</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">china = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取江苏和山东的 polygon</span></span><br><span class="line">province = china.loc[china.NAME.isin([<span class="string">&#x27;江苏省&#x27;</span>,<span class="string">&#x27;山东省&#x27;</span>]), <span class="string">&#x27;geometry&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并polygon</span></span><br><span class="line">polygon_combine = shapely.ops.unary_union(province)</span><br></pre></td></tr></table></figure><hr><p> </p><h2 id="Proplot极地投影画出直线段">Proplot极地投影画出直线段</h2><p>今天作图的时候想在地图上取一个剖面，于是想现在图上画出剖面线段。这件事本来在等经纬度投影下是一件很容易的事情，然而我的地图是北极投影，做出来的效果并不是想象中的样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;npaeqd&#x27;</span>, proj_kw=&#123;<span class="string">&#x27;lon_0&#x27;</span>:<span class="number">160</span>&#125;)</span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.plot([<span class="number">90</span>,<span class="number">210</span>],[<span class="number">80</span>,<span class="number">30</span>], marker=<span class="string">&#x27;o&#x27;</span>, transform=<span class="string">&#x27;npaeqd&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ZlDO.png" alt="请添加图片描述" data-align="center"><p>如上所示，我想在<code>(90E,80N)</code>和<code>(210E, 30N)</code>之间画一个线段，然而并不能实现。这并不是 <code>Proplot</code>的问题，问题在于极地投影下经纬度并不 <code>（-180~180，-90-90）</code> 的范围。我们需要将等经纬度投影下的<code>(90E,80N)</code>和<code>(210E, 30N)</code> 转换到极地投影下的经纬度坐标。如何实现呢？ 其实在 <a href="https://664787022.github.io/2022/06/22/geomask/"><font color=CornflowerBlue>利用 geopandas 地图白化 | XHW’s Blog (664787022.github.io) </font></a> 这篇博文里讲了类似的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将等经纬度投影的经纬度转为极地投影下的坐标</span></span><br><span class="line">pp = ccrs.NorthPolarStereo()</span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),</span><br><span class="line">                 np.array([<span class="number">90</span>,<span class="number">210</span>]), np.array([<span class="number">80</span>,<span class="number">30</span>]))[:,<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;npaeqd&#x27;</span>, proj_kw=&#123;<span class="string">&#x27;lon_0&#x27;</span>:<span class="number">160</span>&#125;)</span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.plot(path_clip.vertices[:,<span class="number">0</span>],path_clip.vertices[:,<span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">        transform=<span class="string">&#x27;npaeqd&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Z8Ve.png" title="" alt="在这里插入图片描述" data-align="center"><p>如果不使用<code> Proplot</code> 而直接用 <code>Cartopy</code> ，情况会更简单一点。因为在 <code>Cartopy下</code> 可以使用 <code>ccrs.Geodetic()</code>  而 <code>Proplot</code> 似乎没有把 <code>ccrs.Geodetic()</code> 加入进自己的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=ccrs.NorthPolarStereo(central_longitude=<span class="number">160</span>))</span><br><span class="line"></span><br><span class="line">ax.stock_img()</span><br><span class="line">ax.coastlines() </span><br><span class="line"><span class="comment"># 注意这里使用的是ccrs.Geodetic()，使用ccrs.NorthPolarStereo是没用的</span></span><br><span class="line">ax.plot([<span class="number">90</span>,<span class="number">210</span>],[<span class="number">80</span>,<span class="number">30</span>], marker=<span class="string">&#x27;o&#x27;</span>, transform=ccrs.Geodetic())</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZGUH.png" title="" alt="在这里插入图片描述" data-align="center"><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> geopandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用geopandas地图白化</title>
      <link href="/2022/06/22/geomask/"/>
      <url>/2022/06/22/geomask/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-4">前言</h2><p>偶然间看到摸鱼咯大佬在和鲸社区发的帖子 <a href="https://www.heywhale.com/mw/project/621450308da0860017bdfb1a"><font color=CornflowerBlue>geopandas白化</font></a>，利用了<code>geopandas</code>对等值线进行白化。以往我是用气象家园中的maskout.py函数进行白化的。但使用maskout.py需要结合meteoinfo对地图文件进行查看，相对来说还是比较麻烦的。在这里就记录一下使用geopandas的方法。</p><p>以下用的数据存放在网盘中</p><p><a href="https://pan.baidu.com/s/1ExMNF1-yv0OsVg8CH4fbxA"><font color=CornflowerBlue>百度网盘：j4d3</font></a></p><hr><h2 id="代码示例">代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = xr.open_dataset(<span class="string">&#x27;D:/data_english/era5/slp.sst.pre.1979-2020mon.global.nc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 海平面气压距平</span></span><br><span class="line">slp = data[<span class="string">&#x27;msl&#x27;</span>][:,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>))</span><br><span class="line">lon, lat = np.meshgrid(slp.longitude, slp.latitude)</span><br><span class="line"></span><br><span class="line">gb = slp.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">slpa = gb - clim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随便取一年</span></span><br><span class="line">slpa = slpa[<span class="number">0</span>,...]</span><br></pre></td></tr></table></figure><h3 id="未白化的状况">未白化的状况</h3><p>只看中国周围吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;cyl&#x27;</span>,                        <span class="comment"># 等经纬度投影</span></span><br><span class="line">                        lonlim=(<span class="number">70</span>, <span class="number">140</span>), latlim=(<span class="number">10</span>, <span class="number">60</span>)) <span class="comment"># 设置extent</span></span><br><span class="line"></span><br><span class="line">kw = &#123;<span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;RdBu&#x27;</span>,        <span class="comment"># 设置cmap</span></span><br><span class="line">      <span class="string">&#x27;extend&#x27;</span>:<span class="string">&#x27;both&#x27;</span>,      <span class="comment"># 设置extend</span></span><br><span class="line">      <span class="string">&#x27;symmetric&#x27;</span>:<span class="literal">True</span>&#125;     <span class="comment"># 保证 0 在 colorbar中间</span></span><br><span class="line"></span><br><span class="line">fill = ax[<span class="number">0</span>].contourf(lon, lat, slpa, **kw, vmin=-<span class="number">900</span>) <span class="comment"># 等值线填色</span></span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>,                 <span class="comment"># 经纬度标签</span></span><br><span class="line">          coast=<span class="literal">True</span>,                  <span class="comment"># 海岸线</span></span><br><span class="line">          gridlabelsize=<span class="string">&#x27;xx-small&#x27;</span>)    <span class="comment"># 经纬度标签字体大小</span></span><br><span class="line"></span><br><span class="line">fig.colorbar(fill, label=<span class="string">&#x27;&#x27;</span>,                 <span class="comment"># 取掉colorbar的label</span></span><br><span class="line">                   ticklabelsize=<span class="string">&#x27;xx-small&#x27;</span>, <span class="comment"># colorbar tick字体大小</span></span><br><span class="line">                   width=<span class="number">0.1</span>)                <span class="comment"># colorbar宽度</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2E7mF.png" alt="" data-align="center" width="473"><hr><h3 id="geopandas-读取-shp">geopandas 读取 shp</h3><p><code>下面利用bou2_4p.shp对中国区域进行白化。先看一下geopandas读取shp文件的结果。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    AREA    PERIMETER    BOU2_4M_    BOU2_4M_ID    ADCODE93    ADCODE99    NAME    geometry</span><br><span class="line">0    54.447    68.489    2    23    230000    230000    黑龙江省    POLYGON ((121.48844 53.33265, 121.49954 53.336...</span><br><span class="line">1    129.113    129.933    3    15    150000    150000    内蒙古自治区    POLYGON ((121.48844 53.33265, 121.49738 53.321...</span><br><span class="line">2    175.591    84.905    4    65    650000    650000    新疆维吾尔自治区    POLYGON ((96.38329 42.72696, 96.35991 42.70969...</span><br><span class="line">3    21.315    41.186    5    22    220000    220000    吉林省    POLYGON ((123.17104 46.24668, 123.21857 46.269...</span><br><span class="line">4    15.603    38.379    6    21    210000    210000    辽宁省    POLYGON ((123.69019 43.37677, 123.70496 43.381...</span><br><span class="line">...    ...    ...    ...    ...    ...    ...    ...    ...</span><br><span class="line">920    0.000    0.037    922    3110    810000    810000    香港特别行政区    POLYGON ((114.24527 22.18337, 114.24348 22.184...</span><br><span class="line">921    0.000    0.018    923    3109    810000    810000    香港特别行政区    POLYGON ((114.28620 22.18478, 114.28435 22.185...</span><br><span class="line">922    0.000    0.014    924    3112    810000    810000    香港特别行政区    POLYGON ((114.30350 22.18492, 114.30413 22.186...</span><br><span class="line">923    0.000    0.079    925    3114    810000    810000    香港特别行政区    POLYGON ((114.25628 22.16027, 114.25436 22.163...</span><br><span class="line">924    0.000    0.011    926    3115    810000    810000    香港特别行政区    POLYGON ((114.29893 22.17812, 114.30064 22.178...</span><br></pre></td></tr></table></figure><hr><h3 id="关键白化操作">关键白化操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">china = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成裁剪路径 – 关键操作1</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(china))</span><br><span class="line"><span class="comment"># 将裁剪路径应用到图层 – 关键操作2</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ERFs.png" alt="" data-align="center" width="458"><p><font size=5 color="blue"> 可直接添加图窗画区域边缘 </font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制多边形边缘线</span></span><br><span class="line"><span class="comment"># bou1_4l包括国界线和南海九段线</span></span><br><span class="line">shp2 = gpd.read_file(<span class="string">&#x27;bou1_4l.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">ax.add_geometries(shp2[<span class="string">&#x27;geometry&#x27;</span>].tolist(), crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;none&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EbTJ.png" alt="" data-align="center" width="436"><p><font size=5 color="blue"> 合并添加多个shp </font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可添加多个shp</span></span><br><span class="line"><span class="comment"># bou2_4p包括国界和省界</span></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">shp2 = gpd.read_file(<span class="string">&#x27;bou1_4l.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line"></span><br><span class="line">com = shp2[<span class="string">&#x27;geometry&#x27;</span>].append(shp[<span class="string">&#x27;geometry&#x27;</span>]) <span class="comment"># 合并两个shp</span></span><br><span class="line"><span class="comment"># 或者 com = shp2[&#x27;geometry&#x27;].tolist() + shp[&#x27;geometry&#x27;].tolist()</span></span><br><span class="line"></span><br><span class="line">ax.add_geometries(com, crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;none&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2EvSx.png" alt="" data-align="center" width="434"><hr><h3 id="风矢量的白化">风矢量的白化</h3><p>quiver生成的对象与contourf生成的对象不同，<code>它不包含collection属性</code>。所以白化操作略有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取资料</span></span><br><span class="line">data2 = xr.open_dataset(<span class="string">&#x27;GH.UV.500_850hPa.1979-2020.nc&#x27;</span>)</span><br><span class="line">u = data2[<span class="string">&#x27;u&#x27;</span>][:,<span class="number">0</span>,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="number">70</span>,<span class="number">140</span>,<span class="number">4</span>))</span><br><span class="line">v = data2[<span class="string">&#x27;v&#x27;</span>][:,<span class="number">0</span>,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="number">70</span>,<span class="number">140</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取距平</span></span><br><span class="line">gb = u.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">ua = gb - clim</span><br><span class="line">ua = ua[<span class="number">0</span>,...]</span><br><span class="line"></span><br><span class="line">gb = v.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">va = gb - clim</span><br><span class="line">va = va[<span class="number">0</span>,...]</span><br><span class="line"></span><br><span class="line">lon2, lat2 = np.meshgrid(u.longitude,v.latitude)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d=<span class="number">1</span></span><br><span class="line">tt = ax.quiver(lon2[::d,::d],lat2[::d,::d],ua[::d,::d],va[::d,::d])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剪切白化</span></span><br><span class="line">tt.set_clip_path(path_clip, transform=ax.transData)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VSOO.png" alt="" data-align="center" width="476"><mark class="hl-label red">对于quiver，数据范围最好保证在extent范围内。如果使用-180~180的数据，而extent只设定在70-120，那么画出来的矢量箭头会非常小，需要手动调整scale。一般来说需要进一步调整降低箭头密集度，并调整scale</mark> <hr><h3 id="contour-和-clabel的白化">contour 和 clabel的白化</h3><p><code>contour的白化方法与contourf白化方法相同。contour生成对象后，提取collection循环切片即可。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon <span class="keyword">as</span> ShapelyPolygon</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point <span class="keyword">as</span> ShapelyPoint</span><br><span class="line"></span><br><span class="line">data = xr.open_dataset(<span class="string">&#x27;D:/data_english/era5/slp.sst.pre.1979-2020mon.global.nc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%% </span></span><br><span class="line"></span><br><span class="line">slp = data[<span class="string">&#x27;msl&#x27;</span>][:,<span class="number">0</span>,...].sel(latitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>), longitude=<span class="built_in">slice</span>(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">4</span>))</span><br><span class="line">lon, lat = np.meshgrid(slp.longitude, slp.latitude)</span><br><span class="line"></span><br><span class="line">gb = slp.groupby(<span class="string">&#x27;time.month&#x27;</span>)</span><br><span class="line">clim = gb.mean(dim=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">slpa = gb - clim</span><br><span class="line">slpa = slpa[<span class="number">0</span>,...]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建等值线和labels</span></span><br><span class="line">fig, ax = pplt.subplots(proj=<span class="string">&#x27;cyl&#x27;</span>,lonlim=(<span class="number">70</span>, <span class="number">140</span>), latlim=(<span class="number">10</span>, <span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">kw = &#123; <span class="string">&#x27;cmap&#x27;</span>:<span class="string">&#x27;RdBu_r&#x27;</span>,<span class="string">&#x27;extend&#x27;</span>:<span class="string">&#x27;both&#x27;</span>, <span class="string">&#x27;symmetric&#x27;</span>:<span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line">fill = ax[<span class="number">0</span>].contourf(lon, lat, slpa, **kw, vmin=-<span class="number">900</span>,values=<span class="number">20</span>)</span><br><span class="line">con = ax[<span class="number">0</span>].contour(lon, lat, slpa, levels=fill.levels,</span><br><span class="line">                    color=<span class="string">&#x27;black&#x27;</span>,linewidth=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">cb = ax[<span class="number">0</span>].clabel(con,levels=fill.levels)</span><br><span class="line">ax.<span class="built_in">format</span>(labels=<span class="literal">True</span>, coast=<span class="literal">True</span>, gridlabelsize=<span class="string">&#x27;xx-small&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.colorbar(fill, label=<span class="string">&#x27;&#x27;</span>, ticklabelsize=<span class="string">&#x27;xx-small&#x27;</span>, width=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VktA.png" alt="" data-align="center" width="380"><p>下面对<code>等值线白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shp = gpd.read_file(<span class="string">&#x27;D:/anaconda_spyder_filesave/mission/mission9/0619/shpfile/bou2_4p.shp&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">ee = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成裁剪路径 – 关键操作1</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(ee))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将裁剪路径应用到图层 – 关键操作2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对填色图白化</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对等值线白化</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> con.collections]</span><br><span class="line"></span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VGpq.png" alt="" data-align="center" width="352"><p>可以看到labels还是到处乱飞，下面需要对labels白化。然而labels对象是Text组成的列表，操作过程以上等值线白化又有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clabel白化</span></span><br><span class="line"><span class="comment"># cb = ax[0].clabel(con,levels=fill.levels)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> text_object <span class="keyword">in</span> cb:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path_clip.contains_point(text_object.get_position()):</span><br><span class="line">        text_object.set_visible(<span class="literal">False</span>)  </span><br><span class="line">fig</span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2VYcV.png" alt="" data-align="center" width="397"><p><code>path_clip.contains_point</code> 判断点是否在路径所包围的区域内</p><hr><h3 id="非等经纬度投影白化">非等经纬度投影白化</h3><p><code>以上白化操作ax的投影皆为ccrs.PlateCarree()</code>, <code>数据投影也为ccrs.PlateCarree()</code>。因此无论是画图还是白化都不需要额外的操作来转化点的坐标。</p><p>需要注意的是，在创建ax时，<code>projection参数是对ax进行投影设置</code>。即若projection=ccrs.PlateCarree()，则我们最后看到的图就是等经纬度投影的图。若projection=ccrs.LambertConformal()，则我们最后看到的图就是兰伯特投影的样子。</p><p>然而<code>在contourf的transform和ax.set_extent()中设置的crs的意义不同，它们要求我们告诉程序，为什么所输入的数据是取自怎样的投影</code>。一般来说，我们的数据都是格点数据，lon:-180~180, lat:-90~90。即我们的数据一般是等经纬度的，<code>所以transform和crs都设置为ccrs.PlateCarree()就可以了(不随projection的变化而变化)</code>。</p><p>详情可以看这里  <a href="https://scitools.org.uk/cartopy/docs/latest/tutorials/understanding_transform.html?highlight=transform"><font color=CornflowerBlue>transform和projection的意义</font></a></p><p>此外，通常我们的shp文件提取出的点也是等经纬度的lon:-180~180, lat:-90~90。<code>而当projection=ccrs.LambertConformal()时就无法直接用以上程序直接进行白化</code>，因为坐标不对应。这个时候<code>需要先将路径Path转化到相应的projection上</code>。</p><p>注意即使我们的projection使用的是ccrs.PlateCarree()，但设置了中心经度例如projection=ccrs.PlateCarree(central_longitude=120)。也需要对路径点进行坐标转化。<code>路径点坐标系必须与 projection 完全一致</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非等经纬度投影白化</span></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(ee))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的操作会丢失codes信息，需要提前保存副本</span></span><br><span class="line">codes = path_clip.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设在创建ax时设置了兰伯特投影和中心经度、中心纬度</span></span><br><span class="line"><span class="comment"># fig, ax = pplt.subplots(proj=&#x27;lcc&#x27;,lonlim=(70, 140), </span></span><br><span class="line"><span class="comment">#                       latlim=(10, 60),proj_kw=&#123;&#x27;lon_0&#x27;:100,&#x27;lat_0&#x27;:30&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须与projection一致</span></span><br><span class="line">pp = ccrs.LambertConformal(central_longitude=<span class="number">100</span>, central_latitude=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步将处于ccrs.PlateCarree()里的路径点转化到 pp 投影上</span></span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),path_clip.vertices[:,<span class="number">0</span>], path_clip.vertices[:,<span class="number">1</span>])[:,<span class="number">0</span>:<span class="number">2</span>],codes=codes)</span><br></pre></td></tr></table></figure><div class="note success simple"><p>codes似乎标记了多边形个体，每个多边形用有一个数字存在codes中。如果不添加codes参数，例如大陆和海南岛之间会有路径穿过。</p><p>摸鱼咯大佬的帖子中使用的是ccrs.Geodetic()而不是ccrs.PlateCarree()来转化路径点，我不清楚有什么区别。我觉得ccrs.PlateCarree()更合理一些。</p></div><p>由此，我们得到了一个<code>新的path_clip</code>，后面的白化过程就与之前的内容完全一致了。如果我们不是用等经纬度投影创建坐标轴，就<code>需要将路径点的坐标转化到相应的projection上</code>。</p><hr><h3 id="南海小图">南海小图</h3><p>有时候在画中国地图时需要对地图右下角添加一个小图来显示南海地区。这个小图可以和主图完全相同，只需要调整<code>extent</code>即可。然而，在白化之后会出现如下图的情况。</p><img src="https://s1.ax1x.com/2023/03/30/pp2VaBF.png" title="" alt="" data-align="center"><p>小图范围内虽然白化成功，但是小图之外的图像并没有去除掉。原因在于<code>ax.set_extent()</code>和<code>collection.set_clip()</code>这两个命令相互覆盖了。导致只有一个命令生效。解决的方法就是找到<code>extent</code>与<code>path_clip</code>的交集。思路来源于：<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NzY4MzgxNw==&amp;mid=2247488767&amp;idx=1&amp;sn=5df006905b3e16d7cc4a100988393b03&amp;chksm=cf87fb79f8f0726f51ce8bb5c6bde9f8bcf5535bb4ca8db502083c0f9cee26c1a0e90d23bf90&amp;mpshare=1&amp;scene=23&amp;srcid=06234bAPPyrWvy7gJ1FgEOLf&amp;sharer_sharetime=1661769196302&amp;sharer_shareid=327e1b5af213919a0371744eb74c4650#rd"><font color=CornflowerBlue>链接</font></a> 。我对其代码进行了精简。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> geometry <span class="keyword">as</span> geo</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path,path_to_geos</span><br><span class="line"></span><br><span class="line"><span class="comment"># proplot添加内嵌坐标轴</span></span><br><span class="line">iax = ax.inset([<span class="number">140</span>-<span class="number">11</span>*<span class="number">0.8</span>,<span class="number">10</span>,<span class="number">11</span>*<span class="number">0.8</span>,<span class="number">24</span>*<span class="number">0.8</span>],transform=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填色图</span></span><br><span class="line">fill2 = iax.contourf(lon, lat, o3, extend=<span class="string">&#x27;both&#x27;</span>, robust=<span class="literal">True</span>)</span><br><span class="line">iax.add_geometries(shp[<span class="string">&#x27;geometry&#x27;</span>], crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;None&#x27;</span>, )</span><br><span class="line">iax.add_geometries(shp2[<span class="string">&#x27;geometry&#x27;</span>], crs=ccrs.PlateCarree(), facecolor=<span class="string">&#x27;None&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">iax.<span class="built_in">format</span>(lonlim=(<span class="number">109</span>,<span class="number">120</span>), latlim=(<span class="number">0</span>,<span class="number">24</span>))</span><br><span class="line"></span><br><span class="line">extent = [<span class="number">109</span>,<span class="number">120</span>,<span class="number">0</span>,<span class="number">24</span>]</span><br><span class="line">extentPolygon = geo.Polygon([</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">2</span>]),</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">3</span>]),</span><br><span class="line">    (extent[<span class="number">1</span>], extent[<span class="number">3</span>]),</span><br><span class="line">    (extent[<span class="number">1</span>], extent[<span class="number">2</span>]),</span><br><span class="line">    (extent[<span class="number">0</span>], extent[<span class="number">2</span>]),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键步骤*************</span></span><br><span class="line">polygon_clip = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> path_to_geos(path_clip): <span class="comment"># 将 path 转 polygon</span></span><br><span class="line">    polygon_clip.append(extentPolygon.intersection(p)) <span class="comment"># 将交集填入列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新将交集 polygon 转为 path</span></span><br><span class="line">path_clip2 = Path.make_compound_path(*geos_to_path(polygon_clip))</span><br><span class="line">[collection.set_clip_path(path_clip2, transform=iax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill2.collections]</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2Vd74.png" title="" alt="" data-align="center"><hr><h2 id="总结-2">总结</h2><p>写了这么多，再回去看看觉得好乱。那就简单做个总结吧。</p><p><code>文件读取</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">shp = gpd.read_file(<span class="string">&#x27;./shpfile/china.shp&#x27;</span>)</span><br><span class="line">china = shp[<span class="string">&#x27;geometry&#x27;</span>].tolist()</span><br></pre></td></tr></table></figure><p><code>剪切路径</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.path <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> cartopy.mpl.patch <span class="keyword">import</span> geos_to_path</span><br><span class="line"><span class="keyword">import</span> cartopy.crs <span class="keyword">as</span> ccrs</span><br><span class="line"></span><br><span class="line">path_clip = Path.make_compound_path(*geos_to_path(china))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 ax 不是等经纬度投影需要加上以下代码，以兰伯特投影为例</span></span><br><span class="line">codes = path_clip.codes</span><br><span class="line">pp = ccrs.LambertConformal(central_longitude=<span class="number">100</span>, central_latitude=<span class="number">30</span>)</span><br><span class="line">path_clip = Path(pp.transform_points(ccrs.PlateCarree(),path_clip.vertices[:,<span class="number">0</span>], path_clip.vertices[:,<span class="number">1</span>])[:,<span class="number">0</span>:<span class="number">2</span>],codes=codes)</span><br></pre></td></tr></table></figure><p><code>等值线和填色图白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fill：填色图对象</span></span><br><span class="line"><span class="comment"># con：等值线对象</span></span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill.collections]</span><br><span class="line">[collection.set_clip_path(path_clip, transform=ax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> con.collections]</span><br></pre></td></tr></table></figure><p><code>风矢量白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tt：quiver对象</span></span><br><span class="line">tt.set_clip_path(path_clip, transform=ax.transData)</span><br></pre></td></tr></table></figure><p><code>clabel 白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cb：clabel对象</span></span><br><span class="line"><span class="keyword">for</span> text_object <span class="keyword">in</span> cb:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path_clip.contains_point(text_object.get_position()):</span><br><span class="line">        text_object.set_visible(<span class="literal">False</span>) </span><br></pre></td></tr></table></figure><p><code>polygon取交集白化</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># extentPolygon 与 path_clip 取交集</span></span><br><span class="line">polygon_clip = []</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> path_to_geos(path_clip): <span class="comment"># 将 path 转 polygon</span></span><br><span class="line">    polygon_clip.append(extentPolygon.intersection(p)) <span class="comment"># 将交集填入列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新将交集 polygon 转为 path</span></span><br><span class="line">path_clip2 = Path.make_compound_path(*geos_to_path(polygon_clip))</span><br><span class="line">[collection.set_clip_path(path_clip2, transform=iax.transData) <span class="keyword">for</span> collection <span class="keyword">in</span> fill2.collections]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白化 </tag>
            
            <tag> proplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proplot相关说明及示例</title>
      <link href="/2022/05/25/proplot/"/>
      <url>/2022/05/25/proplot/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-6">前言</h2><p>今天发现一个python模块包: <mark class="hl-label red">Proplot</mark> 。</p><p><a href="https://proplot.readthedocs.io/en/stable/"><font color=CornflowerBlue>ProPlot 文档</font></a></p><p><a href="https://github.com/lukelbd/proplot"><font color=CornflowerBlue>Proplot_github</font></a></p><p>它整合封装了matplotlib，cartopy，basemap。将画图命令精简整合，图窗和轴的排列更加智能整齐，可以说解决了我的很多痛点。但proplot的文档中给出的例子太少，我打算自己做一些例子，帮助自己学会proplot。</p><hr><h2 id="fig和ax的创建">fig和ax的创建</h2><h3 id="fig，ax参数列表">fig，ax参数列表</h3><hr><mark class="hl-label red">Fig-Subplots</mark> <p>nrows: int； 子图行数</p><p>ncols: int；子图列数</p><p>space/wspace/hspace: float, str, None, turple；子图间距</p><p>refwidth: float; 子图宽度</p><p>refheight: float；子图高度</p><p>refaspect: float; 长宽比，默认1</p><p>figsize: tuple; 图窗大小</p><p>figwidth: float, str; 图窗宽度</p><p>figheight: float, str; 图窗高度</p><p>bottom/right/left/top: float, str, None; 图窗边界宽度</p><p>grid/xgrid/ygrid：bool; 网格线, 默认‘True’</p><mark class="hl-label green">Label-Ticks</mark> <p>abc: str; 子图编号</p><p>abcloc: str; label位置</p><p>abc[size][color][weight]</p><p>title: str; 标题</p><p>titleloc：str； 标题位置</p><p>title[size][color][weight]</p><mark class="hl-label blue">Axis-sharing</mark> <p>share/sharex/sharey: bool; 是否共享ticklabels，默认‘True’</p><p>span/spanx/spany: bool; 是否共享xlabel/ylabel，默认‘True’</p><hr><p>与matplotlib相似，proplot支同时创建fig和ax，或者先创建fig，再逐步添加ax</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplt <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots()</span><br></pre></td></tr></table></figure><p>需要注意的是，subplots生成的是多个ax, 通过索引axs[0]访问单个ax。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = pplt.figure()</span><br><span class="line">axs = fig.add_subplots()  <span class="comment"># add several subplots</span></span><br><span class="line">ax = fig.add_subplot()  <span class="comment"># add a single subplot</span></span><br><span class="line"><span class="comment"># axs = fig.subplots()  # shorthand</span></span><br><span class="line"><span class="comment"># ax = fig.subplot()  # shorthand</span></span><br></pre></td></tr></table></figure><p>ax继承了matplotlib中ax的方法和属性（大致看了一下，应该是全部都继承了）。fig也是一样。</p><p>因此proplot几乎可以和matplotlib混用，加入投影参数后也继承了cartopy的方法和属性，同样可以实现混用。不同的是，proplot中ax对象分为三种：Cartesian，AxesGeoAxes，PolarAxes。与matplotlib和cartopy中的名称叫法不同。</p><h3 id="子图间隔、宽度、高度">子图间隔、宽度、高度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots(nrows=<span class="number">4</span>, <span class="comment"># 行数</span></span><br><span class="line">                         ncols=<span class="number">4</span>, <span class="comment"># 列数</span></span><br><span class="line">                         wspace=(<span class="string">&#x27;5em&#x27;</span>,<span class="number">3</span>,<span class="literal">None</span>),</span><br><span class="line">                         hspace=(<span class="literal">None</span>,<span class="number">2</span>,<span class="string">&#x27;4em&#x27;</span>),<span class="comment"># 子图之间的间距</span></span><br><span class="line">                         refwidth=<span class="number">3</span>, <span class="comment"># 子图宽度</span></span><br><span class="line">                         refheight=<span class="number">2</span>) <span class="comment"># 子图高度</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2ZsaQ.png" alt="" data-align="inline" width="351"><div class="note success simple"><p>space可分为wspace,和hspace，分别控制水平和垂直间隔。同样距离可加单位。</p><p>wspace和hspace可以为单一值，也可为元组形式。为元组时，对子图间两两间距进行设置。</p><p>refwidth提供相对长度和绝对长度，例如refwidth=‘2cm’即宽度2cm。</p></div><h4 id="share参数">share参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig, axs = pplt.subplots(nrows=<span class="number">2</span>, <span class="comment"># 行数</span></span><br><span class="line">                         ncols=<span class="number">2</span>, <span class="comment"># 列数</span></span><br><span class="line">                        share=<span class="literal">False</span>) <span class="comment"># 取消共享ticklabels</span></span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/30/pp2ZcPs.png" title="" alt="" width="341"><div class="note success simple"><p>share参数默认为True，即几个子图共享x，yticklabels。ticklabels只在图下和图左出现。</p><p>share=False取消共享，每个子图都画ticklabels。可分为sharex、sharey</p></div><h4 id="子图划分和图窗边距">子图划分和图窗边距</h4><p>subplots接受一个多维数组或列表，用于划分子图分布。0表示此处不画子图，1表示第一个子图，2表示第二个子图…。根据传入的grid决定子图分布，而不用传入ncols和nrows</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">grid = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line">        [<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>]]</span><br><span class="line">fig, axs = pplt.subplots(grid,</span><br><span class="line">                         bottom=<span class="string">&#x27;5em&#x27;</span>, <span class="comment"># 底边距</span></span><br><span class="line">                         right=<span class="string">&#x27;5em&#x27;</span>) <span class="comment"># 右边距</span></span><br></pre></td></tr></table></figure><img title="" src="[![pp2eKij.md.png](https://s1.ax1x.com/2023/03/30/pp2eKij.md.png)](https://imgse.com/i/pp2eKij)" alt="" width="453"><h3 id="子图编号和标题">子图编号和标题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proplot <span class="keyword">as</span> pplt</span><br><span class="line">fig = pplt.figure(space=<span class="number">0</span>, refwidth=<span class="string">&#x27;10em&#x27;</span>)</span><br><span class="line">axs = fig.subplots(nrows=<span class="number">3</span>, ncols=<span class="number">3</span>)</span><br><span class="line">axs.<span class="built_in">format</span>(</span><br><span class="line">    abc=<span class="string">&#x27;A.&#x27;</span>, abcloc=<span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">    xticks=<span class="string">&#x27;null&#x27;</span>, yticks=<span class="string">&#x27;null&#x27;</span>, facecolor=<span class="string">&#x27;gray5&#x27;</span>,</span><br><span class="line">    xlabel=<span class="string">&#x27;x axis&#x27;</span>, ylabel=<span class="string">&#x27;y axis&#x27;</span>,</span><br><span class="line">    suptitle=<span class="string">&#x27;A-b-c label offsetting, borders, and boxes&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">axs[:<span class="number">3</span>].<span class="built_in">format</span>(abcloc=<span class="string">&#x27;l&#x27;</span>, titleloc=<span class="string">&#x27;l&#x27;</span>, title=<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">axs[-<span class="number">3</span>:].<span class="built_in">format</span>(abcbbox=<span class="literal">True</span>)  <span class="comment"># also disables abcborder</span></span><br><span class="line"><span class="comment"># axs[:-3].format(abcborder=True)  # this is already the default</span></span><br></pre></td></tr></table></figure><img title="" src="https://s1.ax1x.com/2023/03/30/pp2eYeU.png" alt="" width="319"><h2 id="笛卡尔坐标系">笛卡尔坐标系</h2><h3 id="ticks-and-ticklabels">ticks and ticklabels</h3><p>xlocater/xticks: (1) 直接输入int, 触发<strong>MultipleLocator</strong>，每隔int设置一个tick。</p><p>例xlocater=30</p><p>(2) 直接输入list，触发<strong>FixedLocator</strong>，ticks根据list中的值确定。</p><p>例xlocator=[0, 0.3, 0.8, 1.6, 4.4, 8, 8.8]</p><p>(3) 线性<strong>LinearLocator</strong></p><p>例xlocator=(‘linear’, 21)，根据xlim线性等分，设置21个ticks</p><p>(4) 对数<strong>LogLocator</strong></p><p>例xlocator=‘log’，对数坐标</p><p>(5)最多刻度数<strong>MaxNLocator</strong></p><p>例xlocator=(‘maxn’, 11)</p><p>(6) 无刻度<strong>NullLocator</strong></p><p>例xlocator=‘null’，没有ticks</p><div class="note success simple"><p>图像示例参见官方文档</p><p>ylocater/yticks同理。matplotlib中的Func自定义坐标轴趋势没有测试。即使不能在proplot中实现，将ax单独拎出来可以通过matplotlib实现。</p><p>还有xminorlocator，yminorlocator参数</p><p>此外还有xlim，ylim参数设置上下限。例xlim=(0, 10)</p></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相关命令以及本地文件备份</title>
      <link href="/2022/05/22/test/"/>
      <url>/2022/05/22/test/</url>
      
        <content type="html"><![CDATA[<p>今天为了整博客的图库差点把博客源文件整没了。恢复以后，尝试了很久在github上备份本地博客文件。参考了以下文章：<br><a href="https://blog.csdn.net/weixin_44861399/article/details/104936907">博客备份与换设备</a></p><p>在这里顺便写点hexo相关命令，防止以后忘记了。</p><h5 id="清除和再生成-大概是这个意思吧">清除和再生成 (大概是这个意思吧)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><h5 id="部署至github">部署至github</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h5 id="生成静态地址-本地">生成静态地址(本地)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h5 id="新建文章">新建文章</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h5 id="将静态文件推送到master分支">将静态文件推送到master分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h5 id="将相关更改推送到hexo分支">将相关更改推送到hexo分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;发表文章test&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章！！！O(∩_∩)O哈哈~</title>
      <link href="/2022/05/19/firstblogxhw/"/>
      <url>/2022/05/19/firstblogxhw/</url>
      
        <content type="html"><![CDATA[<h1>第一篇文章！！！</h1><p>这是第一篇文章，测试一下效果</p><p>本博客计划写一些<font color=blue><strong>气象</strong></font>方面的学习经验。如<font color=blue><em><strong>气象编程、学习笔记、文献回顾总结</strong></em></font>。</p><p>另外还有<font color=green><strong>英语学习</strong>。<em>如口语句式、学术论文写作笔记</em></font>。</p><p>最后可能有一些<font color=red><strong>日记性质的文章</strong></font>，记录自己五年读博生涯。</p><p>下面测试一下<mark style="background-color：yellow">markdown</mark></p><h3 id="1-首先是代码块">1. 首先是代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%% 去趋势1979-2020,春、秋季位势高度</span></span><br><span class="line">temp = data2.sel(time=<span class="built_in">slice</span>(<span class="string">&#x27;1979&#x27;</span>,<span class="string">&#x27;2020&#x27;</span>))</span><br><span class="line">hgt500Spring1979_2020Detrend = temp.sel(time=temp[<span class="string">&#x27;time.season&#x27;</span>]==<span class="string">&#x27;MAM&#x27;</span>).mean(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">hgt500Autumn1979_2020Detrend = temp.sel(time=temp[<span class="string">&#x27;time.season&#x27;</span>]==<span class="string">&#x27;SON&#x27;</span>).mean(<span class="string">&#x27;time&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-然后是图片">2. 然后是图片</h3><p><img src="https://s1.ax1x.com/2023/03/30/pp2EaFA.jpg#pic_center" alt="惠"></p><h3 id="3-试一下公式">3. 试一下公式</h3><p>$y={x^2}$<br>$y = {x^2} + 2x - { {\rm{T} }_0} + {\mu ^4}\sqrt { { {\rm{v} }^2} + {b^2} }$</p><p>update test哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/17/hello-world/"/>
      <url>/2022/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
